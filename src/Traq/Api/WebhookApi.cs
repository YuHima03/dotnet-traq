// <auto-generated>
/*
 * traQ v3
 *
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Traq.Client;
using Traq.Model;
using System.Diagnostics.CodeAnalysis;

namespace Traq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IWebhookApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        WebhookApiEvents Events { get; }

        /// <summary>
        /// Webhookのアイコンを変更
        /// </summary>
        /// <remarks>
        /// 指定したWebhookのアイコン画像を変更します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="file">アイコン画像(2MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeWebhookIconApiResponse"/>&gt;</returns>
        Task<IChangeWebhookIconApiResponse> ChangeWebhookIconAsync(Guid webhookId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookのアイコンを変更
        /// </summary>
        /// <remarks>
        /// 指定したWebhookのアイコン画像を変更します。
        /// </remarks>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="file">アイコン画像(2MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeWebhookIconApiResponse"/>?&gt;</returns>
        Task<IChangeWebhookIconApiResponse?> ChangeWebhookIconOrDefaultAsync(Guid webhookId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookを新規作成
        /// </summary>
        /// <remarks>
        /// Webhookを新規作成します。 &#x60;secret&#x60;が空文字の場合、insecureウェブフックが作成されます。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postWebhookRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateWebhookApiResponse"/>&gt;</returns>
        Task<ICreateWebhookApiResponse> CreateWebhookAsync(Option<PostWebhookRequest> postWebhookRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookを新規作成
        /// </summary>
        /// <remarks>
        /// Webhookを新規作成します。 &#x60;secret&#x60;が空文字の場合、insecureウェブフックが作成されます。
        /// </remarks>
        /// <param name="postWebhookRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateWebhookApiResponse"/>?&gt;</returns>
        Task<ICreateWebhookApiResponse?> CreateWebhookOrDefaultAsync(Option<PostWebhookRequest> postWebhookRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookを削除
        /// </summary>
        /// <remarks>
        /// 指定したWebhookを削除します。 Webhookによって投稿されたメッセージは削除されません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteWebhookApiResponse"/>&gt;</returns>
        Task<IDeleteWebhookApiResponse> DeleteWebhookAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookを削除
        /// </summary>
        /// <remarks>
        /// 指定したWebhookを削除します。 Webhookによって投稿されたメッセージは削除されません。
        /// </remarks>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteWebhookApiResponse"/>?&gt;</returns>
        Task<IDeleteWebhookApiResponse?> DeleteWebhookOrDefaultAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhook情報を変更
        /// </summary>
        /// <remarks>
        /// 指定したWebhookの情報を変更します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="patchWebhookRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditWebhookApiResponse"/>&gt;</returns>
        Task<IEditWebhookApiResponse> EditWebhookAsync(Guid webhookId, Option<PatchWebhookRequest> patchWebhookRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhook情報を変更
        /// </summary>
        /// <remarks>
        /// 指定したWebhookの情報を変更します。
        /// </remarks>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="patchWebhookRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditWebhookApiResponse"/>?&gt;</returns>
        Task<IEditWebhookApiResponse?> EditWebhookOrDefaultAsync(Guid webhookId, Option<PatchWebhookRequest> patchWebhookRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhook情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したWebhookの詳細を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookApiResponse"/>&gt;</returns>
        Task<IGetWebhookApiResponse> GetWebhookAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhook情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したWebhookの詳細を取得します。
        /// </remarks>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookApiResponse"/>?&gt;</returns>
        Task<IGetWebhookApiResponse?> GetWebhookOrDefaultAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookのアイコンを取得
        /// </summary>
        /// <remarks>
        /// 指定したWebhookのアイコン画像を取得します
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookIconApiResponse"/>&gt;</returns>
        Task<IGetWebhookIconApiResponse> GetWebhookIconAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookのアイコンを取得
        /// </summary>
        /// <remarks>
        /// 指定したWebhookのアイコン画像を取得します
        /// </remarks>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookIconApiResponse"/>?&gt;</returns>
        Task<IGetWebhookIconApiResponse?> GetWebhookIconOrDefaultAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookの投稿メッセージのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定されたWebhookが投稿したメッセージのリストを返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookMessagesApiResponse"/>&gt;</returns>
        Task<IGetWebhookMessagesApiResponse> GetWebhookMessagesAsync(Guid webhookId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookの投稿メッセージのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定されたWebhookが投稿したメッセージのリストを返します。
        /// </remarks>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookMessagesApiResponse"/>?&gt;</returns>
        Task<IGetWebhookMessagesApiResponse?> GetWebhookMessagesOrDefaultAsync(Guid webhookId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhook情報のリストを取得します
        /// </summary>
        /// <remarks>
        /// Webhookのリストを取得します。 allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="all">全てのWebhookを取得します。権限が必要です。 (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhooksApiResponse"/>&gt;</returns>
        Task<IGetWebhooksApiResponse> GetWebhooksAsync(Option<bool> all = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhook情報のリストを取得します
        /// </summary>
        /// <remarks>
        /// Webhookのリストを取得します。 allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。
        /// </remarks>
        /// <param name="all">全てのWebhookを取得します。権限が必要です。 (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhooksApiResponse"/>?&gt;</returns>
        Task<IGetWebhooksApiResponse?> GetWebhooksOrDefaultAsync(Option<bool> all = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookを送信
        /// </summary>
        /// <remarks>
        /// Webhookにメッセージを投稿します。 secureなウェブフックに対しては&#x60;X-TRAQ-Signature&#x60;ヘッダーが必須です。 アーカイブされているチャンネルには投稿できません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="xTRAQSignature">リクエストボディシグネチャ(Secretが設定されている場合は必須) (optional)</param>
        /// <param name="xTRAQChannelId">投稿先のチャンネルID(変更する場合) (optional)</param>
        /// <param name="embed">メンション・チャンネルリンクを自動埋め込みする場合に1を指定する (optional, default to 0)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostWebhookApiResponse"/>&gt;</returns>
        Task<IPostWebhookApiResponse> PostWebhookAsync(Guid webhookId, Option<string> xTRAQSignature = default, Option<string> xTRAQChannelId = default, Option<int> embed = default, Option<string> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Webhookを送信
        /// </summary>
        /// <remarks>
        /// Webhookにメッセージを投稿します。 secureなウェブフックに対しては&#x60;X-TRAQ-Signature&#x60;ヘッダーが必須です。 アーカイブされているチャンネルには投稿できません。
        /// </remarks>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="xTRAQSignature">リクエストボディシグネチャ(Secretが設定されている場合は必須) (optional)</param>
        /// <param name="xTRAQChannelId">投稿先のチャンネルID(変更する場合) (optional)</param>
        /// <param name="embed">メンション・チャンネルリンクを自動埋め込みする場合に1を指定する (optional, default to 0)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostWebhookApiResponse"/>?&gt;</returns>
        Task<IPostWebhookApiResponse?> PostWebhookOrDefaultAsync(Guid webhookId, Option<string> xTRAQSignature = default, Option<string> xTRAQChannelId = default, Option<int> embed = default, Option<string> body = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IChangeWebhookIconApiResponse"/>
    /// </summary>
    public interface IChangeWebhookIconApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 413 ContentTooLarge
        /// </summary>
        /// <returns></returns>
        bool IsContentTooLarge { get; }
    }

    /// <summary>
    /// The <see cref="ICreateWebhookApiResponse"/>
    /// </summary>
    public interface ICreateWebhookApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.Webhook?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteWebhookApiResponse"/>
    /// </summary>
    public interface IDeleteWebhookApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IEditWebhookApiResponse"/>
    /// </summary>
    public interface IEditWebhookApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetWebhookApiResponse"/>
    /// </summary>
    public interface IGetWebhookApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.Webhook?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetWebhookIconApiResponse"/>
    /// </summary>
    public interface IGetWebhookIconApiResponse : Traq.Client.IApiResponse, IOk<System.IO.Stream?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetWebhookMessagesApiResponse"/>
    /// </summary>
    public interface IGetWebhookMessagesApiResponse : Traq.Client.IApiResponse, IOk<List<Message>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetWebhooksApiResponse"/>
    /// </summary>
    public interface IGetWebhooksApiResponse : Traq.Client.IApiResponse, IOk<List<Webhook>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IPostWebhookApiResponse"/>
    /// </summary>
    public interface IPostWebhookApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class WebhookApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeWebhookIcon;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeWebhookIcon;

        internal void ExecuteOnChangeWebhookIcon(WebhookApi.ChangeWebhookIconApiResponse apiResponse)
        {
            OnChangeWebhookIcon?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeWebhookIcon(Exception exception)
        {
            OnErrorChangeWebhookIcon?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateWebhook;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateWebhook;

        internal void ExecuteOnCreateWebhook(WebhookApi.CreateWebhookApiResponse apiResponse)
        {
            OnCreateWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateWebhook(Exception exception)
        {
            OnErrorCreateWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteWebhook;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteWebhook;

        internal void ExecuteOnDeleteWebhook(WebhookApi.DeleteWebhookApiResponse apiResponse)
        {
            OnDeleteWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteWebhook(Exception exception)
        {
            OnErrorDeleteWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditWebhook;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditWebhook;

        internal void ExecuteOnEditWebhook(WebhookApi.EditWebhookApiResponse apiResponse)
        {
            OnEditWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditWebhook(Exception exception)
        {
            OnErrorEditWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetWebhook;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetWebhook;

        internal void ExecuteOnGetWebhook(WebhookApi.GetWebhookApiResponse apiResponse)
        {
            OnGetWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetWebhook(Exception exception)
        {
            OnErrorGetWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetWebhookIcon;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetWebhookIcon;

        internal void ExecuteOnGetWebhookIcon(WebhookApi.GetWebhookIconApiResponse apiResponse)
        {
            OnGetWebhookIcon?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetWebhookIcon(Exception exception)
        {
            OnErrorGetWebhookIcon?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetWebhookMessages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetWebhookMessages;

        internal void ExecuteOnGetWebhookMessages(WebhookApi.GetWebhookMessagesApiResponse apiResponse)
        {
            OnGetWebhookMessages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetWebhookMessages(Exception exception)
        {
            OnErrorGetWebhookMessages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetWebhooks;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetWebhooks;

        internal void ExecuteOnGetWebhooks(WebhookApi.GetWebhooksApiResponse apiResponse)
        {
            OnGetWebhooks?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetWebhooks(Exception exception)
        {
            OnErrorGetWebhooks?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostWebhook;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostWebhook;

        internal void ExecuteOnPostWebhook(WebhookApi.PostWebhookApiResponse apiResponse)
        {
            OnPostWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostWebhook(Exception exception)
        {
            OnErrorPostWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class WebhookApi : IWebhookApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<WebhookApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public WebhookApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="WebhookApi"/> class.
        /// </summary>
        /// <returns></returns>
        public WebhookApi(ILogger<WebhookApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, WebhookApiEvents webhookApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<WebhookApi>();
            HttpClient = httpClient;
            Events = webhookApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatChangeWebhookIcon(ref Guid webhookId, ref System.IO.Stream file);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="file"></param>
        /// <returns></returns>
        private void ValidateChangeWebhookIcon(System.IO.Stream file)
        {
            if (file == null)
                throw new ArgumentNullException(nameof(file));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        /// <param name="file"></param>
        private void AfterChangeWebhookIconDefaultImplementation(IChangeWebhookIconApiResponse apiResponseLocalVar, Guid webhookId, System.IO.Stream file)
        {
            bool suppressDefaultLog = false;
            AfterChangeWebhookIcon(ref suppressDefaultLog, apiResponseLocalVar, webhookId, file);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        /// <param name="file"></param>
        partial void AfterChangeWebhookIcon(ref bool suppressDefaultLog, IChangeWebhookIconApiResponse apiResponseLocalVar, Guid webhookId, System.IO.Stream file);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        /// <param name="file"></param>
        private void OnErrorChangeWebhookIconDefaultImplementation(Exception exception, string pathFormat, string path, Guid webhookId, System.IO.Stream file)
        {
            bool suppressDefaultLog = false;
            OnErrorChangeWebhookIcon(ref suppressDefaultLog, exception, pathFormat, path, webhookId, file);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        /// <param name="file"></param>
        partial void OnErrorChangeWebhookIcon(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid webhookId, System.IO.Stream file);

        /// <summary>
        /// Webhookのアイコンを変更 指定したWebhookのアイコン画像を変更します。
        /// </summary>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="file">アイコン画像(2MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeWebhookIconApiResponse"/>&gt;</returns>
        public async Task<IChangeWebhookIconApiResponse?> ChangeWebhookIconOrDefaultAsync(Guid webhookId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeWebhookIconAsync(webhookId, file, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Webhookのアイコンを変更 指定したWebhookのアイコン画像を変更します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="file">アイコン画像(2MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeWebhookIconApiResponse"/>&gt;</returns>
        public async Task<IChangeWebhookIconApiResponse> ChangeWebhookIconAsync(Guid webhookId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeWebhookIcon(file);

                FormatChangeWebhookIcon(ref webhookId, ref file);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/webhooks/{webhookId}/icon";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));                    multipartContentLocalVar.Add(new StreamContent(file));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "multipart/form-data"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeWebhookIconApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeWebhookIconApiResponse>();

                        ChangeWebhookIconApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webhooks/{webhookId}/icon", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeWebhookIconDefaultImplementation(apiResponseLocalVar, webhookId, file);

                        Events.ExecuteOnChangeWebhookIcon(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeWebhookIconDefaultImplementation(e, "/webhooks/{webhookId}/icon", uriBuilderLocalVar.Path, webhookId, file);
                Events.ExecuteOnErrorChangeWebhookIcon(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeWebhookIconApiResponse"/>
        /// </summary>
        public partial class ChangeWebhookIconApiResponse : Traq.Client.ApiResponse, IChangeWebhookIconApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeWebhookIconApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeWebhookIconApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeWebhookIconApiResponse(ILogger<ChangeWebhookIconApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 413 ContentTooLarge
            /// </summary>
            /// <returns></returns>
            public bool IsContentTooLarge => 413 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateWebhook(Option<PostWebhookRequest> postWebhookRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postWebhookRequest"></param>
        /// <returns></returns>
        private void ValidateCreateWebhook(Option<PostWebhookRequest> postWebhookRequest)
        {
            if (postWebhookRequest.IsSet && postWebhookRequest.Value == null)
                throw new ArgumentNullException(nameof(postWebhookRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postWebhookRequest"></param>
        private void AfterCreateWebhookDefaultImplementation(ICreateWebhookApiResponse apiResponseLocalVar, Option<PostWebhookRequest> postWebhookRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateWebhook(ref suppressDefaultLog, apiResponseLocalVar, postWebhookRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postWebhookRequest"></param>
        partial void AfterCreateWebhook(ref bool suppressDefaultLog, ICreateWebhookApiResponse apiResponseLocalVar, Option<PostWebhookRequest> postWebhookRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postWebhookRequest"></param>
        private void OnErrorCreateWebhookDefaultImplementation(Exception exception, string pathFormat, string path, Option<PostWebhookRequest> postWebhookRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorCreateWebhook(ref suppressDefaultLog, exception, pathFormat, path, postWebhookRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postWebhookRequest"></param>
        partial void OnErrorCreateWebhook(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<PostWebhookRequest> postWebhookRequest);

        /// <summary>
        /// Webhookを新規作成 Webhookを新規作成します。 &#x60;secret&#x60;が空文字の場合、insecureウェブフックが作成されます。
        /// </summary>
        /// <param name="postWebhookRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateWebhookApiResponse"/>&gt;</returns>
        public async Task<ICreateWebhookApiResponse?> CreateWebhookOrDefaultAsync(Option<PostWebhookRequest> postWebhookRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateWebhookAsync(postWebhookRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Webhookを新規作成 Webhookを新規作成します。 &#x60;secret&#x60;が空文字の場合、insecureウェブフックが作成されます。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postWebhookRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateWebhookApiResponse"/>&gt;</returns>
        public async Task<ICreateWebhookApiResponse> CreateWebhookAsync(Option<PostWebhookRequest> postWebhookRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateWebhook(postWebhookRequest);

                FormatCreateWebhook(postWebhookRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/webhooks";

                    if (postWebhookRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postWebhookRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postWebhookRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateWebhookApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateWebhookApiResponse>();

                        CreateWebhookApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webhooks", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateWebhookDefaultImplementation(apiResponseLocalVar, postWebhookRequest);

                        Events.ExecuteOnCreateWebhook(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateWebhookDefaultImplementation(e, "/webhooks", uriBuilderLocalVar.Path, postWebhookRequest);
                Events.ExecuteOnErrorCreateWebhook(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateWebhookApiResponse"/>
        /// </summary>
        public partial class CreateWebhookApiResponse : Traq.Client.ApiResponse, ICreateWebhookApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateWebhookApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateWebhookApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateWebhookApiResponse(ILogger<CreateWebhookApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.Webhook? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.Webhook>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.Webhook? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteWebhook(ref Guid webhookId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        private void AfterDeleteWebhookDefaultImplementation(IDeleteWebhookApiResponse apiResponseLocalVar, Guid webhookId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteWebhook(ref suppressDefaultLog, apiResponseLocalVar, webhookId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        partial void AfterDeleteWebhook(ref bool suppressDefaultLog, IDeleteWebhookApiResponse apiResponseLocalVar, Guid webhookId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        private void OnErrorDeleteWebhookDefaultImplementation(Exception exception, string pathFormat, string path, Guid webhookId)
        {
            bool suppressDefaultLog = false;
            OnErrorDeleteWebhook(ref suppressDefaultLog, exception, pathFormat, path, webhookId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        partial void OnErrorDeleteWebhook(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid webhookId);

        /// <summary>
        /// Webhookを削除 指定したWebhookを削除します。 Webhookによって投稿されたメッセージは削除されません。
        /// </summary>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteWebhookApiResponse"/>&gt;</returns>
        public async Task<IDeleteWebhookApiResponse?> DeleteWebhookOrDefaultAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteWebhookAsync(webhookId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Webhookを削除 指定したWebhookを削除します。 Webhookによって投稿されたメッセージは削除されません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteWebhookApiResponse"/>&gt;</returns>
        public async Task<IDeleteWebhookApiResponse> DeleteWebhookAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteWebhook(ref webhookId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/webhooks/{webhookId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteWebhookApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteWebhookApiResponse>();

                        DeleteWebhookApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webhooks/{webhookId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteWebhookDefaultImplementation(apiResponseLocalVar, webhookId);

                        Events.ExecuteOnDeleteWebhook(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteWebhookDefaultImplementation(e, "/webhooks/{webhookId}", uriBuilderLocalVar.Path, webhookId);
                Events.ExecuteOnErrorDeleteWebhook(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteWebhookApiResponse"/>
        /// </summary>
        public partial class DeleteWebhookApiResponse : Traq.Client.ApiResponse, IDeleteWebhookApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteWebhookApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteWebhookApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteWebhookApiResponse(ILogger<DeleteWebhookApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditWebhook(ref Guid webhookId, Option<PatchWebhookRequest> patchWebhookRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="patchWebhookRequest"></param>
        /// <returns></returns>
        private void ValidateEditWebhook(Option<PatchWebhookRequest> patchWebhookRequest)
        {
            if (patchWebhookRequest.IsSet && patchWebhookRequest.Value == null)
                throw new ArgumentNullException(nameof(patchWebhookRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        /// <param name="patchWebhookRequest"></param>
        private void AfterEditWebhookDefaultImplementation(IEditWebhookApiResponse apiResponseLocalVar, Guid webhookId, Option<PatchWebhookRequest> patchWebhookRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditWebhook(ref suppressDefaultLog, apiResponseLocalVar, webhookId, patchWebhookRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        /// <param name="patchWebhookRequest"></param>
        partial void AfterEditWebhook(ref bool suppressDefaultLog, IEditWebhookApiResponse apiResponseLocalVar, Guid webhookId, Option<PatchWebhookRequest> patchWebhookRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        /// <param name="patchWebhookRequest"></param>
        private void OnErrorEditWebhookDefaultImplementation(Exception exception, string pathFormat, string path, Guid webhookId, Option<PatchWebhookRequest> patchWebhookRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditWebhook(ref suppressDefaultLog, exception, pathFormat, path, webhookId, patchWebhookRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        /// <param name="patchWebhookRequest"></param>
        partial void OnErrorEditWebhook(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid webhookId, Option<PatchWebhookRequest> patchWebhookRequest);

        /// <summary>
        /// Webhook情報を変更 指定したWebhookの情報を変更します。
        /// </summary>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="patchWebhookRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditWebhookApiResponse"/>&gt;</returns>
        public async Task<IEditWebhookApiResponse?> EditWebhookOrDefaultAsync(Guid webhookId, Option<PatchWebhookRequest> patchWebhookRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditWebhookAsync(webhookId, patchWebhookRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Webhook情報を変更 指定したWebhookの情報を変更します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="patchWebhookRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditWebhookApiResponse"/>&gt;</returns>
        public async Task<IEditWebhookApiResponse> EditWebhookAsync(Guid webhookId, Option<PatchWebhookRequest> patchWebhookRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditWebhook(patchWebhookRequest);

                FormatEditWebhook(ref webhookId, patchWebhookRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/webhooks/{webhookId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    if (patchWebhookRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchWebhookRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchWebhookRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditWebhookApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditWebhookApiResponse>();

                        EditWebhookApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webhooks/{webhookId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditWebhookDefaultImplementation(apiResponseLocalVar, webhookId, patchWebhookRequest);

                        Events.ExecuteOnEditWebhook(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditWebhookDefaultImplementation(e, "/webhooks/{webhookId}", uriBuilderLocalVar.Path, webhookId, patchWebhookRequest);
                Events.ExecuteOnErrorEditWebhook(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditWebhookApiResponse"/>
        /// </summary>
        public partial class EditWebhookApiResponse : Traq.Client.ApiResponse, IEditWebhookApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditWebhookApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditWebhookApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditWebhookApiResponse(ILogger<EditWebhookApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetWebhook(ref Guid webhookId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        private void AfterGetWebhookDefaultImplementation(IGetWebhookApiResponse apiResponseLocalVar, Guid webhookId)
        {
            bool suppressDefaultLog = false;
            AfterGetWebhook(ref suppressDefaultLog, apiResponseLocalVar, webhookId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        partial void AfterGetWebhook(ref bool suppressDefaultLog, IGetWebhookApiResponse apiResponseLocalVar, Guid webhookId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        private void OnErrorGetWebhookDefaultImplementation(Exception exception, string pathFormat, string path, Guid webhookId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetWebhook(ref suppressDefaultLog, exception, pathFormat, path, webhookId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        partial void OnErrorGetWebhook(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid webhookId);

        /// <summary>
        /// Webhook情報を取得 指定したWebhookの詳細を取得します。
        /// </summary>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookApiResponse"/>&gt;</returns>
        public async Task<IGetWebhookApiResponse?> GetWebhookOrDefaultAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetWebhookAsync(webhookId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Webhook情報を取得 指定したWebhookの詳細を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookApiResponse"/>&gt;</returns>
        public async Task<IGetWebhookApiResponse> GetWebhookAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetWebhook(ref webhookId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/webhooks/{webhookId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetWebhookApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetWebhookApiResponse>();

                        GetWebhookApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webhooks/{webhookId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetWebhookDefaultImplementation(apiResponseLocalVar, webhookId);

                        Events.ExecuteOnGetWebhook(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetWebhookDefaultImplementation(e, "/webhooks/{webhookId}", uriBuilderLocalVar.Path, webhookId);
                Events.ExecuteOnErrorGetWebhook(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetWebhookApiResponse"/>
        /// </summary>
        public partial class GetWebhookApiResponse : Traq.Client.ApiResponse, IGetWebhookApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetWebhookApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetWebhookApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebhookApiResponse(ILogger<GetWebhookApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.Webhook? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.Webhook>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.Webhook? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetWebhookIcon(ref Guid webhookId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        private void AfterGetWebhookIconDefaultImplementation(IGetWebhookIconApiResponse apiResponseLocalVar, Guid webhookId)
        {
            bool suppressDefaultLog = false;
            AfterGetWebhookIcon(ref suppressDefaultLog, apiResponseLocalVar, webhookId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        partial void AfterGetWebhookIcon(ref bool suppressDefaultLog, IGetWebhookIconApiResponse apiResponseLocalVar, Guid webhookId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        private void OnErrorGetWebhookIconDefaultImplementation(Exception exception, string pathFormat, string path, Guid webhookId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetWebhookIcon(ref suppressDefaultLog, exception, pathFormat, path, webhookId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        partial void OnErrorGetWebhookIcon(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid webhookId);

        /// <summary>
        /// Webhookのアイコンを取得 指定したWebhookのアイコン画像を取得します
        /// </summary>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookIconApiResponse"/>&gt;</returns>
        public async Task<IGetWebhookIconApiResponse?> GetWebhookIconOrDefaultAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetWebhookIconAsync(webhookId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Webhookのアイコンを取得 指定したWebhookのアイコン画像を取得します
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookIconApiResponse"/>&gt;</returns>
        public async Task<IGetWebhookIconApiResponse> GetWebhookIconAsync(Guid webhookId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetWebhookIcon(ref webhookId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/webhooks/{webhookId}/icon";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "image/jpeg",
                        "image/gif",
                        "image/png"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetWebhookIconApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetWebhookIconApiResponse>();

                        GetWebhookIconApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webhooks/{webhookId}/icon", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetWebhookIconDefaultImplementation(apiResponseLocalVar, webhookId);

                        Events.ExecuteOnGetWebhookIcon(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetWebhookIconDefaultImplementation(e, "/webhooks/{webhookId}/icon", uriBuilderLocalVar.Path, webhookId);
                Events.ExecuteOnErrorGetWebhookIcon(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetWebhookIconApiResponse"/>
        /// </summary>
        public partial class GetWebhookIconApiResponse : Traq.Client.ApiResponse, IGetWebhookIconApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetWebhookIconApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetWebhookIconApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebhookIconApiResponse(ILogger<GetWebhookIconApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public System.IO.Stream? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<System.IO.Stream>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out System.IO.Stream? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetWebhookMessages(ref Guid webhookId, ref Option<int> limit, ref Option<int> offset, ref Option<DateTimeOffset> since, ref Option<DateTimeOffset> until, ref Option<bool> inclusive, ref Option<string> order);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="order"></param>
        /// <returns></returns>
        private void ValidateGetWebhookMessages(Option<string> order)
        {
            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        private void AfterGetWebhookMessagesDefaultImplementation(IGetWebhookMessagesApiResponse apiResponseLocalVar, Guid webhookId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order)
        {
            bool suppressDefaultLog = false;
            AfterGetWebhookMessages(ref suppressDefaultLog, apiResponseLocalVar, webhookId, limit, offset, since, until, inclusive, order);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        partial void AfterGetWebhookMessages(ref bool suppressDefaultLog, IGetWebhookMessagesApiResponse apiResponseLocalVar, Guid webhookId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        private void OnErrorGetWebhookMessagesDefaultImplementation(Exception exception, string pathFormat, string path, Guid webhookId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order)
        {
            bool suppressDefaultLog = false;
            OnErrorGetWebhookMessages(ref suppressDefaultLog, exception, pathFormat, path, webhookId, limit, offset, since, until, inclusive, order);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        partial void OnErrorGetWebhookMessages(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid webhookId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order);

        /// <summary>
        /// Webhookの投稿メッセージのリストを取得 指定されたWebhookが投稿したメッセージのリストを返します。
        /// </summary>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookMessagesApiResponse"/>&gt;</returns>
        public async Task<IGetWebhookMessagesApiResponse?> GetWebhookMessagesOrDefaultAsync(Guid webhookId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetWebhookMessagesAsync(webhookId, limit, offset, since, until, inclusive, order, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Webhookの投稿メッセージのリストを取得 指定されたWebhookが投稿したメッセージのリストを返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhookMessagesApiResponse"/>&gt;</returns>
        public async Task<IGetWebhookMessagesApiResponse> GetWebhookMessagesAsync(Guid webhookId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetWebhookMessages(order);

                FormatGetWebhookMessages(ref webhookId, ref limit, ref offset, ref since, ref until, ref inclusive, ref order);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/webhooks/{webhookId}/messages";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (until.IsSet)
                        parseQueryStringLocalVar["until"] = ClientUtils.ParameterToString(until.Value);

                    if (inclusive.IsSet)
                        parseQueryStringLocalVar["inclusive"] = ClientUtils.ParameterToString(inclusive.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetWebhookMessagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetWebhookMessagesApiResponse>();

                        GetWebhookMessagesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webhooks/{webhookId}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetWebhookMessagesDefaultImplementation(apiResponseLocalVar, webhookId, limit, offset, since, until, inclusive, order);

                        Events.ExecuteOnGetWebhookMessages(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetWebhookMessagesDefaultImplementation(e, "/webhooks/{webhookId}/messages", uriBuilderLocalVar.Path, webhookId, limit, offset, since, until, inclusive, order);
                Events.ExecuteOnErrorGetWebhookMessages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetWebhookMessagesApiResponse"/>
        /// </summary>
        public partial class GetWebhookMessagesApiResponse : Traq.Client.ApiResponse, IGetWebhookMessagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetWebhookMessagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetWebhookMessagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebhookMessagesApiResponse(ILogger<GetWebhookMessagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Message>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Message>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Message>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetWebhooks(ref Option<bool> all);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="all"></param>
        private void AfterGetWebhooksDefaultImplementation(IGetWebhooksApiResponse apiResponseLocalVar, Option<bool> all)
        {
            bool suppressDefaultLog = false;
            AfterGetWebhooks(ref suppressDefaultLog, apiResponseLocalVar, all);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="all"></param>
        partial void AfterGetWebhooks(ref bool suppressDefaultLog, IGetWebhooksApiResponse apiResponseLocalVar, Option<bool> all);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="all"></param>
        private void OnErrorGetWebhooksDefaultImplementation(Exception exception, string pathFormat, string path, Option<bool> all)
        {
            bool suppressDefaultLog = false;
            OnErrorGetWebhooks(ref suppressDefaultLog, exception, pathFormat, path, all);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="all"></param>
        partial void OnErrorGetWebhooks(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<bool> all);

        /// <summary>
        /// Webhook情報のリストを取得します Webhookのリストを取得します。 allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。
        /// </summary>
        /// <param name="all">全てのWebhookを取得します。権限が必要です。 (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhooksApiResponse"/>&gt;</returns>
        public async Task<IGetWebhooksApiResponse?> GetWebhooksOrDefaultAsync(Option<bool> all = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetWebhooksAsync(all, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Webhook情報のリストを取得します Webhookのリストを取得します。 allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="all">全てのWebhookを取得します。権限が必要です。 (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetWebhooksApiResponse"/>&gt;</returns>
        public async Task<IGetWebhooksApiResponse> GetWebhooksAsync(Option<bool> all = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetWebhooks(ref all);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/webhooks";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (all.IsSet)
                        parseQueryStringLocalVar["all"] = ClientUtils.ParameterToString(all.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetWebhooksApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetWebhooksApiResponse>();

                        GetWebhooksApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webhooks", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetWebhooksDefaultImplementation(apiResponseLocalVar, all);

                        Events.ExecuteOnGetWebhooks(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetWebhooksDefaultImplementation(e, "/webhooks", uriBuilderLocalVar.Path, all);
                Events.ExecuteOnErrorGetWebhooks(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetWebhooksApiResponse"/>
        /// </summary>
        public partial class GetWebhooksApiResponse : Traq.Client.ApiResponse, IGetWebhooksApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetWebhooksApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetWebhooksApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetWebhooksApiResponse(ILogger<GetWebhooksApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Webhook>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Webhook>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Webhook>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostWebhook(ref Guid webhookId, ref Option<string> xTRAQSignature, ref Option<string> xTRAQChannelId, ref Option<int> embed, ref Option<string> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xTRAQSignature"></param>
        /// <param name="xTRAQChannelId"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidatePostWebhook(Option<string> xTRAQSignature, Option<string> xTRAQChannelId, Option<string> body)
        {
            if (xTRAQSignature.IsSet && xTRAQSignature.Value == null)
                throw new ArgumentNullException(nameof(xTRAQSignature));

            if (xTRAQChannelId.IsSet && xTRAQChannelId.Value == null)
                throw new ArgumentNullException(nameof(xTRAQChannelId));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        /// <param name="xTRAQSignature"></param>
        /// <param name="xTRAQChannelId"></param>
        /// <param name="embed"></param>
        /// <param name="body"></param>
        private void AfterPostWebhookDefaultImplementation(IPostWebhookApiResponse apiResponseLocalVar, Guid webhookId, Option<string> xTRAQSignature, Option<string> xTRAQChannelId, Option<int> embed, Option<string> body)
        {
            bool suppressDefaultLog = false;
            AfterPostWebhook(ref suppressDefaultLog, apiResponseLocalVar, webhookId, xTRAQSignature, xTRAQChannelId, embed, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="webhookId"></param>
        /// <param name="xTRAQSignature"></param>
        /// <param name="xTRAQChannelId"></param>
        /// <param name="embed"></param>
        /// <param name="body"></param>
        partial void AfterPostWebhook(ref bool suppressDefaultLog, IPostWebhookApiResponse apiResponseLocalVar, Guid webhookId, Option<string> xTRAQSignature, Option<string> xTRAQChannelId, Option<int> embed, Option<string> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        /// <param name="xTRAQSignature"></param>
        /// <param name="xTRAQChannelId"></param>
        /// <param name="embed"></param>
        /// <param name="body"></param>
        private void OnErrorPostWebhookDefaultImplementation(Exception exception, string pathFormat, string path, Guid webhookId, Option<string> xTRAQSignature, Option<string> xTRAQChannelId, Option<int> embed, Option<string> body)
        {
            bool suppressDefaultLog = false;
            OnErrorPostWebhook(ref suppressDefaultLog, exception, pathFormat, path, webhookId, xTRAQSignature, xTRAQChannelId, embed, body);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="webhookId"></param>
        /// <param name="xTRAQSignature"></param>
        /// <param name="xTRAQChannelId"></param>
        /// <param name="embed"></param>
        /// <param name="body"></param>
        partial void OnErrorPostWebhook(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid webhookId, Option<string> xTRAQSignature, Option<string> xTRAQChannelId, Option<int> embed, Option<string> body);

        /// <summary>
        /// Webhookを送信 Webhookにメッセージを投稿します。 secureなウェブフックに対しては&#x60;X-TRAQ-Signature&#x60;ヘッダーが必須です。 アーカイブされているチャンネルには投稿できません。
        /// </summary>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="xTRAQSignature">リクエストボディシグネチャ(Secretが設定されている場合は必須) (optional)</param>
        /// <param name="xTRAQChannelId">投稿先のチャンネルID(変更する場合) (optional)</param>
        /// <param name="embed">メンション・チャンネルリンクを自動埋め込みする場合に1を指定する (optional, default to 0)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostWebhookApiResponse"/>&gt;</returns>
        public async Task<IPostWebhookApiResponse?> PostWebhookOrDefaultAsync(Guid webhookId, Option<string> xTRAQSignature = default, Option<string> xTRAQChannelId = default, Option<int> embed = default, Option<string> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostWebhookAsync(webhookId, xTRAQSignature, xTRAQChannelId, embed, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Webhookを送信 Webhookにメッセージを投稿します。 secureなウェブフックに対しては&#x60;X-TRAQ-Signature&#x60;ヘッダーが必須です。 アーカイブされているチャンネルには投稿できません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="webhookId">WebhookUUID</param>
        /// <param name="xTRAQSignature">リクエストボディシグネチャ(Secretが設定されている場合は必須) (optional)</param>
        /// <param name="xTRAQChannelId">投稿先のチャンネルID(変更する場合) (optional)</param>
        /// <param name="embed">メンション・チャンネルリンクを自動埋め込みする場合に1を指定する (optional, default to 0)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostWebhookApiResponse"/>&gt;</returns>
        public async Task<IPostWebhookApiResponse> PostWebhookAsync(Guid webhookId, Option<string> xTRAQSignature = default, Option<string> xTRAQChannelId = default, Option<int> embed = default, Option<string> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostWebhook(xTRAQSignature, xTRAQChannelId, body);

                FormatPostWebhook(ref webhookId, ref xTRAQSignature, ref xTRAQChannelId, ref embed, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/webhooks/{webhookId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (embed.IsSet)
                        parseQueryStringLocalVar["embed"] = ClientUtils.ParameterToString(embed.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTRAQSignature.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-TRAQ-Signature", ClientUtils.ParameterToString(xTRAQSignature.Value));

                    if (xTRAQChannelId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-TRAQ-Channel-Id", ClientUtils.ParameterToString(xTRAQChannelId.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "text/plain"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostWebhookApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostWebhookApiResponse>();

                        PostWebhookApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/webhooks/{webhookId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostWebhookDefaultImplementation(apiResponseLocalVar, webhookId, xTRAQSignature, xTRAQChannelId, embed, body);

                        Events.ExecuteOnPostWebhook(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostWebhookDefaultImplementation(e, "/webhooks/{webhookId}", uriBuilderLocalVar.Path, webhookId, xTRAQSignature, xTRAQChannelId, embed, body);
                Events.ExecuteOnErrorPostWebhook(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostWebhookApiResponse"/>
        /// </summary>
        public partial class PostWebhookApiResponse : Traq.Client.ApiResponse, IPostWebhookApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostWebhookApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostWebhookApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostWebhookApiResponse(ILogger<PostWebhookApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
