// <auto-generated>
/*
 * traQ v3
 *
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Traq.Client;
using Traq.Model;
using System.Diagnostics.CodeAnalysis;

namespace Traq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface INotificationApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        NotificationApiEvents Events { get; }

        /// <summary>
        /// チャンネルの通知購読者を編集
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの通知購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="patchChannelSubscribersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditChannelSubscribersApiResponse"/>&gt;</returns>
        Task<IEditChannelSubscribersApiResponse> EditChannelSubscribersAsync(Guid channelId, Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルの通知購読者を編集
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの通知購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
        /// </remarks>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="patchChannelSubscribersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditChannelSubscribersApiResponse"/>?&gt;</returns>
        Task<IEditChannelSubscribersApiResponse?> EditChannelSubscribersOrDefaultAsync(Guid channelId, Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルの通知購読者のリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelSubscribersApiResponse"/>&gt;</returns>
        Task<IGetChannelSubscribersApiResponse> GetChannelSubscribersAsync(Guid channelId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルの通知購読者のリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
        /// </remarks>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelSubscribersApiResponse"/>?&gt;</returns>
        Task<IGetChannelSubscribersApiResponse?> GetChannelSubscribersOrDefaultAsync(Guid channelId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のチャンネル購読状態を取得
        /// </summary>
        /// <remarks>
        /// 自身のチャンネル購読状態を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyChannelSubscriptionsApiResponse"/>&gt;</returns>
        Task<IGetMyChannelSubscriptionsApiResponse> GetMyChannelSubscriptionsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のチャンネル購読状態を取得
        /// </summary>
        /// <remarks>
        /// 自身のチャンネル購読状態を取得します。
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyChannelSubscriptionsApiResponse"/>?&gt;</returns>
        Task<IGetMyChannelSubscriptionsApiResponse?> GetMyChannelSubscriptionsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 未読チャンネルを取得
        /// </summary>
        /// <remarks>
        /// 自分が現在未読のチャンネルの未読情報を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyUnreadChannelsApiResponse"/>&gt;</returns>
        Task<IGetMyUnreadChannelsApiResponse> GetMyUnreadChannelsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 未読チャンネルを取得
        /// </summary>
        /// <remarks>
        /// 自分が現在未読のチャンネルの未読情報を取得します。
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyUnreadChannelsApiResponse"/>?&gt;</returns>
        Task<IGetMyUnreadChannelsApiResponse?> GetMyUnreadChannelsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自身のチャンネル閲覧状態一覧を取得
        /// </summary>
        /// <remarks>
        /// 自身のチャンネル閲覧状態一覧を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyViewStatesApiResponse"/>&gt;</returns>
        Task<IGetMyViewStatesApiResponse> GetMyViewStatesAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自身のチャンネル閲覧状態一覧を取得
        /// </summary>
        /// <remarks>
        /// 自身のチャンネル閲覧状態一覧を取得します。
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyViewStatesApiResponse"/>?&gt;</returns>
        Task<IGetMyViewStatesApiResponse?> GetMyViewStatesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルを既読にする
        /// </summary>
        /// <remarks>
        /// 自分が未読のチャンネルを既読にします。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReadChannelApiResponse"/>&gt;</returns>
        Task<IReadChannelApiResponse> ReadChannelAsync(Guid channelId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルを既読にする
        /// </summary>
        /// <remarks>
        /// 自分が未読のチャンネルを既読にします。
        /// </remarks>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReadChannelApiResponse"/>?&gt;</returns>
        Task<IReadChannelApiResponse?> ReadChannelOrDefaultAsync(Guid channelId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// FCMデバイスを登録
        /// </summary>
        /// <remarks>
        /// 自身のFCMデバイスを登録します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postMyFCMDeviceRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRegisterFCMDeviceApiResponse"/>&gt;</returns>
        Task<IRegisterFCMDeviceApiResponse> RegisterFCMDeviceAsync(Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// FCMデバイスを登録
        /// </summary>
        /// <remarks>
        /// 自身のFCMデバイスを登録します。
        /// </remarks>
        /// <param name="postMyFCMDeviceRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRegisterFCMDeviceApiResponse"/>?&gt;</returns>
        Task<IRegisterFCMDeviceApiResponse?> RegisterFCMDeviceOrDefaultAsync(Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネル購読レベルを設定
        /// </summary>
        /// <remarks>
        /// 自身の指定したチャンネルの購読レベルを設定します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="putChannelSubscribeLevelRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetChannelSubscribeLevelApiResponse"/>&gt;</returns>
        Task<ISetChannelSubscribeLevelApiResponse> SetChannelSubscribeLevelAsync(Guid channelId, Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネル購読レベルを設定
        /// </summary>
        /// <remarks>
        /// 自身の指定したチャンネルの購読レベルを設定します。
        /// </remarks>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="putChannelSubscribeLevelRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetChannelSubscribeLevelApiResponse"/>?&gt;</returns>
        Task<ISetChannelSubscribeLevelApiResponse?> SetChannelSubscribeLevelOrDefaultAsync(Guid channelId, Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルの通知購読者を設定
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの通知購読状態はオフになります。 また、存在しないユーザーを指定した場合は無視されます。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="putChannelSubscribersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetChannelSubscribersApiResponse"/>&gt;</returns>
        Task<ISetChannelSubscribersApiResponse> SetChannelSubscribersAsync(Guid channelId, Option<PutChannelSubscribersRequest> putChannelSubscribersRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルの通知購読者を設定
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの通知購読状態はオフになります。 また、存在しないユーザーを指定した場合は無視されます。
        /// </remarks>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="putChannelSubscribersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetChannelSubscribersApiResponse"/>?&gt;</returns>
        Task<ISetChannelSubscribersApiResponse?> SetChannelSubscribersOrDefaultAsync(Guid channelId, Option<PutChannelSubscribersRequest> putChannelSubscribersRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// WebSocket通知ストリームに接続します
        /// </summary>
        /// <remarks>
        /// # WebSocketプロトコル ## 送信 &#x60;コマンド:引数1:引数2:...&#x60;のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### &#x60;viewstate&#x60;コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  &#x60;viewstate:{チャンネルID}:{閲覧状態}&#x60; + チャンネルID: 対象のチャンネルID + 閲覧状態: &#x60;none&#x60;, &#x60;monitoring&#x60;, &#x60;editing&#x60;  最初の&#x60;viewstate&#x60;コマンドを送る前、または&#x60;viewstate:null&#x60;, &#x60;viewstate:&#x60;を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ### &#x60;rtcstate&#x60;コマンド 自分のWebRTC状態を変更する。 他のコネクションが既に状態を保持している場合、変更することができません。  &#x60;rtcstate:{チャンネルID}:({状態}:{セッションID})*&#x60;  コネクションが切断された場合、自分のWebRTC状態はリセットされます。  ### &#x60;timeline_streaming&#x60;コマンド 全てのパブリックチャンネルの&#x60;MESSAGE_CREATED&#x60;イベントを受け取るかどうかを設定する。 初期状態は&#x60;off&#x60;です。  &#x60;timeline_streaming:(on|off|true|false)&#x60;  ## 受信 TextMessageとして各種イベントが&#x60;type&#x60;と&#x60;body&#x60;を持つJSONとして非同期に送られます。  例: &#x60;&#x60;&#x60;json {\&quot;type\&quot;:\&quot;USER_ONLINE\&quot;,\&quot;body\&quot;:{\&quot;id\&quot;:\&quot;7dd8e07f-7f5d-4331-9176-b56a4299768b\&quot;}} &#x60;&#x60;&#x60;  ## イベント一覧  ### &#x60;USER_JOINED&#x60; ユーザーが新規登録された。  対象: 全員  + &#x60;id&#x60;: 登録されたユーザーのId  ### &#x60;USER_UPDATED&#x60; ユーザーの情報が更新された。  対象: 全員  + &#x60;id&#x60;: 情報が更新されたユーザーのId  ### &#x60;USER_TAGS_UPDATED&#x60; ユーザーのタグが更新された。  対象: 全員  + &#x60;id&#x60;: タグが更新されたユーザーのId + &#x60;tag_id&#x60;: 更新されたタグのId  ### &#x60;USER_ICON_UPDATED&#x60; ユーザーのアイコンが更新された。  対象: 全員  + &#x60;id&#x60;: アイコンが更新されたユーザーのId  ### &#x60;USER_WEBRTC_STATE_CHANGED&#x60; ユーザーのWebRTCの状態が変化した  対象: 全員  + &#x60;user_id&#x60;: 変更があったユーザーのId + &#x60;channel_id&#x60;: ユーザーの変更後の接続チャンネルのId + &#x60;sessions&#x60;: ユーザーの変更後の状態(配列)   + &#x60;state&#x60;: 状態   + &#x60;sessionId&#x60;: セッションID  ### &#x60;USER_VIEWSTATE_CHANGED&#x60; ユーザーのチャンネルの閲覧状態が変化した  対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て  + &#x60;view_states&#x60;: 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)   + &#x60;key&#x60;: WSセッションの識別子   + &#x60;channel_id&#x60;: 閲覧しているチャンネルId   + &#x60;state&#x60;: 閲覧状態  ### &#x60;USER_ONLINE&#x60; ユーザーがオンラインになった。  対象: 全員  + &#x60;id&#x60;: オンラインになったユーザーのId  ### &#x60;USER_OFFLINE&#x60; ユーザーがオフラインになった。  対象: 全員  + &#x60;id&#x60;: オフラインになったユーザーのId  ### &#x60;USER_GROUP_CREATED&#x60; ユーザーグループが作成された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_UPDATED&#x60; ユーザーグループが更新された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_DELETED&#x60; ユーザーグループが削除された  対象: 全員  + &#x60;id&#x60;: 削除されたユーザーグループのId  ### &#x60;CHANNEL_CREATED&#x60; チャンネルが新規作成された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 作成されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_UPDATED&#x60; チャンネルの情報が変更された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 変更があったチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_DELETED&#x60; チャンネルが削除された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 削除されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_STARED&#x60; 自分がチャンネルをスターした。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_UNSTARED&#x60; 自分がチャンネルのスターを解除した。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_VIEWERS_CHANGED&#x60; チャンネルの閲覧者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId + &#x60;viewers&#x60;: 変化後の閲覧者(配列)   + &#x60;userId&#x60;: ユーザーId   + &#x60;state&#x60;: 閲覧状態   + &#x60;updatedAt&#x60;: 閲覧状態の更新日時  ### &#x60;CHANNEL_SUBSCRIBERS_CHANGED&#x60; チャンネルの購読者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId  ### &#x60;MESSAGE_CREATED&#x60; メッセージが投稿された。  対象: 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー  + &#x60;id&#x60;: 投稿されたメッセージのId + &#x60;is_citing&#x60;: 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか  ### &#x60;MESSAGE_UPDATED&#x60; メッセージが更新された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 更新されたメッセージのId  ### &#x60;MESSAGE_DELETED&#x60; メッセージが削除された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 削除されたメッセージのId  ### &#x60;MESSAGE_STAMPED&#x60; メッセージにスタンプが押された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId + &#x60;count&#x60;: そのユーザーが押した数 + &#x60;created_at&#x60;: そのユーザーがそのスタンプをそのメッセージに最初に押した日時  ### &#x60;MESSAGE_UNSTAMPED&#x60; メッセージからスタンプが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId  ### &#x60;MESSAGE_PINNED&#x60; メッセージがピン留めされた。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンされたメッセージのID + &#x60;channel_id&#x60;: ピンされたメッセージのチャンネルID  ### &#x60;MESSAGE_UNPINNED&#x60; ピン留めされたメッセージのピンが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンが外されたメッセージのID + &#x60;channel_id&#x60;: ピンが外されたメッセージのチャンネルID  ### &#x60;MESSAGE_READ&#x60; 自分があるチャンネルのメッセージを読んだ。  対象: 自分  + &#x60;id&#x60;: 読んだチャンネルId  ### &#x60;STAMP_CREATED&#x60; スタンプが新しく追加された。  対象: 全員  + &#x60;id&#x60;: 作成されたスタンプのId  ### &#x60;STAMP_UPDATED&#x60; スタンプが修正された。  対象: 全員  + &#x60;id&#x60;: 修正されたスタンプのId  ### &#x60;STAMP_DELETED&#x60; スタンプが削除された。  対象: 全員  + &#x60;id&#x60;: 削除されたスタンプのId  ### &#x60;STAMP_PALETTE_CREATED&#x60; スタンプパレットが新しく追加された。  対象: 自分  + &#x60;id&#x60;: 作成されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_UPDATED&#x60; スタンプパレットが修正された。  対象: 自分  + &#x60;id&#x60;: 修正されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_DELETED&#x60; スタンプパレットが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたスタンプパレットのId  ### &#x60;CLIP_FOLDER_CREATED&#x60; クリップフォルダーが作成された。  対象：自分  + &#x60;id&#x60;: 作成されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_UPDATED&#x60; クリップフォルダーが修正された。  対象: 自分  + &#x60;id&#x60;: 更新されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_DELETED&#x60; クリップフォルダーが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_MESSAGE_DELETED&#x60; クリップフォルダーからメッセージが除外された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが除外されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーから除外されたメッセージのId  ### &#x60;CLIP_FOLDER_MESSAGE_ADDED&#x60; クリップフォルダーにメッセージが追加された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが追加されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーに追加されたメッセージのId  ### &#x60;QALL_ROOM_STATE_CHANGED&#x60; ルーム状態が変更された。  対象: 全員  + &#x60;room_id&#x60;: 変更されたルームのId + &#x60;state&#x60;: 変更後のルーム状態   + &#x60;roomId&#x60;: ルームのID   + &#x60;participants&#x60;: ルーム内の参加者(配列)     + &#x60;identity&#x60;: ユーザーID_RandomUUID     + &#x60;name&#x60;: 表示名     + &#x60;joinedAt&#x60;: 参加した時刻     + &#x60;attributes&#x60;: ユーザーに関連付けられたカスタム属性     + &#x60;canPublish&#x60;: 発言権限   + &#x60;isWebinar&#x60;: ウェビナールームかどうか   + &#x60;metadata&#x60;: ルームに関連付けられたカスタム属性  ### &#x60;QALL_SOUNDBOARD_ITEM_CREATED&#x60; サウンドボードアイテムが作成された。  対象: 全員  + &#x60;sound_id&#x60;: 作成されたサウンドのId + &#x60;name&#x60;: サウンド名 + &#x60;creator_id&#x60;: 作成者のId  ### &#x60;QALL_SOUNDBOARD_ITEM_DELETED&#x60; サウンドボードアイテムが削除された。  対象: 全員  + &#x60;sound_id&#x60;: 削除されたサウンドのId
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWsApiResponse"/>&gt;</returns>
        Task<IWsApiResponse> WsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// WebSocket通知ストリームに接続します
        /// </summary>
        /// <remarks>
        /// # WebSocketプロトコル ## 送信 &#x60;コマンド:引数1:引数2:...&#x60;のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### &#x60;viewstate&#x60;コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  &#x60;viewstate:{チャンネルID}:{閲覧状態}&#x60; + チャンネルID: 対象のチャンネルID + 閲覧状態: &#x60;none&#x60;, &#x60;monitoring&#x60;, &#x60;editing&#x60;  最初の&#x60;viewstate&#x60;コマンドを送る前、または&#x60;viewstate:null&#x60;, &#x60;viewstate:&#x60;を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ### &#x60;rtcstate&#x60;コマンド 自分のWebRTC状態を変更する。 他のコネクションが既に状態を保持している場合、変更することができません。  &#x60;rtcstate:{チャンネルID}:({状態}:{セッションID})*&#x60;  コネクションが切断された場合、自分のWebRTC状態はリセットされます。  ### &#x60;timeline_streaming&#x60;コマンド 全てのパブリックチャンネルの&#x60;MESSAGE_CREATED&#x60;イベントを受け取るかどうかを設定する。 初期状態は&#x60;off&#x60;です。  &#x60;timeline_streaming:(on|off|true|false)&#x60;  ## 受信 TextMessageとして各種イベントが&#x60;type&#x60;と&#x60;body&#x60;を持つJSONとして非同期に送られます。  例: &#x60;&#x60;&#x60;json {\&quot;type\&quot;:\&quot;USER_ONLINE\&quot;,\&quot;body\&quot;:{\&quot;id\&quot;:\&quot;7dd8e07f-7f5d-4331-9176-b56a4299768b\&quot;}} &#x60;&#x60;&#x60;  ## イベント一覧  ### &#x60;USER_JOINED&#x60; ユーザーが新規登録された。  対象: 全員  + &#x60;id&#x60;: 登録されたユーザーのId  ### &#x60;USER_UPDATED&#x60; ユーザーの情報が更新された。  対象: 全員  + &#x60;id&#x60;: 情報が更新されたユーザーのId  ### &#x60;USER_TAGS_UPDATED&#x60; ユーザーのタグが更新された。  対象: 全員  + &#x60;id&#x60;: タグが更新されたユーザーのId + &#x60;tag_id&#x60;: 更新されたタグのId  ### &#x60;USER_ICON_UPDATED&#x60; ユーザーのアイコンが更新された。  対象: 全員  + &#x60;id&#x60;: アイコンが更新されたユーザーのId  ### &#x60;USER_WEBRTC_STATE_CHANGED&#x60; ユーザーのWebRTCの状態が変化した  対象: 全員  + &#x60;user_id&#x60;: 変更があったユーザーのId + &#x60;channel_id&#x60;: ユーザーの変更後の接続チャンネルのId + &#x60;sessions&#x60;: ユーザーの変更後の状態(配列)   + &#x60;state&#x60;: 状態   + &#x60;sessionId&#x60;: セッションID  ### &#x60;USER_VIEWSTATE_CHANGED&#x60; ユーザーのチャンネルの閲覧状態が変化した  対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て  + &#x60;view_states&#x60;: 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)   + &#x60;key&#x60;: WSセッションの識別子   + &#x60;channel_id&#x60;: 閲覧しているチャンネルId   + &#x60;state&#x60;: 閲覧状態  ### &#x60;USER_ONLINE&#x60; ユーザーがオンラインになった。  対象: 全員  + &#x60;id&#x60;: オンラインになったユーザーのId  ### &#x60;USER_OFFLINE&#x60; ユーザーがオフラインになった。  対象: 全員  + &#x60;id&#x60;: オフラインになったユーザーのId  ### &#x60;USER_GROUP_CREATED&#x60; ユーザーグループが作成された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_UPDATED&#x60; ユーザーグループが更新された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_DELETED&#x60; ユーザーグループが削除された  対象: 全員  + &#x60;id&#x60;: 削除されたユーザーグループのId  ### &#x60;CHANNEL_CREATED&#x60; チャンネルが新規作成された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 作成されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_UPDATED&#x60; チャンネルの情報が変更された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 変更があったチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_DELETED&#x60; チャンネルが削除された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 削除されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_STARED&#x60; 自分がチャンネルをスターした。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_UNSTARED&#x60; 自分がチャンネルのスターを解除した。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_VIEWERS_CHANGED&#x60; チャンネルの閲覧者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId + &#x60;viewers&#x60;: 変化後の閲覧者(配列)   + &#x60;userId&#x60;: ユーザーId   + &#x60;state&#x60;: 閲覧状態   + &#x60;updatedAt&#x60;: 閲覧状態の更新日時  ### &#x60;CHANNEL_SUBSCRIBERS_CHANGED&#x60; チャンネルの購読者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId  ### &#x60;MESSAGE_CREATED&#x60; メッセージが投稿された。  対象: 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー  + &#x60;id&#x60;: 投稿されたメッセージのId + &#x60;is_citing&#x60;: 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか  ### &#x60;MESSAGE_UPDATED&#x60; メッセージが更新された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 更新されたメッセージのId  ### &#x60;MESSAGE_DELETED&#x60; メッセージが削除された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 削除されたメッセージのId  ### &#x60;MESSAGE_STAMPED&#x60; メッセージにスタンプが押された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId + &#x60;count&#x60;: そのユーザーが押した数 + &#x60;created_at&#x60;: そのユーザーがそのスタンプをそのメッセージに最初に押した日時  ### &#x60;MESSAGE_UNSTAMPED&#x60; メッセージからスタンプが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId  ### &#x60;MESSAGE_PINNED&#x60; メッセージがピン留めされた。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンされたメッセージのID + &#x60;channel_id&#x60;: ピンされたメッセージのチャンネルID  ### &#x60;MESSAGE_UNPINNED&#x60; ピン留めされたメッセージのピンが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンが外されたメッセージのID + &#x60;channel_id&#x60;: ピンが外されたメッセージのチャンネルID  ### &#x60;MESSAGE_READ&#x60; 自分があるチャンネルのメッセージを読んだ。  対象: 自分  + &#x60;id&#x60;: 読んだチャンネルId  ### &#x60;STAMP_CREATED&#x60; スタンプが新しく追加された。  対象: 全員  + &#x60;id&#x60;: 作成されたスタンプのId  ### &#x60;STAMP_UPDATED&#x60; スタンプが修正された。  対象: 全員  + &#x60;id&#x60;: 修正されたスタンプのId  ### &#x60;STAMP_DELETED&#x60; スタンプが削除された。  対象: 全員  + &#x60;id&#x60;: 削除されたスタンプのId  ### &#x60;STAMP_PALETTE_CREATED&#x60; スタンプパレットが新しく追加された。  対象: 自分  + &#x60;id&#x60;: 作成されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_UPDATED&#x60; スタンプパレットが修正された。  対象: 自分  + &#x60;id&#x60;: 修正されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_DELETED&#x60; スタンプパレットが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたスタンプパレットのId  ### &#x60;CLIP_FOLDER_CREATED&#x60; クリップフォルダーが作成された。  対象：自分  + &#x60;id&#x60;: 作成されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_UPDATED&#x60; クリップフォルダーが修正された。  対象: 自分  + &#x60;id&#x60;: 更新されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_DELETED&#x60; クリップフォルダーが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_MESSAGE_DELETED&#x60; クリップフォルダーからメッセージが除外された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが除外されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーから除外されたメッセージのId  ### &#x60;CLIP_FOLDER_MESSAGE_ADDED&#x60; クリップフォルダーにメッセージが追加された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが追加されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーに追加されたメッセージのId  ### &#x60;QALL_ROOM_STATE_CHANGED&#x60; ルーム状態が変更された。  対象: 全員  + &#x60;room_id&#x60;: 変更されたルームのId + &#x60;state&#x60;: 変更後のルーム状態   + &#x60;roomId&#x60;: ルームのID   + &#x60;participants&#x60;: ルーム内の参加者(配列)     + &#x60;identity&#x60;: ユーザーID_RandomUUID     + &#x60;name&#x60;: 表示名     + &#x60;joinedAt&#x60;: 参加した時刻     + &#x60;attributes&#x60;: ユーザーに関連付けられたカスタム属性     + &#x60;canPublish&#x60;: 発言権限   + &#x60;isWebinar&#x60;: ウェビナールームかどうか   + &#x60;metadata&#x60;: ルームに関連付けられたカスタム属性  ### &#x60;QALL_SOUNDBOARD_ITEM_CREATED&#x60; サウンドボードアイテムが作成された。  対象: 全員  + &#x60;sound_id&#x60;: 作成されたサウンドのId + &#x60;name&#x60;: サウンド名 + &#x60;creator_id&#x60;: 作成者のId  ### &#x60;QALL_SOUNDBOARD_ITEM_DELETED&#x60; サウンドボードアイテムが削除された。  対象: 全員  + &#x60;sound_id&#x60;: 削除されたサウンドのId
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWsApiResponse"/>?&gt;</returns>
        Task<IWsApiResponse?> WsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IEditChannelSubscribersApiResponse"/>
    /// </summary>
    public interface IEditChannelSubscribersApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetChannelSubscribersApiResponse"/>
    /// </summary>
    public interface IGetChannelSubscribersApiResponse : Traq.Client.IApiResponse, IOk<List<Guid>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetMyChannelSubscriptionsApiResponse"/>
    /// </summary>
    public interface IGetMyChannelSubscriptionsApiResponse : Traq.Client.IApiResponse, IOk<List<UserSubscribeState>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetMyUnreadChannelsApiResponse"/>
    /// </summary>
    public interface IGetMyUnreadChannelsApiResponse : Traq.Client.IApiResponse, IOk<List<UnreadChannel>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetMyViewStatesApiResponse"/>
    /// </summary>
    public interface IGetMyViewStatesApiResponse : Traq.Client.IApiResponse, IOk<List<MyChannelViewState>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IReadChannelApiResponse"/>
    /// </summary>
    public interface IReadChannelApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IRegisterFCMDeviceApiResponse"/>
    /// </summary>
    public interface IRegisterFCMDeviceApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="ISetChannelSubscribeLevelApiResponse"/>
    /// </summary>
    public interface ISetChannelSubscribeLevelApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ISetChannelSubscribersApiResponse"/>
    /// </summary>
    public interface ISetChannelSubscribersApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IWsApiResponse"/>
    /// </summary>
    public interface IWsApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 101 SwitchingProtocols
        /// </summary>
        /// <returns></returns>
        bool IsSwitchingProtocols { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class NotificationApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditChannelSubscribers;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditChannelSubscribers;

        internal void ExecuteOnEditChannelSubscribers(NotificationApi.EditChannelSubscribersApiResponse apiResponse)
        {
            OnEditChannelSubscribers?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditChannelSubscribers(Exception exception)
        {
            OnErrorEditChannelSubscribers?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetChannelSubscribers;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetChannelSubscribers;

        internal void ExecuteOnGetChannelSubscribers(NotificationApi.GetChannelSubscribersApiResponse apiResponse)
        {
            OnGetChannelSubscribers?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetChannelSubscribers(Exception exception)
        {
            OnErrorGetChannelSubscribers?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMyChannelSubscriptions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMyChannelSubscriptions;

        internal void ExecuteOnGetMyChannelSubscriptions(NotificationApi.GetMyChannelSubscriptionsApiResponse apiResponse)
        {
            OnGetMyChannelSubscriptions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMyChannelSubscriptions(Exception exception)
        {
            OnErrorGetMyChannelSubscriptions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMyUnreadChannels;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMyUnreadChannels;

        internal void ExecuteOnGetMyUnreadChannels(NotificationApi.GetMyUnreadChannelsApiResponse apiResponse)
        {
            OnGetMyUnreadChannels?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMyUnreadChannels(Exception exception)
        {
            OnErrorGetMyUnreadChannels?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMyViewStates;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMyViewStates;

        internal void ExecuteOnGetMyViewStates(NotificationApi.GetMyViewStatesApiResponse apiResponse)
        {
            OnGetMyViewStates?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMyViewStates(Exception exception)
        {
            OnErrorGetMyViewStates?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnReadChannel;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorReadChannel;

        internal void ExecuteOnReadChannel(NotificationApi.ReadChannelApiResponse apiResponse)
        {
            OnReadChannel?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorReadChannel(Exception exception)
        {
            OnErrorReadChannel?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRegisterFCMDevice;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRegisterFCMDevice;

        internal void ExecuteOnRegisterFCMDevice(NotificationApi.RegisterFCMDeviceApiResponse apiResponse)
        {
            OnRegisterFCMDevice?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRegisterFCMDevice(Exception exception)
        {
            OnErrorRegisterFCMDevice?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSetChannelSubscribeLevel;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSetChannelSubscribeLevel;

        internal void ExecuteOnSetChannelSubscribeLevel(NotificationApi.SetChannelSubscribeLevelApiResponse apiResponse)
        {
            OnSetChannelSubscribeLevel?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSetChannelSubscribeLevel(Exception exception)
        {
            OnErrorSetChannelSubscribeLevel?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSetChannelSubscribers;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSetChannelSubscribers;

        internal void ExecuteOnSetChannelSubscribers(NotificationApi.SetChannelSubscribersApiResponse apiResponse)
        {
            OnSetChannelSubscribers?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSetChannelSubscribers(Exception exception)
        {
            OnErrorSetChannelSubscribers?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnWs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorWs;

        internal void ExecuteOnWs(NotificationApi.WsApiResponse apiResponse)
        {
            OnWs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorWs(Exception exception)
        {
            OnErrorWs?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class NotificationApi : INotificationApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<NotificationApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public NotificationApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="NotificationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public NotificationApi(ILogger<NotificationApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, NotificationApiEvents notificationApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<NotificationApi>();
            HttpClient = httpClient;
            Events = notificationApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatEditChannelSubscribers(ref Guid channelId, Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="patchChannelSubscribersRequest"></param>
        /// <returns></returns>
        private void ValidateEditChannelSubscribers(Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest)
        {
            if (patchChannelSubscribersRequest.IsSet && patchChannelSubscribersRequest.Value == null)
                throw new ArgumentNullException(nameof(patchChannelSubscribersRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="patchChannelSubscribersRequest"></param>
        private void AfterEditChannelSubscribersDefaultImplementation(IEditChannelSubscribersApiResponse apiResponseLocalVar, Guid channelId, Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditChannelSubscribers(ref suppressDefaultLog, apiResponseLocalVar, channelId, patchChannelSubscribersRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="patchChannelSubscribersRequest"></param>
        partial void AfterEditChannelSubscribers(ref bool suppressDefaultLog, IEditChannelSubscribersApiResponse apiResponseLocalVar, Guid channelId, Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="patchChannelSubscribersRequest"></param>
        private void OnErrorEditChannelSubscribersDefaultImplementation(Exception exception, string pathFormat, string path, Guid channelId, Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditChannelSubscribers(ref suppressDefaultLog, exception, pathFormat, path, channelId, patchChannelSubscribersRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="patchChannelSubscribersRequest"></param>
        partial void OnErrorEditChannelSubscribers(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid channelId, Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest);

        /// <summary>
        /// チャンネルの通知購読者を編集 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの通知購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
        /// </summary>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="patchChannelSubscribersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditChannelSubscribersApiResponse"/>&gt;</returns>
        public async Task<IEditChannelSubscribersApiResponse?> EditChannelSubscribersOrDefaultAsync(Guid channelId, Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditChannelSubscribersAsync(channelId, patchChannelSubscribersRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// チャンネルの通知購読者を編集 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの通知購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="patchChannelSubscribersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditChannelSubscribersApiResponse"/>&gt;</returns>
        public async Task<IEditChannelSubscribersApiResponse> EditChannelSubscribersAsync(Guid channelId, Option<PatchChannelSubscribersRequest> patchChannelSubscribersRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditChannelSubscribers(patchChannelSubscribersRequest);

                FormatEditChannelSubscribers(ref channelId, patchChannelSubscribersRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/channels/{channelId}/subscribers";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BchannelId%7D", Uri.EscapeDataString(channelId.ToString()));

                    if (patchChannelSubscribersRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchChannelSubscribersRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchChannelSubscribersRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditChannelSubscribersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditChannelSubscribersApiResponse>();

                        EditChannelSubscribersApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channels/{channelId}/subscribers", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditChannelSubscribersDefaultImplementation(apiResponseLocalVar, channelId, patchChannelSubscribersRequest);

                        Events.ExecuteOnEditChannelSubscribers(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditChannelSubscribersDefaultImplementation(e, "/channels/{channelId}/subscribers", uriBuilderLocalVar.Path, channelId, patchChannelSubscribersRequest);
                Events.ExecuteOnErrorEditChannelSubscribers(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditChannelSubscribersApiResponse"/>
        /// </summary>
        public partial class EditChannelSubscribersApiResponse : Traq.Client.ApiResponse, IEditChannelSubscribersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditChannelSubscribersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditChannelSubscribersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditChannelSubscribersApiResponse(ILogger<EditChannelSubscribersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetChannelSubscribers(ref Guid channelId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        private void AfterGetChannelSubscribersDefaultImplementation(IGetChannelSubscribersApiResponse apiResponseLocalVar, Guid channelId)
        {
            bool suppressDefaultLog = false;
            AfterGetChannelSubscribers(ref suppressDefaultLog, apiResponseLocalVar, channelId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        partial void AfterGetChannelSubscribers(ref bool suppressDefaultLog, IGetChannelSubscribersApiResponse apiResponseLocalVar, Guid channelId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        private void OnErrorGetChannelSubscribersDefaultImplementation(Exception exception, string pathFormat, string path, Guid channelId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetChannelSubscribers(ref suppressDefaultLog, exception, pathFormat, path, channelId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        partial void OnErrorGetChannelSubscribers(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid channelId);

        /// <summary>
        /// チャンネルの通知購読者のリストを取得 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
        /// </summary>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelSubscribersApiResponse"/>&gt;</returns>
        public async Task<IGetChannelSubscribersApiResponse?> GetChannelSubscribersOrDefaultAsync(Guid channelId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetChannelSubscribersAsync(channelId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// チャンネルの通知購読者のリストを取得 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetChannelSubscribersApiResponse"/>&gt;</returns>
        public async Task<IGetChannelSubscribersApiResponse> GetChannelSubscribersAsync(Guid channelId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetChannelSubscribers(ref channelId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/channels/{channelId}/subscribers";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BchannelId%7D", Uri.EscapeDataString(channelId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetChannelSubscribersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetChannelSubscribersApiResponse>();

                        GetChannelSubscribersApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channels/{channelId}/subscribers", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetChannelSubscribersDefaultImplementation(apiResponseLocalVar, channelId);

                        Events.ExecuteOnGetChannelSubscribers(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetChannelSubscribersDefaultImplementation(e, "/channels/{channelId}/subscribers", uriBuilderLocalVar.Path, channelId);
                Events.ExecuteOnErrorGetChannelSubscribers(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetChannelSubscribersApiResponse"/>
        /// </summary>
        public partial class GetChannelSubscribersApiResponse : Traq.Client.ApiResponse, IGetChannelSubscribersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetChannelSubscribersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetChannelSubscribersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetChannelSubscribersApiResponse(ILogger<GetChannelSubscribersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Guid>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Guid>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Guid>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetMyChannelSubscriptionsDefaultImplementation(IGetMyChannelSubscriptionsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetMyChannelSubscriptions(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetMyChannelSubscriptions(ref bool suppressDefaultLog, IGetMyChannelSubscriptionsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        private void OnErrorGetMyChannelSubscriptionsDefaultImplementation(Exception exception, string pathFormat, string path)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMyChannelSubscriptions(ref suppressDefaultLog, exception, pathFormat, path);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        partial void OnErrorGetMyChannelSubscriptions(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path);

        /// <summary>
        /// 自分のチャンネル購読状態を取得 自身のチャンネル購読状態を取得します。
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyChannelSubscriptionsApiResponse"/>&gt;</returns>
        public async Task<IGetMyChannelSubscriptionsApiResponse?> GetMyChannelSubscriptionsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMyChannelSubscriptionsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 自分のチャンネル購読状態を取得 自身のチャンネル購読状態を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyChannelSubscriptionsApiResponse"/>&gt;</returns>
        public async Task<IGetMyChannelSubscriptionsApiResponse> GetMyChannelSubscriptionsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/subscriptions";

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMyChannelSubscriptionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMyChannelSubscriptionsApiResponse>();

                        GetMyChannelSubscriptionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/subscriptions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMyChannelSubscriptionsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetMyChannelSubscriptions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMyChannelSubscriptionsDefaultImplementation(e, "/users/me/subscriptions", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetMyChannelSubscriptions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMyChannelSubscriptionsApiResponse"/>
        /// </summary>
        public partial class GetMyChannelSubscriptionsApiResponse : Traq.Client.ApiResponse, IGetMyChannelSubscriptionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMyChannelSubscriptionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMyChannelSubscriptionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMyChannelSubscriptionsApiResponse(ILogger<GetMyChannelSubscriptionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<UserSubscribeState>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<UserSubscribeState>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<UserSubscribeState>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetMyUnreadChannelsDefaultImplementation(IGetMyUnreadChannelsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetMyUnreadChannels(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetMyUnreadChannels(ref bool suppressDefaultLog, IGetMyUnreadChannelsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        private void OnErrorGetMyUnreadChannelsDefaultImplementation(Exception exception, string pathFormat, string path)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMyUnreadChannels(ref suppressDefaultLog, exception, pathFormat, path);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        partial void OnErrorGetMyUnreadChannels(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path);

        /// <summary>
        /// 未読チャンネルを取得 自分が現在未読のチャンネルの未読情報を取得します。
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyUnreadChannelsApiResponse"/>&gt;</returns>
        public async Task<IGetMyUnreadChannelsApiResponse?> GetMyUnreadChannelsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMyUnreadChannelsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 未読チャンネルを取得 自分が現在未読のチャンネルの未読情報を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyUnreadChannelsApiResponse"/>&gt;</returns>
        public async Task<IGetMyUnreadChannelsApiResponse> GetMyUnreadChannelsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/unread";

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMyUnreadChannelsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMyUnreadChannelsApiResponse>();

                        GetMyUnreadChannelsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/unread", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMyUnreadChannelsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetMyUnreadChannels(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMyUnreadChannelsDefaultImplementation(e, "/users/me/unread", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetMyUnreadChannels(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMyUnreadChannelsApiResponse"/>
        /// </summary>
        public partial class GetMyUnreadChannelsApiResponse : Traq.Client.ApiResponse, IGetMyUnreadChannelsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMyUnreadChannelsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMyUnreadChannelsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMyUnreadChannelsApiResponse(ILogger<GetMyUnreadChannelsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<UnreadChannel>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<UnreadChannel>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<UnreadChannel>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetMyViewStatesDefaultImplementation(IGetMyViewStatesApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetMyViewStates(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetMyViewStates(ref bool suppressDefaultLog, IGetMyViewStatesApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        private void OnErrorGetMyViewStatesDefaultImplementation(Exception exception, string pathFormat, string path)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMyViewStates(ref suppressDefaultLog, exception, pathFormat, path);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        partial void OnErrorGetMyViewStates(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path);

        /// <summary>
        /// 自身のチャンネル閲覧状態一覧を取得 自身のチャンネル閲覧状態一覧を取得します。
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyViewStatesApiResponse"/>&gt;</returns>
        public async Task<IGetMyViewStatesApiResponse?> GetMyViewStatesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMyViewStatesAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 自身のチャンネル閲覧状態一覧を取得 自身のチャンネル閲覧状態一覧を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyViewStatesApiResponse"/>&gt;</returns>
        public async Task<IGetMyViewStatesApiResponse> GetMyViewStatesAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/view-states";

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMyViewStatesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMyViewStatesApiResponse>();

                        GetMyViewStatesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/view-states", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMyViewStatesDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetMyViewStates(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMyViewStatesDefaultImplementation(e, "/users/me/view-states", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetMyViewStates(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMyViewStatesApiResponse"/>
        /// </summary>
        public partial class GetMyViewStatesApiResponse : Traq.Client.ApiResponse, IGetMyViewStatesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMyViewStatesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMyViewStatesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMyViewStatesApiResponse(ILogger<GetMyViewStatesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MyChannelViewState>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MyChannelViewState>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MyChannelViewState>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatReadChannel(ref Guid channelId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        private void AfterReadChannelDefaultImplementation(IReadChannelApiResponse apiResponseLocalVar, Guid channelId)
        {
            bool suppressDefaultLog = false;
            AfterReadChannel(ref suppressDefaultLog, apiResponseLocalVar, channelId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        partial void AfterReadChannel(ref bool suppressDefaultLog, IReadChannelApiResponse apiResponseLocalVar, Guid channelId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        private void OnErrorReadChannelDefaultImplementation(Exception exception, string pathFormat, string path, Guid channelId)
        {
            bool suppressDefaultLog = false;
            OnErrorReadChannel(ref suppressDefaultLog, exception, pathFormat, path, channelId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        partial void OnErrorReadChannel(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid channelId);

        /// <summary>
        /// チャンネルを既読にする 自分が未読のチャンネルを既読にします。
        /// </summary>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReadChannelApiResponse"/>&gt;</returns>
        public async Task<IReadChannelApiResponse?> ReadChannelOrDefaultAsync(Guid channelId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ReadChannelAsync(channelId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// チャンネルを既読にする 自分が未読のチャンネルを既読にします。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReadChannelApiResponse"/>&gt;</returns>
        public async Task<IReadChannelApiResponse> ReadChannelAsync(Guid channelId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatReadChannel(ref channelId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/unread/{channelId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BchannelId%7D", Uri.EscapeDataString(channelId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ReadChannelApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ReadChannelApiResponse>();

                        ReadChannelApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/unread/{channelId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterReadChannelDefaultImplementation(apiResponseLocalVar, channelId);

                        Events.ExecuteOnReadChannel(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorReadChannelDefaultImplementation(e, "/users/me/unread/{channelId}", uriBuilderLocalVar.Path, channelId);
                Events.ExecuteOnErrorReadChannel(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ReadChannelApiResponse"/>
        /// </summary>
        public partial class ReadChannelApiResponse : Traq.Client.ApiResponse, IReadChannelApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ReadChannelApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ReadChannelApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ReadChannelApiResponse(ILogger<ReadChannelApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRegisterFCMDevice(Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postMyFCMDeviceRequest"></param>
        /// <returns></returns>
        private void ValidateRegisterFCMDevice(Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest)
        {
            if (postMyFCMDeviceRequest.IsSet && postMyFCMDeviceRequest.Value == null)
                throw new ArgumentNullException(nameof(postMyFCMDeviceRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postMyFCMDeviceRequest"></param>
        private void AfterRegisterFCMDeviceDefaultImplementation(IRegisterFCMDeviceApiResponse apiResponseLocalVar, Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest)
        {
            bool suppressDefaultLog = false;
            AfterRegisterFCMDevice(ref suppressDefaultLog, apiResponseLocalVar, postMyFCMDeviceRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postMyFCMDeviceRequest"></param>
        partial void AfterRegisterFCMDevice(ref bool suppressDefaultLog, IRegisterFCMDeviceApiResponse apiResponseLocalVar, Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postMyFCMDeviceRequest"></param>
        private void OnErrorRegisterFCMDeviceDefaultImplementation(Exception exception, string pathFormat, string path, Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorRegisterFCMDevice(ref suppressDefaultLog, exception, pathFormat, path, postMyFCMDeviceRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postMyFCMDeviceRequest"></param>
        partial void OnErrorRegisterFCMDevice(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest);

        /// <summary>
        /// FCMデバイスを登録 自身のFCMデバイスを登録します。
        /// </summary>
        /// <param name="postMyFCMDeviceRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRegisterFCMDeviceApiResponse"/>&gt;</returns>
        public async Task<IRegisterFCMDeviceApiResponse?> RegisterFCMDeviceOrDefaultAsync(Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RegisterFCMDeviceAsync(postMyFCMDeviceRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// FCMデバイスを登録 自身のFCMデバイスを登録します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postMyFCMDeviceRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRegisterFCMDeviceApiResponse"/>&gt;</returns>
        public async Task<IRegisterFCMDeviceApiResponse> RegisterFCMDeviceAsync(Option<PostMyFCMDeviceRequest> postMyFCMDeviceRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRegisterFCMDevice(postMyFCMDeviceRequest);

                FormatRegisterFCMDevice(postMyFCMDeviceRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/fcm-device";

                    if (postMyFCMDeviceRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postMyFCMDeviceRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postMyFCMDeviceRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RegisterFCMDeviceApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RegisterFCMDeviceApiResponse>();

                        RegisterFCMDeviceApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/fcm-device", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRegisterFCMDeviceDefaultImplementation(apiResponseLocalVar, postMyFCMDeviceRequest);

                        Events.ExecuteOnRegisterFCMDevice(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRegisterFCMDeviceDefaultImplementation(e, "/users/me/fcm-device", uriBuilderLocalVar.Path, postMyFCMDeviceRequest);
                Events.ExecuteOnErrorRegisterFCMDevice(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RegisterFCMDeviceApiResponse"/>
        /// </summary>
        public partial class RegisterFCMDeviceApiResponse : Traq.Client.ApiResponse, IRegisterFCMDeviceApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RegisterFCMDeviceApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RegisterFCMDeviceApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RegisterFCMDeviceApiResponse(ILogger<RegisterFCMDeviceApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSetChannelSubscribeLevel(ref Guid channelId, Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="putChannelSubscribeLevelRequest"></param>
        /// <returns></returns>
        private void ValidateSetChannelSubscribeLevel(Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest)
        {
            if (putChannelSubscribeLevelRequest.IsSet && putChannelSubscribeLevelRequest.Value == null)
                throw new ArgumentNullException(nameof(putChannelSubscribeLevelRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="putChannelSubscribeLevelRequest"></param>
        private void AfterSetChannelSubscribeLevelDefaultImplementation(ISetChannelSubscribeLevelApiResponse apiResponseLocalVar, Guid channelId, Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest)
        {
            bool suppressDefaultLog = false;
            AfterSetChannelSubscribeLevel(ref suppressDefaultLog, apiResponseLocalVar, channelId, putChannelSubscribeLevelRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="putChannelSubscribeLevelRequest"></param>
        partial void AfterSetChannelSubscribeLevel(ref bool suppressDefaultLog, ISetChannelSubscribeLevelApiResponse apiResponseLocalVar, Guid channelId, Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="putChannelSubscribeLevelRequest"></param>
        private void OnErrorSetChannelSubscribeLevelDefaultImplementation(Exception exception, string pathFormat, string path, Guid channelId, Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorSetChannelSubscribeLevel(ref suppressDefaultLog, exception, pathFormat, path, channelId, putChannelSubscribeLevelRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="putChannelSubscribeLevelRequest"></param>
        partial void OnErrorSetChannelSubscribeLevel(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid channelId, Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest);

        /// <summary>
        /// チャンネル購読レベルを設定 自身の指定したチャンネルの購読レベルを設定します。
        /// </summary>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="putChannelSubscribeLevelRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetChannelSubscribeLevelApiResponse"/>&gt;</returns>
        public async Task<ISetChannelSubscribeLevelApiResponse?> SetChannelSubscribeLevelOrDefaultAsync(Guid channelId, Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SetChannelSubscribeLevelAsync(channelId, putChannelSubscribeLevelRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// チャンネル購読レベルを設定 自身の指定したチャンネルの購読レベルを設定します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="putChannelSubscribeLevelRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetChannelSubscribeLevelApiResponse"/>&gt;</returns>
        public async Task<ISetChannelSubscribeLevelApiResponse> SetChannelSubscribeLevelAsync(Guid channelId, Option<PutChannelSubscribeLevelRequest> putChannelSubscribeLevelRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSetChannelSubscribeLevel(putChannelSubscribeLevelRequest);

                FormatSetChannelSubscribeLevel(ref channelId, putChannelSubscribeLevelRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/subscriptions/{channelId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BchannelId%7D", Uri.EscapeDataString(channelId.ToString()));

                    if (putChannelSubscribeLevelRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (putChannelSubscribeLevelRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(putChannelSubscribeLevelRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SetChannelSubscribeLevelApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SetChannelSubscribeLevelApiResponse>();

                        SetChannelSubscribeLevelApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/subscriptions/{channelId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSetChannelSubscribeLevelDefaultImplementation(apiResponseLocalVar, channelId, putChannelSubscribeLevelRequest);

                        Events.ExecuteOnSetChannelSubscribeLevel(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSetChannelSubscribeLevelDefaultImplementation(e, "/users/me/subscriptions/{channelId}", uriBuilderLocalVar.Path, channelId, putChannelSubscribeLevelRequest);
                Events.ExecuteOnErrorSetChannelSubscribeLevel(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SetChannelSubscribeLevelApiResponse"/>
        /// </summary>
        public partial class SetChannelSubscribeLevelApiResponse : Traq.Client.ApiResponse, ISetChannelSubscribeLevelApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SetChannelSubscribeLevelApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SetChannelSubscribeLevelApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SetChannelSubscribeLevelApiResponse(ILogger<SetChannelSubscribeLevelApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSetChannelSubscribers(ref Guid channelId, Option<PutChannelSubscribersRequest> putChannelSubscribersRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="putChannelSubscribersRequest"></param>
        /// <returns></returns>
        private void ValidateSetChannelSubscribers(Option<PutChannelSubscribersRequest> putChannelSubscribersRequest)
        {
            if (putChannelSubscribersRequest.IsSet && putChannelSubscribersRequest.Value == null)
                throw new ArgumentNullException(nameof(putChannelSubscribersRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="putChannelSubscribersRequest"></param>
        private void AfterSetChannelSubscribersDefaultImplementation(ISetChannelSubscribersApiResponse apiResponseLocalVar, Guid channelId, Option<PutChannelSubscribersRequest> putChannelSubscribersRequest)
        {
            bool suppressDefaultLog = false;
            AfterSetChannelSubscribers(ref suppressDefaultLog, apiResponseLocalVar, channelId, putChannelSubscribersRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="putChannelSubscribersRequest"></param>
        partial void AfterSetChannelSubscribers(ref bool suppressDefaultLog, ISetChannelSubscribersApiResponse apiResponseLocalVar, Guid channelId, Option<PutChannelSubscribersRequest> putChannelSubscribersRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="putChannelSubscribersRequest"></param>
        private void OnErrorSetChannelSubscribersDefaultImplementation(Exception exception, string pathFormat, string path, Guid channelId, Option<PutChannelSubscribersRequest> putChannelSubscribersRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorSetChannelSubscribers(ref suppressDefaultLog, exception, pathFormat, path, channelId, putChannelSubscribersRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="putChannelSubscribersRequest"></param>
        partial void OnErrorSetChannelSubscribers(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid channelId, Option<PutChannelSubscribersRequest> putChannelSubscribersRequest);

        /// <summary>
        /// チャンネルの通知購読者を設定 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの通知購読状態はオフになります。 また、存在しないユーザーを指定した場合は無視されます。
        /// </summary>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="putChannelSubscribersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetChannelSubscribersApiResponse"/>&gt;</returns>
        public async Task<ISetChannelSubscribersApiResponse?> SetChannelSubscribersOrDefaultAsync(Guid channelId, Option<PutChannelSubscribersRequest> putChannelSubscribersRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SetChannelSubscribersAsync(channelId, putChannelSubscribersRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// チャンネルの通知購読者を設定 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの通知購読状態はオフになります。 また、存在しないユーザーを指定した場合は無視されます。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="putChannelSubscribersRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISetChannelSubscribersApiResponse"/>&gt;</returns>
        public async Task<ISetChannelSubscribersApiResponse> SetChannelSubscribersAsync(Guid channelId, Option<PutChannelSubscribersRequest> putChannelSubscribersRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSetChannelSubscribers(putChannelSubscribersRequest);

                FormatSetChannelSubscribers(ref channelId, putChannelSubscribersRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/channels/{channelId}/subscribers";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BchannelId%7D", Uri.EscapeDataString(channelId.ToString()));

                    if (putChannelSubscribersRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (putChannelSubscribersRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(putChannelSubscribersRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SetChannelSubscribersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SetChannelSubscribersApiResponse>();

                        SetChannelSubscribersApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channels/{channelId}/subscribers", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSetChannelSubscribersDefaultImplementation(apiResponseLocalVar, channelId, putChannelSubscribersRequest);

                        Events.ExecuteOnSetChannelSubscribers(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSetChannelSubscribersDefaultImplementation(e, "/channels/{channelId}/subscribers", uriBuilderLocalVar.Path, channelId, putChannelSubscribersRequest);
                Events.ExecuteOnErrorSetChannelSubscribers(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SetChannelSubscribersApiResponse"/>
        /// </summary>
        public partial class SetChannelSubscribersApiResponse : Traq.Client.ApiResponse, ISetChannelSubscribersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SetChannelSubscribersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SetChannelSubscribersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SetChannelSubscribersApiResponse(ILogger<SetChannelSubscribersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterWsDefaultImplementation(IWsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterWs(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterWs(ref bool suppressDefaultLog, IWsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        private void OnErrorWsDefaultImplementation(Exception exception, string pathFormat, string path)
        {
            bool suppressDefaultLog = false;
            OnErrorWs(ref suppressDefaultLog, exception, pathFormat, path);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        partial void OnErrorWs(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path);

        /// <summary>
        /// WebSocket通知ストリームに接続します # WebSocketプロトコル ## 送信 &#x60;コマンド:引数1:引数2:...&#x60;のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### &#x60;viewstate&#x60;コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  &#x60;viewstate:{チャンネルID}:{閲覧状態}&#x60; + チャンネルID: 対象のチャンネルID + 閲覧状態: &#x60;none&#x60;, &#x60;monitoring&#x60;, &#x60;editing&#x60;  最初の&#x60;viewstate&#x60;コマンドを送る前、または&#x60;viewstate:null&#x60;, &#x60;viewstate:&#x60;を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ### &#x60;rtcstate&#x60;コマンド 自分のWebRTC状態を変更する。 他のコネクションが既に状態を保持している場合、変更することができません。  &#x60;rtcstate:{チャンネルID}:({状態}:{セッションID})*&#x60;  コネクションが切断された場合、自分のWebRTC状態はリセットされます。  ### &#x60;timeline_streaming&#x60;コマンド 全てのパブリックチャンネルの&#x60;MESSAGE_CREATED&#x60;イベントを受け取るかどうかを設定する。 初期状態は&#x60;off&#x60;です。  &#x60;timeline_streaming:(on|off|true|false)&#x60;  ## 受信 TextMessageとして各種イベントが&#x60;type&#x60;と&#x60;body&#x60;を持つJSONとして非同期に送られます。  例: &#x60;&#x60;&#x60;json {\&quot;type\&quot;:\&quot;USER_ONLINE\&quot;,\&quot;body\&quot;:{\&quot;id\&quot;:\&quot;7dd8e07f-7f5d-4331-9176-b56a4299768b\&quot;}} &#x60;&#x60;&#x60;  ## イベント一覧  ### &#x60;USER_JOINED&#x60; ユーザーが新規登録された。  対象: 全員  + &#x60;id&#x60;: 登録されたユーザーのId  ### &#x60;USER_UPDATED&#x60; ユーザーの情報が更新された。  対象: 全員  + &#x60;id&#x60;: 情報が更新されたユーザーのId  ### &#x60;USER_TAGS_UPDATED&#x60; ユーザーのタグが更新された。  対象: 全員  + &#x60;id&#x60;: タグが更新されたユーザーのId + &#x60;tag_id&#x60;: 更新されたタグのId  ### &#x60;USER_ICON_UPDATED&#x60; ユーザーのアイコンが更新された。  対象: 全員  + &#x60;id&#x60;: アイコンが更新されたユーザーのId  ### &#x60;USER_WEBRTC_STATE_CHANGED&#x60; ユーザーのWebRTCの状態が変化した  対象: 全員  + &#x60;user_id&#x60;: 変更があったユーザーのId + &#x60;channel_id&#x60;: ユーザーの変更後の接続チャンネルのId + &#x60;sessions&#x60;: ユーザーの変更後の状態(配列)   + &#x60;state&#x60;: 状態   + &#x60;sessionId&#x60;: セッションID  ### &#x60;USER_VIEWSTATE_CHANGED&#x60; ユーザーのチャンネルの閲覧状態が変化した  対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て  + &#x60;view_states&#x60;: 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)   + &#x60;key&#x60;: WSセッションの識別子   + &#x60;channel_id&#x60;: 閲覧しているチャンネルId   + &#x60;state&#x60;: 閲覧状態  ### &#x60;USER_ONLINE&#x60; ユーザーがオンラインになった。  対象: 全員  + &#x60;id&#x60;: オンラインになったユーザーのId  ### &#x60;USER_OFFLINE&#x60; ユーザーがオフラインになった。  対象: 全員  + &#x60;id&#x60;: オフラインになったユーザーのId  ### &#x60;USER_GROUP_CREATED&#x60; ユーザーグループが作成された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_UPDATED&#x60; ユーザーグループが更新された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_DELETED&#x60; ユーザーグループが削除された  対象: 全員  + &#x60;id&#x60;: 削除されたユーザーグループのId  ### &#x60;CHANNEL_CREATED&#x60; チャンネルが新規作成された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 作成されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_UPDATED&#x60; チャンネルの情報が変更された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 変更があったチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_DELETED&#x60; チャンネルが削除された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 削除されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_STARED&#x60; 自分がチャンネルをスターした。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_UNSTARED&#x60; 自分がチャンネルのスターを解除した。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_VIEWERS_CHANGED&#x60; チャンネルの閲覧者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId + &#x60;viewers&#x60;: 変化後の閲覧者(配列)   + &#x60;userId&#x60;: ユーザーId   + &#x60;state&#x60;: 閲覧状態   + &#x60;updatedAt&#x60;: 閲覧状態の更新日時  ### &#x60;CHANNEL_SUBSCRIBERS_CHANGED&#x60; チャンネルの購読者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId  ### &#x60;MESSAGE_CREATED&#x60; メッセージが投稿された。  対象: 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー  + &#x60;id&#x60;: 投稿されたメッセージのId + &#x60;is_citing&#x60;: 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか  ### &#x60;MESSAGE_UPDATED&#x60; メッセージが更新された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 更新されたメッセージのId  ### &#x60;MESSAGE_DELETED&#x60; メッセージが削除された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 削除されたメッセージのId  ### &#x60;MESSAGE_STAMPED&#x60; メッセージにスタンプが押された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId + &#x60;count&#x60;: そのユーザーが押した数 + &#x60;created_at&#x60;: そのユーザーがそのスタンプをそのメッセージに最初に押した日時  ### &#x60;MESSAGE_UNSTAMPED&#x60; メッセージからスタンプが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId  ### &#x60;MESSAGE_PINNED&#x60; メッセージがピン留めされた。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンされたメッセージのID + &#x60;channel_id&#x60;: ピンされたメッセージのチャンネルID  ### &#x60;MESSAGE_UNPINNED&#x60; ピン留めされたメッセージのピンが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンが外されたメッセージのID + &#x60;channel_id&#x60;: ピンが外されたメッセージのチャンネルID  ### &#x60;MESSAGE_READ&#x60; 自分があるチャンネルのメッセージを読んだ。  対象: 自分  + &#x60;id&#x60;: 読んだチャンネルId  ### &#x60;STAMP_CREATED&#x60; スタンプが新しく追加された。  対象: 全員  + &#x60;id&#x60;: 作成されたスタンプのId  ### &#x60;STAMP_UPDATED&#x60; スタンプが修正された。  対象: 全員  + &#x60;id&#x60;: 修正されたスタンプのId  ### &#x60;STAMP_DELETED&#x60; スタンプが削除された。  対象: 全員  + &#x60;id&#x60;: 削除されたスタンプのId  ### &#x60;STAMP_PALETTE_CREATED&#x60; スタンプパレットが新しく追加された。  対象: 自分  + &#x60;id&#x60;: 作成されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_UPDATED&#x60; スタンプパレットが修正された。  対象: 自分  + &#x60;id&#x60;: 修正されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_DELETED&#x60; スタンプパレットが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたスタンプパレットのId  ### &#x60;CLIP_FOLDER_CREATED&#x60; クリップフォルダーが作成された。  対象：自分  + &#x60;id&#x60;: 作成されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_UPDATED&#x60; クリップフォルダーが修正された。  対象: 自分  + &#x60;id&#x60;: 更新されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_DELETED&#x60; クリップフォルダーが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_MESSAGE_DELETED&#x60; クリップフォルダーからメッセージが除外された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが除外されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーから除外されたメッセージのId  ### &#x60;CLIP_FOLDER_MESSAGE_ADDED&#x60; クリップフォルダーにメッセージが追加された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが追加されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーに追加されたメッセージのId  ### &#x60;QALL_ROOM_STATE_CHANGED&#x60; ルーム状態が変更された。  対象: 全員  + &#x60;room_id&#x60;: 変更されたルームのId + &#x60;state&#x60;: 変更後のルーム状態   + &#x60;roomId&#x60;: ルームのID   + &#x60;participants&#x60;: ルーム内の参加者(配列)     + &#x60;identity&#x60;: ユーザーID_RandomUUID     + &#x60;name&#x60;: 表示名     + &#x60;joinedAt&#x60;: 参加した時刻     + &#x60;attributes&#x60;: ユーザーに関連付けられたカスタム属性     + &#x60;canPublish&#x60;: 発言権限   + &#x60;isWebinar&#x60;: ウェビナールームかどうか   + &#x60;metadata&#x60;: ルームに関連付けられたカスタム属性  ### &#x60;QALL_SOUNDBOARD_ITEM_CREATED&#x60; サウンドボードアイテムが作成された。  対象: 全員  + &#x60;sound_id&#x60;: 作成されたサウンドのId + &#x60;name&#x60;: サウンド名 + &#x60;creator_id&#x60;: 作成者のId  ### &#x60;QALL_SOUNDBOARD_ITEM_DELETED&#x60; サウンドボードアイテムが削除された。  対象: 全員  + &#x60;sound_id&#x60;: 削除されたサウンドのId
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWsApiResponse"/>&gt;</returns>
        public async Task<IWsApiResponse?> WsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await WsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// WebSocket通知ストリームに接続します # WebSocketプロトコル ## 送信 &#x60;コマンド:引数1:引数2:...&#x60;のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### &#x60;viewstate&#x60;コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  &#x60;viewstate:{チャンネルID}:{閲覧状態}&#x60; + チャンネルID: 対象のチャンネルID + 閲覧状態: &#x60;none&#x60;, &#x60;monitoring&#x60;, &#x60;editing&#x60;  最初の&#x60;viewstate&#x60;コマンドを送る前、または&#x60;viewstate:null&#x60;, &#x60;viewstate:&#x60;を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ### &#x60;rtcstate&#x60;コマンド 自分のWebRTC状態を変更する。 他のコネクションが既に状態を保持している場合、変更することができません。  &#x60;rtcstate:{チャンネルID}:({状態}:{セッションID})*&#x60;  コネクションが切断された場合、自分のWebRTC状態はリセットされます。  ### &#x60;timeline_streaming&#x60;コマンド 全てのパブリックチャンネルの&#x60;MESSAGE_CREATED&#x60;イベントを受け取るかどうかを設定する。 初期状態は&#x60;off&#x60;です。  &#x60;timeline_streaming:(on|off|true|false)&#x60;  ## 受信 TextMessageとして各種イベントが&#x60;type&#x60;と&#x60;body&#x60;を持つJSONとして非同期に送られます。  例: &#x60;&#x60;&#x60;json {\&quot;type\&quot;:\&quot;USER_ONLINE\&quot;,\&quot;body\&quot;:{\&quot;id\&quot;:\&quot;7dd8e07f-7f5d-4331-9176-b56a4299768b\&quot;}} &#x60;&#x60;&#x60;  ## イベント一覧  ### &#x60;USER_JOINED&#x60; ユーザーが新規登録された。  対象: 全員  + &#x60;id&#x60;: 登録されたユーザーのId  ### &#x60;USER_UPDATED&#x60; ユーザーの情報が更新された。  対象: 全員  + &#x60;id&#x60;: 情報が更新されたユーザーのId  ### &#x60;USER_TAGS_UPDATED&#x60; ユーザーのタグが更新された。  対象: 全員  + &#x60;id&#x60;: タグが更新されたユーザーのId + &#x60;tag_id&#x60;: 更新されたタグのId  ### &#x60;USER_ICON_UPDATED&#x60; ユーザーのアイコンが更新された。  対象: 全員  + &#x60;id&#x60;: アイコンが更新されたユーザーのId  ### &#x60;USER_WEBRTC_STATE_CHANGED&#x60; ユーザーのWebRTCの状態が変化した  対象: 全員  + &#x60;user_id&#x60;: 変更があったユーザーのId + &#x60;channel_id&#x60;: ユーザーの変更後の接続チャンネルのId + &#x60;sessions&#x60;: ユーザーの変更後の状態(配列)   + &#x60;state&#x60;: 状態   + &#x60;sessionId&#x60;: セッションID  ### &#x60;USER_VIEWSTATE_CHANGED&#x60; ユーザーのチャンネルの閲覧状態が変化した  対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て  + &#x60;view_states&#x60;: 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)   + &#x60;key&#x60;: WSセッションの識別子   + &#x60;channel_id&#x60;: 閲覧しているチャンネルId   + &#x60;state&#x60;: 閲覧状態  ### &#x60;USER_ONLINE&#x60; ユーザーがオンラインになった。  対象: 全員  + &#x60;id&#x60;: オンラインになったユーザーのId  ### &#x60;USER_OFFLINE&#x60; ユーザーがオフラインになった。  対象: 全員  + &#x60;id&#x60;: オフラインになったユーザーのId  ### &#x60;USER_GROUP_CREATED&#x60; ユーザーグループが作成された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_UPDATED&#x60; ユーザーグループが更新された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_DELETED&#x60; ユーザーグループが削除された  対象: 全員  + &#x60;id&#x60;: 削除されたユーザーグループのId  ### &#x60;CHANNEL_CREATED&#x60; チャンネルが新規作成された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 作成されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_UPDATED&#x60; チャンネルの情報が変更された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 変更があったチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_DELETED&#x60; チャンネルが削除された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 削除されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_STARED&#x60; 自分がチャンネルをスターした。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_UNSTARED&#x60; 自分がチャンネルのスターを解除した。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_VIEWERS_CHANGED&#x60; チャンネルの閲覧者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId + &#x60;viewers&#x60;: 変化後の閲覧者(配列)   + &#x60;userId&#x60;: ユーザーId   + &#x60;state&#x60;: 閲覧状態   + &#x60;updatedAt&#x60;: 閲覧状態の更新日時  ### &#x60;CHANNEL_SUBSCRIBERS_CHANGED&#x60; チャンネルの購読者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId  ### &#x60;MESSAGE_CREATED&#x60; メッセージが投稿された。  対象: 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー  + &#x60;id&#x60;: 投稿されたメッセージのId + &#x60;is_citing&#x60;: 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか  ### &#x60;MESSAGE_UPDATED&#x60; メッセージが更新された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 更新されたメッセージのId  ### &#x60;MESSAGE_DELETED&#x60; メッセージが削除された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 削除されたメッセージのId  ### &#x60;MESSAGE_STAMPED&#x60; メッセージにスタンプが押された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId + &#x60;count&#x60;: そのユーザーが押した数 + &#x60;created_at&#x60;: そのユーザーがそのスタンプをそのメッセージに最初に押した日時  ### &#x60;MESSAGE_UNSTAMPED&#x60; メッセージからスタンプが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId  ### &#x60;MESSAGE_PINNED&#x60; メッセージがピン留めされた。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンされたメッセージのID + &#x60;channel_id&#x60;: ピンされたメッセージのチャンネルID  ### &#x60;MESSAGE_UNPINNED&#x60; ピン留めされたメッセージのピンが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンが外されたメッセージのID + &#x60;channel_id&#x60;: ピンが外されたメッセージのチャンネルID  ### &#x60;MESSAGE_READ&#x60; 自分があるチャンネルのメッセージを読んだ。  対象: 自分  + &#x60;id&#x60;: 読んだチャンネルId  ### &#x60;STAMP_CREATED&#x60; スタンプが新しく追加された。  対象: 全員  + &#x60;id&#x60;: 作成されたスタンプのId  ### &#x60;STAMP_UPDATED&#x60; スタンプが修正された。  対象: 全員  + &#x60;id&#x60;: 修正されたスタンプのId  ### &#x60;STAMP_DELETED&#x60; スタンプが削除された。  対象: 全員  + &#x60;id&#x60;: 削除されたスタンプのId  ### &#x60;STAMP_PALETTE_CREATED&#x60; スタンプパレットが新しく追加された。  対象: 自分  + &#x60;id&#x60;: 作成されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_UPDATED&#x60; スタンプパレットが修正された。  対象: 自分  + &#x60;id&#x60;: 修正されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_DELETED&#x60; スタンプパレットが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたスタンプパレットのId  ### &#x60;CLIP_FOLDER_CREATED&#x60; クリップフォルダーが作成された。  対象：自分  + &#x60;id&#x60;: 作成されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_UPDATED&#x60; クリップフォルダーが修正された。  対象: 自分  + &#x60;id&#x60;: 更新されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_DELETED&#x60; クリップフォルダーが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_MESSAGE_DELETED&#x60; クリップフォルダーからメッセージが除外された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが除外されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーから除外されたメッセージのId  ### &#x60;CLIP_FOLDER_MESSAGE_ADDED&#x60; クリップフォルダーにメッセージが追加された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが追加されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーに追加されたメッセージのId  ### &#x60;QALL_ROOM_STATE_CHANGED&#x60; ルーム状態が変更された。  対象: 全員  + &#x60;room_id&#x60;: 変更されたルームのId + &#x60;state&#x60;: 変更後のルーム状態   + &#x60;roomId&#x60;: ルームのID   + &#x60;participants&#x60;: ルーム内の参加者(配列)     + &#x60;identity&#x60;: ユーザーID_RandomUUID     + &#x60;name&#x60;: 表示名     + &#x60;joinedAt&#x60;: 参加した時刻     + &#x60;attributes&#x60;: ユーザーに関連付けられたカスタム属性     + &#x60;canPublish&#x60;: 発言権限   + &#x60;isWebinar&#x60;: ウェビナールームかどうか   + &#x60;metadata&#x60;: ルームに関連付けられたカスタム属性  ### &#x60;QALL_SOUNDBOARD_ITEM_CREATED&#x60; サウンドボードアイテムが作成された。  対象: 全員  + &#x60;sound_id&#x60;: 作成されたサウンドのId + &#x60;name&#x60;: サウンド名 + &#x60;creator_id&#x60;: 作成者のId  ### &#x60;QALL_SOUNDBOARD_ITEM_DELETED&#x60; サウンドボードアイテムが削除された。  対象: 全員  + &#x60;sound_id&#x60;: 削除されたサウンドのId
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IWsApiResponse"/>&gt;</returns>
        public async Task<IWsApiResponse> WsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/ws";

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<WsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<WsApiResponse>();

                        WsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/ws", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterWsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnWs(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorWsDefaultImplementation(e, "/ws", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorWs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="WsApiResponse"/>
        /// </summary>
        public partial class WsApiResponse : Traq.Client.ApiResponse, IWsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<WsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="WsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public WsApiResponse(ILogger<WsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 101 SwitchingProtocols
            /// </summary>
            /// <returns></returns>
            public bool IsSwitchingProtocols => 101 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
