// <auto-generated>
/*
 * traQ v3
 *
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Traq.Client;
using Traq.Model;
using System.Diagnostics.CodeAnalysis;

namespace Traq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IUserApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        UserApiEvents Events { get; }

        /// <summary>
        /// ユーザーにタグを追加
        /// </summary>
        /// <remarks>
        /// 指定したユーザーに指定したタグを追加します。 Webhookユーザーにタグを追加することは出来ません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUserTagApiResponse"/>&gt;</returns>
        Task<IAddUserTagApiResponse> AddUserTagAsync(Guid userId, Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーにタグを追加
        /// </summary>
        /// <remarks>
        /// 指定したユーザーに指定したタグを追加します。 Webhookユーザーにタグを追加することは出来ません。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUserTagApiResponse"/>?&gt;</returns>
        Task<IAddUserTagApiResponse?> AddUserTagOrDefaultAsync(Guid userId, Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのアイコン画像を変更します
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="file">アイコン画像(2MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeUserIconApiResponse"/>&gt;</returns>
        Task<IChangeUserIconApiResponse> ChangeUserIconAsync(Guid userId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのアイコン画像を変更します
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="file">アイコン画像(2MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeUserIconApiResponse"/>?&gt;</returns>
        Task<IChangeUserIconApiResponse?> ChangeUserIconOrDefaultAsync(Guid userId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのパスワードを変更
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="putUserPasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeUserPasswordApiResponse"/>&gt;</returns>
        Task<IChangeUserPasswordApiResponse> ChangeUserPasswordAsync(Guid userId, Option<PutUserPasswordRequest> putUserPasswordRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのパスワードを変更
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="putUserPasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeUserPasswordApiResponse"/>?&gt;</returns>
        Task<IChangeUserPasswordApiResponse?> ChangeUserPasswordOrDefaultAsync(Guid userId, Option<PutUserPasswordRequest> putUserPasswordRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーを登録
        /// </summary>
        /// <remarks>
        /// ユーザーを登録します。 管理者権限が必要です。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postUserRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateUserApiResponse"/>&gt;</returns>
        Task<ICreateUserApiResponse> CreateUserAsync(Option<PostUserRequest> postUserRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーを登録
        /// </summary>
        /// <remarks>
        /// ユーザーを登録します。 管理者権限が必要です。
        /// </remarks>
        /// <param name="postUserRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateUserApiResponse"/>?&gt;</returns>
        Task<ICreateUserApiResponse?> CreateUserOrDefaultAsync(Option<PostUserRequest> postUserRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザー情報を変更
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの情報を変更します。 管理者権限が必要です。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="patchUserRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserApiResponse"/>&gt;</returns>
        Task<IEditUserApiResponse> EditUserAsync(Guid userId, Option<PatchUserRequest> patchUserRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザー情報を変更
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの情報を変更します。 管理者権限が必要です。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="patchUserRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserApiResponse"/>?&gt;</returns>
        Task<IEditUserApiResponse?> EditUserOrDefaultAsync(Guid userId, Option<PatchUserRequest> patchUserRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのタグを編集
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの指定したタグの状態を変更します。 他人の状態は変更できません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserTagApiResponse"/>&gt;</returns>
        Task<IEditUserTagApiResponse> EditUserTagAsync(Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのタグを編集
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの指定したタグの状態を変更します。 他人の状態は変更できません。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserTagApiResponse"/>?&gt;</returns>
        Task<IEditUserTagApiResponse?> EditUserTagOrDefaultAsync(Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ダイレクトメッセージのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーとのダイレクトメッセージのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDirectMessagesApiResponse"/>&gt;</returns>
        Task<IGetDirectMessagesApiResponse> GetDirectMessagesAsync(Guid userId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ダイレクトメッセージのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーとのダイレクトメッセージのリストを取得します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDirectMessagesApiResponse"/>?&gt;</returns>
        Task<IGetDirectMessagesApiResponse?> GetDirectMessagesOrDefaultAsync(Guid userId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザー詳細情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの詳細情報を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserApiResponse"/>&gt;</returns>
        Task<IGetUserApiResponse> GetUserAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザー詳細情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの詳細情報を取得します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserApiResponse"/>?&gt;</returns>
        Task<IGetUserApiResponse?> GetUserOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// DMチャンネル情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーとのダイレクトメッセージチャンネルの情報を返します。 ダイレクトメッセージチャンネルが存在しなかった場合、自動的に作成されます。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserDMChannelApiResponse"/>&gt;</returns>
        Task<IGetUserDMChannelApiResponse> GetUserDMChannelAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// DMチャンネル情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーとのダイレクトメッセージチャンネルの情報を返します。 ダイレクトメッセージチャンネルが存在しなかった場合、自動的に作成されます。
        /// </remarks>
        /// <param name="userId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserDMChannelApiResponse"/>?&gt;</returns>
        Task<IGetUserDMChannelApiResponse?> GetUserDMChannelOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのアイコン画像を取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのアイコン画像を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserIconApiResponse"/>&gt;</returns>
        Task<IGetUserIconApiResponse> GetUserIconAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのアイコン画像を取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのアイコン画像を取得します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserIconApiResponse"/>?&gt;</returns>
        Task<IGetUserIconApiResponse?> GetUserIconOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザー統計情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの統計情報を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserStatsApiResponse"/>&gt;</returns>
        Task<IGetUserStatsApiResponse> GetUserStatsAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザー統計情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの統計情報を取得します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserStatsApiResponse"/>?&gt;</returns>
        Task<IGetUserStatsApiResponse?> GetUserStatsOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのタグリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのタグリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserTagsApiResponse"/>&gt;</returns>
        Task<IGetUserTagsApiResponse> GetUserTagsAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのタグリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのタグリストを取得します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserTagsApiResponse"/>?&gt;</returns>
        Task<IGetUserTagsApiResponse?> GetUserTagsOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのリストを取得
        /// </summary>
        /// <remarks>
        /// ユーザーのリストを取得します。 &#x60;include-suspended&#x60;を指定しない場合、レスポンスにはユーザーアカウント状態が\&quot;1: 有効\&quot;であるユーザーのみが含まれます。 &#x60;include-suspended&#x60;と&#x60;name&#x60;を同時に指定することはできません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSuspended">アカウントがアクティブでないユーザーを含め、全てのユーザーを取得するかどうか (optional, default to false)</param>
        /// <param name="name">名前が一致するアカウントのみを取得する (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUsersApiResponse"/>&gt;</returns>
        Task<IGetUsersApiResponse> GetUsersAsync(Option<bool> includeSuspended = default, Option<string> name = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのリストを取得
        /// </summary>
        /// <remarks>
        /// ユーザーのリストを取得します。 &#x60;include-suspended&#x60;を指定しない場合、レスポンスにはユーザーアカウント状態が\&quot;1: 有効\&quot;であるユーザーのみが含まれます。 &#x60;include-suspended&#x60;と&#x60;name&#x60;を同時に指定することはできません。
        /// </remarks>
        /// <param name="includeSuspended">アカウントがアクティブでないユーザーを含め、全てのユーザーを取得するかどうか (optional, default to false)</param>
        /// <param name="name">名前が一致するアカウントのみを取得する (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUsersApiResponse"/>?&gt;</returns>
        Task<IGetUsersApiResponse?> GetUsersOrDefaultAsync(Option<bool> includeSuspended = default, Option<string> name = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ダイレクトメッセージを送信
        /// </summary>
        /// <remarks>
        /// 指定したユーザーにダイレクトメッセージを送信します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostDirectMessageApiResponse"/>&gt;</returns>
        Task<IPostDirectMessageApiResponse> PostDirectMessageAsync(Guid userId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ダイレクトメッセージを送信
        /// </summary>
        /// <remarks>
        /// 指定したユーザーにダイレクトメッセージを送信します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostDirectMessageApiResponse"/>?&gt;</returns>
        Task<IPostDirectMessageApiResponse?> PostDirectMessageOrDefaultAsync(Guid userId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーからタグを削除します
        /// </summary>
        /// <remarks>
        /// 既に存在しないタグを削除しようとした場合は204を返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUserTagApiResponse"/>&gt;</returns>
        Task<IRemoveUserTagApiResponse> RemoveUserTagAsync(Guid userId, Guid tagId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーからタグを削除します
        /// </summary>
        /// <remarks>
        /// 既に存在しないタグを削除しようとした場合は204を返します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUserTagApiResponse"/>?&gt;</returns>
        Task<IRemoveUserTagApiResponse?> RemoveUserTagOrDefaultAsync(Guid userId, Guid tagId, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddUserTagApiResponse"/>
    /// </summary>
    public interface IAddUserTagApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.UserTag?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }
    }

    /// <summary>
    /// The <see cref="IChangeUserIconApiResponse"/>
    /// </summary>
    public interface IChangeUserIconApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 413 ContentTooLarge
        /// </summary>
        /// <returns></returns>
        bool IsContentTooLarge { get; }
    }

    /// <summary>
    /// The <see cref="IChangeUserPasswordApiResponse"/>
    /// </summary>
    public interface IChangeUserPasswordApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ICreateUserApiResponse"/>
    /// </summary>
    public interface ICreateUserApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.UserDetail?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }
    }

    /// <summary>
    /// The <see cref="IEditUserApiResponse"/>
    /// </summary>
    public interface IEditUserApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IEditUserTagApiResponse"/>
    /// </summary>
    public interface IEditUserTagApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetDirectMessagesApiResponse"/>
    /// </summary>
    public interface IGetDirectMessagesApiResponse : Traq.Client.IApiResponse, IOk<List<Message>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetUserApiResponse"/>
    /// </summary>
    public interface IGetUserApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.UserDetail?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetUserDMChannelApiResponse"/>
    /// </summary>
    public interface IGetUserDMChannelApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.DMChannel?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetUserIconApiResponse"/>
    /// </summary>
    public interface IGetUserIconApiResponse : Traq.Client.IApiResponse, IOk<System.IO.Stream?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetUserStatsApiResponse"/>
    /// </summary>
    public interface IGetUserStatsApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.UserStats?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetUserTagsApiResponse"/>
    /// </summary>
    public interface IGetUserTagsApiResponse : Traq.Client.IApiResponse, IOk<List<UserTag>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetUsersApiResponse"/>
    /// </summary>
    public interface IGetUsersApiResponse : Traq.Client.IApiResponse, IOk<List<User>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IPostDirectMessageApiResponse"/>
    /// </summary>
    public interface IPostDirectMessageApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.Message?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveUserTagApiResponse"/>
    /// </summary>
    public interface IRemoveUserTagApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class UserApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddUserTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddUserTag;

        internal void ExecuteOnAddUserTag(UserApi.AddUserTagApiResponse apiResponse)
        {
            OnAddUserTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddUserTag(Exception exception)
        {
            OnErrorAddUserTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeUserIcon;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeUserIcon;

        internal void ExecuteOnChangeUserIcon(UserApi.ChangeUserIconApiResponse apiResponse)
        {
            OnChangeUserIcon?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeUserIcon(Exception exception)
        {
            OnErrorChangeUserIcon?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeUserPassword;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeUserPassword;

        internal void ExecuteOnChangeUserPassword(UserApi.ChangeUserPasswordApiResponse apiResponse)
        {
            OnChangeUserPassword?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeUserPassword(Exception exception)
        {
            OnErrorChangeUserPassword?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateUser;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateUser;

        internal void ExecuteOnCreateUser(UserApi.CreateUserApiResponse apiResponse)
        {
            OnCreateUser?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateUser(Exception exception)
        {
            OnErrorCreateUser?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditUser;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditUser;

        internal void ExecuteOnEditUser(UserApi.EditUserApiResponse apiResponse)
        {
            OnEditUser?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditUser(Exception exception)
        {
            OnErrorEditUser?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditUserTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditUserTag;

        internal void ExecuteOnEditUserTag(UserApi.EditUserTagApiResponse apiResponse)
        {
            OnEditUserTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditUserTag(Exception exception)
        {
            OnErrorEditUserTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetDirectMessages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetDirectMessages;

        internal void ExecuteOnGetDirectMessages(UserApi.GetDirectMessagesApiResponse apiResponse)
        {
            OnGetDirectMessages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetDirectMessages(Exception exception)
        {
            OnErrorGetDirectMessages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUser;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUser;

        internal void ExecuteOnGetUser(UserApi.GetUserApiResponse apiResponse)
        {
            OnGetUser?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUser(Exception exception)
        {
            OnErrorGetUser?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUserDMChannel;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUserDMChannel;

        internal void ExecuteOnGetUserDMChannel(UserApi.GetUserDMChannelApiResponse apiResponse)
        {
            OnGetUserDMChannel?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUserDMChannel(Exception exception)
        {
            OnErrorGetUserDMChannel?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUserIcon;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUserIcon;

        internal void ExecuteOnGetUserIcon(UserApi.GetUserIconApiResponse apiResponse)
        {
            OnGetUserIcon?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUserIcon(Exception exception)
        {
            OnErrorGetUserIcon?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUserStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUserStats;

        internal void ExecuteOnGetUserStats(UserApi.GetUserStatsApiResponse apiResponse)
        {
            OnGetUserStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUserStats(Exception exception)
        {
            OnErrorGetUserStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUserTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUserTags;

        internal void ExecuteOnGetUserTags(UserApi.GetUserTagsApiResponse apiResponse)
        {
            OnGetUserTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUserTags(Exception exception)
        {
            OnErrorGetUserTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUsers;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUsers;

        internal void ExecuteOnGetUsers(UserApi.GetUsersApiResponse apiResponse)
        {
            OnGetUsers?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUsers(Exception exception)
        {
            OnErrorGetUsers?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostDirectMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostDirectMessage;

        internal void ExecuteOnPostDirectMessage(UserApi.PostDirectMessageApiResponse apiResponse)
        {
            OnPostDirectMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostDirectMessage(Exception exception)
        {
            OnErrorPostDirectMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveUserTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveUserTag;

        internal void ExecuteOnRemoveUserTag(UserApi.RemoveUserTagApiResponse apiResponse)
        {
            OnRemoveUserTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveUserTag(Exception exception)
        {
            OnErrorRemoveUserTag?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class UserApi : IUserApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<UserApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public UserApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="UserApi"/> class.
        /// </summary>
        /// <returns></returns>
        public UserApi(ILogger<UserApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, UserApiEvents userApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<UserApi>();
            HttpClient = httpClient;
            Events = userApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatAddUserTag(ref Guid userId, Option<PostUserTagRequest> postUserTagRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postUserTagRequest"></param>
        /// <returns></returns>
        private void ValidateAddUserTag(Option<PostUserTagRequest> postUserTagRequest)
        {
            if (postUserTagRequest.IsSet && postUserTagRequest.Value == null)
                throw new ArgumentNullException(nameof(postUserTagRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="postUserTagRequest"></param>
        private void AfterAddUserTagDefaultImplementation(IAddUserTagApiResponse apiResponseLocalVar, Guid userId, Option<PostUserTagRequest> postUserTagRequest)
        {
            bool suppressDefaultLog = false;
            AfterAddUserTag(ref suppressDefaultLog, apiResponseLocalVar, userId, postUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="postUserTagRequest"></param>
        partial void AfterAddUserTag(ref bool suppressDefaultLog, IAddUserTagApiResponse apiResponseLocalVar, Guid userId, Option<PostUserTagRequest> postUserTagRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="postUserTagRequest"></param>
        private void OnErrorAddUserTagDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Option<PostUserTagRequest> postUserTagRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorAddUserTag(ref suppressDefaultLog, exception, pathFormat, path, userId, postUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="postUserTagRequest"></param>
        partial void OnErrorAddUserTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Option<PostUserTagRequest> postUserTagRequest);

        /// <summary>
        /// ユーザーにタグを追加 指定したユーザーに指定したタグを追加します。 Webhookユーザーにタグを追加することは出来ません。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUserTagApiResponse"/>&gt;</returns>
        public async Task<IAddUserTagApiResponse?> AddUserTagOrDefaultAsync(Guid userId, Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddUserTagAsync(userId, postUserTagRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーにタグを追加 指定したユーザーに指定したタグを追加します。 Webhookユーザーにタグを追加することは出来ません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUserTagApiResponse"/>&gt;</returns>
        public async Task<IAddUserTagApiResponse> AddUserTagAsync(Guid userId, Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddUserTag(postUserTagRequest);

                FormatAddUserTag(ref userId, postUserTagRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/tags";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    if (postUserTagRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postUserTagRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postUserTagRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AddUserTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddUserTagApiResponse>();

                        AddUserTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/tags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddUserTagDefaultImplementation(apiResponseLocalVar, userId, postUserTagRequest);

                        Events.ExecuteOnAddUserTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddUserTagDefaultImplementation(e, "/users/{userId}/tags", uriBuilderLocalVar.Path, userId, postUserTagRequest);
                Events.ExecuteOnErrorAddUserTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddUserTagApiResponse"/>
        /// </summary>
        public partial class AddUserTagApiResponse : Traq.Client.ApiResponse, IAddUserTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddUserTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddUserTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddUserTagApiResponse(ILogger<AddUserTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.UserTag? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.UserTag>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.UserTag? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeUserIcon(ref Guid userId, ref System.IO.Stream file);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="file"></param>
        /// <returns></returns>
        private void ValidateChangeUserIcon(System.IO.Stream file)
        {
            if (file == null)
                throw new ArgumentNullException(nameof(file));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="file"></param>
        private void AfterChangeUserIconDefaultImplementation(IChangeUserIconApiResponse apiResponseLocalVar, Guid userId, System.IO.Stream file)
        {
            bool suppressDefaultLog = false;
            AfterChangeUserIcon(ref suppressDefaultLog, apiResponseLocalVar, userId, file);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="file"></param>
        partial void AfterChangeUserIcon(ref bool suppressDefaultLog, IChangeUserIconApiResponse apiResponseLocalVar, Guid userId, System.IO.Stream file);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="file"></param>
        private void OnErrorChangeUserIconDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, System.IO.Stream file)
        {
            bool suppressDefaultLog = false;
            OnErrorChangeUserIcon(ref suppressDefaultLog, exception, pathFormat, path, userId, file);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="file"></param>
        partial void OnErrorChangeUserIcon(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, System.IO.Stream file);

        /// <summary>
        /// ユーザーのアイコン画像を変更します 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="file">アイコン画像(2MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeUserIconApiResponse"/>&gt;</returns>
        public async Task<IChangeUserIconApiResponse?> ChangeUserIconOrDefaultAsync(Guid userId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeUserIconAsync(userId, file, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーのアイコン画像を変更します 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="file">アイコン画像(2MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeUserIconApiResponse"/>&gt;</returns>
        public async Task<IChangeUserIconApiResponse> ChangeUserIconAsync(Guid userId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeUserIcon(file);

                FormatChangeUserIcon(ref userId, ref file);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/icon";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));                    multipartContentLocalVar.Add(new StreamContent(file));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "multipart/form-data"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeUserIconApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeUserIconApiResponse>();

                        ChangeUserIconApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/icon", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeUserIconDefaultImplementation(apiResponseLocalVar, userId, file);

                        Events.ExecuteOnChangeUserIcon(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeUserIconDefaultImplementation(e, "/users/{userId}/icon", uriBuilderLocalVar.Path, userId, file);
                Events.ExecuteOnErrorChangeUserIcon(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeUserIconApiResponse"/>
        /// </summary>
        public partial class ChangeUserIconApiResponse : Traq.Client.ApiResponse, IChangeUserIconApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeUserIconApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeUserIconApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeUserIconApiResponse(ILogger<ChangeUserIconApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 413 ContentTooLarge
            /// </summary>
            /// <returns></returns>
            public bool IsContentTooLarge => 413 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeUserPassword(ref Guid userId, Option<PutUserPasswordRequest> putUserPasswordRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="putUserPasswordRequest"></param>
        /// <returns></returns>
        private void ValidateChangeUserPassword(Option<PutUserPasswordRequest> putUserPasswordRequest)
        {
            if (putUserPasswordRequest.IsSet && putUserPasswordRequest.Value == null)
                throw new ArgumentNullException(nameof(putUserPasswordRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="putUserPasswordRequest"></param>
        private void AfterChangeUserPasswordDefaultImplementation(IChangeUserPasswordApiResponse apiResponseLocalVar, Guid userId, Option<PutUserPasswordRequest> putUserPasswordRequest)
        {
            bool suppressDefaultLog = false;
            AfterChangeUserPassword(ref suppressDefaultLog, apiResponseLocalVar, userId, putUserPasswordRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="putUserPasswordRequest"></param>
        partial void AfterChangeUserPassword(ref bool suppressDefaultLog, IChangeUserPasswordApiResponse apiResponseLocalVar, Guid userId, Option<PutUserPasswordRequest> putUserPasswordRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="putUserPasswordRequest"></param>
        private void OnErrorChangeUserPasswordDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Option<PutUserPasswordRequest> putUserPasswordRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorChangeUserPassword(ref suppressDefaultLog, exception, pathFormat, path, userId, putUserPasswordRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="putUserPasswordRequest"></param>
        partial void OnErrorChangeUserPassword(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Option<PutUserPasswordRequest> putUserPasswordRequest);

        /// <summary>
        /// ユーザーのパスワードを変更 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="putUserPasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeUserPasswordApiResponse"/>&gt;</returns>
        public async Task<IChangeUserPasswordApiResponse?> ChangeUserPasswordOrDefaultAsync(Guid userId, Option<PutUserPasswordRequest> putUserPasswordRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeUserPasswordAsync(userId, putUserPasswordRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーのパスワードを変更 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="putUserPasswordRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeUserPasswordApiResponse"/>&gt;</returns>
        public async Task<IChangeUserPasswordApiResponse> ChangeUserPasswordAsync(Guid userId, Option<PutUserPasswordRequest> putUserPasswordRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeUserPassword(putUserPasswordRequest);

                FormatChangeUserPassword(ref userId, putUserPasswordRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/password";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    if (putUserPasswordRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (putUserPasswordRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(putUserPasswordRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeUserPasswordApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeUserPasswordApiResponse>();

                        ChangeUserPasswordApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/password", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeUserPasswordDefaultImplementation(apiResponseLocalVar, userId, putUserPasswordRequest);

                        Events.ExecuteOnChangeUserPassword(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeUserPasswordDefaultImplementation(e, "/users/{userId}/password", uriBuilderLocalVar.Path, userId, putUserPasswordRequest);
                Events.ExecuteOnErrorChangeUserPassword(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeUserPasswordApiResponse"/>
        /// </summary>
        public partial class ChangeUserPasswordApiResponse : Traq.Client.ApiResponse, IChangeUserPasswordApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeUserPasswordApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeUserPasswordApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeUserPasswordApiResponse(ILogger<ChangeUserPasswordApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateUser(Option<PostUserRequest> postUserRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postUserRequest"></param>
        /// <returns></returns>
        private void ValidateCreateUser(Option<PostUserRequest> postUserRequest)
        {
            if (postUserRequest.IsSet && postUserRequest.Value == null)
                throw new ArgumentNullException(nameof(postUserRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postUserRequest"></param>
        private void AfterCreateUserDefaultImplementation(ICreateUserApiResponse apiResponseLocalVar, Option<PostUserRequest> postUserRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateUser(ref suppressDefaultLog, apiResponseLocalVar, postUserRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postUserRequest"></param>
        partial void AfterCreateUser(ref bool suppressDefaultLog, ICreateUserApiResponse apiResponseLocalVar, Option<PostUserRequest> postUserRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postUserRequest"></param>
        private void OnErrorCreateUserDefaultImplementation(Exception exception, string pathFormat, string path, Option<PostUserRequest> postUserRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorCreateUser(ref suppressDefaultLog, exception, pathFormat, path, postUserRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postUserRequest"></param>
        partial void OnErrorCreateUser(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<PostUserRequest> postUserRequest);

        /// <summary>
        /// ユーザーを登録 ユーザーを登録します。 管理者権限が必要です。
        /// </summary>
        /// <param name="postUserRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateUserApiResponse"/>&gt;</returns>
        public async Task<ICreateUserApiResponse?> CreateUserOrDefaultAsync(Option<PostUserRequest> postUserRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateUserAsync(postUserRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーを登録 ユーザーを登録します。 管理者権限が必要です。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postUserRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateUserApiResponse"/>&gt;</returns>
        public async Task<ICreateUserApiResponse> CreateUserAsync(Option<PostUserRequest> postUserRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateUser(postUserRequest);

                FormatCreateUser(postUserRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users";

                    if (postUserRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postUserRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postUserRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateUserApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateUserApiResponse>();

                        CreateUserApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateUserDefaultImplementation(apiResponseLocalVar, postUserRequest);

                        Events.ExecuteOnCreateUser(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateUserDefaultImplementation(e, "/users", uriBuilderLocalVar.Path, postUserRequest);
                Events.ExecuteOnErrorCreateUser(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateUserApiResponse"/>
        /// </summary>
        public partial class CreateUserApiResponse : Traq.Client.ApiResponse, ICreateUserApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateUserApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateUserApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateUserApiResponse(ILogger<CreateUserApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.UserDetail? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.UserDetail>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.UserDetail? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditUser(ref Guid userId, Option<PatchUserRequest> patchUserRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="patchUserRequest"></param>
        /// <returns></returns>
        private void ValidateEditUser(Option<PatchUserRequest> patchUserRequest)
        {
            if (patchUserRequest.IsSet && patchUserRequest.Value == null)
                throw new ArgumentNullException(nameof(patchUserRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="patchUserRequest"></param>
        private void AfterEditUserDefaultImplementation(IEditUserApiResponse apiResponseLocalVar, Guid userId, Option<PatchUserRequest> patchUserRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditUser(ref suppressDefaultLog, apiResponseLocalVar, userId, patchUserRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="patchUserRequest"></param>
        partial void AfterEditUser(ref bool suppressDefaultLog, IEditUserApiResponse apiResponseLocalVar, Guid userId, Option<PatchUserRequest> patchUserRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="patchUserRequest"></param>
        private void OnErrorEditUserDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Option<PatchUserRequest> patchUserRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditUser(ref suppressDefaultLog, exception, pathFormat, path, userId, patchUserRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="patchUserRequest"></param>
        partial void OnErrorEditUser(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Option<PatchUserRequest> patchUserRequest);

        /// <summary>
        /// ユーザー情報を変更 指定したユーザーの情報を変更します。 管理者権限が必要です。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="patchUserRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserApiResponse"/>&gt;</returns>
        public async Task<IEditUserApiResponse?> EditUserOrDefaultAsync(Guid userId, Option<PatchUserRequest> patchUserRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditUserAsync(userId, patchUserRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザー情報を変更 指定したユーザーの情報を変更します。 管理者権限が必要です。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="patchUserRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserApiResponse"/>&gt;</returns>
        public async Task<IEditUserApiResponse> EditUserAsync(Guid userId, Option<PatchUserRequest> patchUserRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditUser(patchUserRequest);

                FormatEditUser(ref userId, patchUserRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    if (patchUserRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchUserRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchUserRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditUserApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditUserApiResponse>();

                        EditUserApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditUserDefaultImplementation(apiResponseLocalVar, userId, patchUserRequest);

                        Events.ExecuteOnEditUser(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditUserDefaultImplementation(e, "/users/{userId}", uriBuilderLocalVar.Path, userId, patchUserRequest);
                Events.ExecuteOnErrorEditUser(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditUserApiResponse"/>
        /// </summary>
        public partial class EditUserApiResponse : Traq.Client.ApiResponse, IEditUserApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditUserApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditUserApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditUserApiResponse(ILogger<EditUserApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditUserTag(ref Guid userId, ref Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="patchUserTagRequest"></param>
        /// <returns></returns>
        private void ValidateEditUserTag(Option<PatchUserTagRequest> patchUserTagRequest)
        {
            if (patchUserTagRequest.IsSet && patchUserTagRequest.Value == null)
                throw new ArgumentNullException(nameof(patchUserTagRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        private void AfterEditUserTagDefaultImplementation(IEditUserTagApiResponse apiResponseLocalVar, Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditUserTag(ref suppressDefaultLog, apiResponseLocalVar, userId, tagId, patchUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        partial void AfterEditUserTag(ref bool suppressDefaultLog, IEditUserTagApiResponse apiResponseLocalVar, Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        private void OnErrorEditUserTagDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditUserTag(ref suppressDefaultLog, exception, pathFormat, path, userId, tagId, patchUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        partial void OnErrorEditUserTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest);

        /// <summary>
        /// ユーザーのタグを編集 指定したユーザーの指定したタグの状態を変更します。 他人の状態は変更できません。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserTagApiResponse"/>&gt;</returns>
        public async Task<IEditUserTagApiResponse?> EditUserTagOrDefaultAsync(Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditUserTagAsync(userId, tagId, patchUserTagRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーのタグを編集 指定したユーザーの指定したタグの状態を変更します。 他人の状態は変更できません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserTagApiResponse"/>&gt;</returns>
        public async Task<IEditUserTagApiResponse> EditUserTagAsync(Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditUserTag(patchUserTagRequest);

                FormatEditUserTag(ref userId, ref tagId, patchUserTagRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/tags/{tagId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtagId%7D", Uri.EscapeDataString(tagId.ToString()));

                    if (patchUserTagRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchUserTagRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchUserTagRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditUserTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditUserTagApiResponse>();

                        EditUserTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/tags/{tagId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditUserTagDefaultImplementation(apiResponseLocalVar, userId, tagId, patchUserTagRequest);

                        Events.ExecuteOnEditUserTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditUserTagDefaultImplementation(e, "/users/{userId}/tags/{tagId}", uriBuilderLocalVar.Path, userId, tagId, patchUserTagRequest);
                Events.ExecuteOnErrorEditUserTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditUserTagApiResponse"/>
        /// </summary>
        public partial class EditUserTagApiResponse : Traq.Client.ApiResponse, IEditUserTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditUserTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditUserTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditUserTagApiResponse(ILogger<EditUserTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetDirectMessages(ref Guid userId, ref Option<int> limit, ref Option<int> offset, ref Option<DateTimeOffset> since, ref Option<DateTimeOffset> until, ref Option<bool> inclusive, ref Option<string> order);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="order"></param>
        /// <returns></returns>
        private void ValidateGetDirectMessages(Option<string> order)
        {
            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        private void AfterGetDirectMessagesDefaultImplementation(IGetDirectMessagesApiResponse apiResponseLocalVar, Guid userId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order)
        {
            bool suppressDefaultLog = false;
            AfterGetDirectMessages(ref suppressDefaultLog, apiResponseLocalVar, userId, limit, offset, since, until, inclusive, order);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        partial void AfterGetDirectMessages(ref bool suppressDefaultLog, IGetDirectMessagesApiResponse apiResponseLocalVar, Guid userId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        private void OnErrorGetDirectMessagesDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order)
        {
            bool suppressDefaultLog = false;
            OnErrorGetDirectMessages(ref suppressDefaultLog, exception, pathFormat, path, userId, limit, offset, since, until, inclusive, order);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        partial void OnErrorGetDirectMessages(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order);

        /// <summary>
        /// ダイレクトメッセージのリストを取得 指定したユーザーとのダイレクトメッセージのリストを取得します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDirectMessagesApiResponse"/>&gt;</returns>
        public async Task<IGetDirectMessagesApiResponse?> GetDirectMessagesOrDefaultAsync(Guid userId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetDirectMessagesAsync(userId, limit, offset, since, until, inclusive, order, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ダイレクトメッセージのリストを取得 指定したユーザーとのダイレクトメッセージのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDirectMessagesApiResponse"/>&gt;</returns>
        public async Task<IGetDirectMessagesApiResponse> GetDirectMessagesAsync(Guid userId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetDirectMessages(order);

                FormatGetDirectMessages(ref userId, ref limit, ref offset, ref since, ref until, ref inclusive, ref order);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/messages";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (until.IsSet)
                        parseQueryStringLocalVar["until"] = ClientUtils.ParameterToString(until.Value);

                    if (inclusive.IsSet)
                        parseQueryStringLocalVar["inclusive"] = ClientUtils.ParameterToString(inclusive.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetDirectMessagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetDirectMessagesApiResponse>();

                        GetDirectMessagesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetDirectMessagesDefaultImplementation(apiResponseLocalVar, userId, limit, offset, since, until, inclusive, order);

                        Events.ExecuteOnGetDirectMessages(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetDirectMessagesDefaultImplementation(e, "/users/{userId}/messages", uriBuilderLocalVar.Path, userId, limit, offset, since, until, inclusive, order);
                Events.ExecuteOnErrorGetDirectMessages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetDirectMessagesApiResponse"/>
        /// </summary>
        public partial class GetDirectMessagesApiResponse : Traq.Client.ApiResponse, IGetDirectMessagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetDirectMessagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetDirectMessagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetDirectMessagesApiResponse(ILogger<GetDirectMessagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Message>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Message>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Message>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUser(ref Guid userId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        private void AfterGetUserDefaultImplementation(IGetUserApiResponse apiResponseLocalVar, Guid userId)
        {
            bool suppressDefaultLog = false;
            AfterGetUser(ref suppressDefaultLog, apiResponseLocalVar, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        partial void AfterGetUser(ref bool suppressDefaultLog, IGetUserApiResponse apiResponseLocalVar, Guid userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        private void OnErrorGetUserDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetUser(ref suppressDefaultLog, exception, pathFormat, path, userId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        partial void OnErrorGetUser(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId);

        /// <summary>
        /// ユーザー詳細情報を取得 指定したユーザーの詳細情報を取得します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserApiResponse"/>&gt;</returns>
        public async Task<IGetUserApiResponse?> GetUserOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUserAsync(userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザー詳細情報を取得 指定したユーザーの詳細情報を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserApiResponse"/>&gt;</returns>
        public async Task<IGetUserApiResponse> GetUserAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetUser(ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUserApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUserApiResponse>();

                        GetUserApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUserDefaultImplementation(apiResponseLocalVar, userId);

                        Events.ExecuteOnGetUser(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUserDefaultImplementation(e, "/users/{userId}", uriBuilderLocalVar.Path, userId);
                Events.ExecuteOnErrorGetUser(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUserApiResponse"/>
        /// </summary>
        public partial class GetUserApiResponse : Traq.Client.ApiResponse, IGetUserApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUserApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUserApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUserApiResponse(ILogger<GetUserApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.UserDetail? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.UserDetail>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.UserDetail? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUserDMChannel(ref Guid userId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        private void AfterGetUserDMChannelDefaultImplementation(IGetUserDMChannelApiResponse apiResponseLocalVar, Guid userId)
        {
            bool suppressDefaultLog = false;
            AfterGetUserDMChannel(ref suppressDefaultLog, apiResponseLocalVar, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        partial void AfterGetUserDMChannel(ref bool suppressDefaultLog, IGetUserDMChannelApiResponse apiResponseLocalVar, Guid userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        private void OnErrorGetUserDMChannelDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetUserDMChannel(ref suppressDefaultLog, exception, pathFormat, path, userId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        partial void OnErrorGetUserDMChannel(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId);

        /// <summary>
        /// DMチャンネル情報を取得 指定したユーザーとのダイレクトメッセージチャンネルの情報を返します。 ダイレクトメッセージチャンネルが存在しなかった場合、自動的に作成されます。
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserDMChannelApiResponse"/>&gt;</returns>
        public async Task<IGetUserDMChannelApiResponse?> GetUserDMChannelOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUserDMChannelAsync(userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// DMチャンネル情報を取得 指定したユーザーとのダイレクトメッセージチャンネルの情報を返します。 ダイレクトメッセージチャンネルが存在しなかった場合、自動的に作成されます。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserDMChannelApiResponse"/>&gt;</returns>
        public async Task<IGetUserDMChannelApiResponse> GetUserDMChannelAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetUserDMChannel(ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/dm-channel";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUserDMChannelApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUserDMChannelApiResponse>();

                        GetUserDMChannelApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/dm-channel", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUserDMChannelDefaultImplementation(apiResponseLocalVar, userId);

                        Events.ExecuteOnGetUserDMChannel(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUserDMChannelDefaultImplementation(e, "/users/{userId}/dm-channel", uriBuilderLocalVar.Path, userId);
                Events.ExecuteOnErrorGetUserDMChannel(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUserDMChannelApiResponse"/>
        /// </summary>
        public partial class GetUserDMChannelApiResponse : Traq.Client.ApiResponse, IGetUserDMChannelApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUserDMChannelApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUserDMChannelApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUserDMChannelApiResponse(ILogger<GetUserDMChannelApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.DMChannel? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.DMChannel>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.DMChannel? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUserIcon(ref Guid userId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        private void AfterGetUserIconDefaultImplementation(IGetUserIconApiResponse apiResponseLocalVar, Guid userId)
        {
            bool suppressDefaultLog = false;
            AfterGetUserIcon(ref suppressDefaultLog, apiResponseLocalVar, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        partial void AfterGetUserIcon(ref bool suppressDefaultLog, IGetUserIconApiResponse apiResponseLocalVar, Guid userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        private void OnErrorGetUserIconDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetUserIcon(ref suppressDefaultLog, exception, pathFormat, path, userId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        partial void OnErrorGetUserIcon(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId);

        /// <summary>
        /// ユーザーのアイコン画像を取得 指定したユーザーのアイコン画像を取得します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserIconApiResponse"/>&gt;</returns>
        public async Task<IGetUserIconApiResponse?> GetUserIconOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUserIconAsync(userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーのアイコン画像を取得 指定したユーザーのアイコン画像を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserIconApiResponse"/>&gt;</returns>
        public async Task<IGetUserIconApiResponse> GetUserIconAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetUserIcon(ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/icon";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "image/jpeg",
                        "image/gif",
                        "image/png"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUserIconApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUserIconApiResponse>();

                        GetUserIconApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/icon", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUserIconDefaultImplementation(apiResponseLocalVar, userId);

                        Events.ExecuteOnGetUserIcon(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUserIconDefaultImplementation(e, "/users/{userId}/icon", uriBuilderLocalVar.Path, userId);
                Events.ExecuteOnErrorGetUserIcon(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUserIconApiResponse"/>
        /// </summary>
        public partial class GetUserIconApiResponse : Traq.Client.ApiResponse, IGetUserIconApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUserIconApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUserIconApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUserIconApiResponse(ILogger<GetUserIconApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public System.IO.Stream? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<System.IO.Stream>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out System.IO.Stream? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUserStats(ref Guid userId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        private void AfterGetUserStatsDefaultImplementation(IGetUserStatsApiResponse apiResponseLocalVar, Guid userId)
        {
            bool suppressDefaultLog = false;
            AfterGetUserStats(ref suppressDefaultLog, apiResponseLocalVar, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        partial void AfterGetUserStats(ref bool suppressDefaultLog, IGetUserStatsApiResponse apiResponseLocalVar, Guid userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        private void OnErrorGetUserStatsDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetUserStats(ref suppressDefaultLog, exception, pathFormat, path, userId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        partial void OnErrorGetUserStats(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId);

        /// <summary>
        /// ユーザー統計情報を取得 指定したユーザーの統計情報を取得します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserStatsApiResponse"/>&gt;</returns>
        public async Task<IGetUserStatsApiResponse?> GetUserStatsOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUserStatsAsync(userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザー統計情報を取得 指定したユーザーの統計情報を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserStatsApiResponse"/>&gt;</returns>
        public async Task<IGetUserStatsApiResponse> GetUserStatsAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetUserStats(ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/stats";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUserStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUserStatsApiResponse>();

                        GetUserStatsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/stats", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUserStatsDefaultImplementation(apiResponseLocalVar, userId);

                        Events.ExecuteOnGetUserStats(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUserStatsDefaultImplementation(e, "/users/{userId}/stats", uriBuilderLocalVar.Path, userId);
                Events.ExecuteOnErrorGetUserStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUserStatsApiResponse"/>
        /// </summary>
        public partial class GetUserStatsApiResponse : Traq.Client.ApiResponse, IGetUserStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUserStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUserStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUserStatsApiResponse(ILogger<GetUserStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.UserStats? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.UserStats>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.UserStats? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUserTags(ref Guid userId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        private void AfterGetUserTagsDefaultImplementation(IGetUserTagsApiResponse apiResponseLocalVar, Guid userId)
        {
            bool suppressDefaultLog = false;
            AfterGetUserTags(ref suppressDefaultLog, apiResponseLocalVar, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        partial void AfterGetUserTags(ref bool suppressDefaultLog, IGetUserTagsApiResponse apiResponseLocalVar, Guid userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        private void OnErrorGetUserTagsDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetUserTags(ref suppressDefaultLog, exception, pathFormat, path, userId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        partial void OnErrorGetUserTags(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId);

        /// <summary>
        /// ユーザーのタグリストを取得 指定したユーザーのタグリストを取得します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserTagsApiResponse"/>&gt;</returns>
        public async Task<IGetUserTagsApiResponse?> GetUserTagsOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUserTagsAsync(userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーのタグリストを取得 指定したユーザーのタグリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserTagsApiResponse"/>&gt;</returns>
        public async Task<IGetUserTagsApiResponse> GetUserTagsAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetUserTags(ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/tags";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUserTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUserTagsApiResponse>();

                        GetUserTagsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/tags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUserTagsDefaultImplementation(apiResponseLocalVar, userId);

                        Events.ExecuteOnGetUserTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUserTagsDefaultImplementation(e, "/users/{userId}/tags", uriBuilderLocalVar.Path, userId);
                Events.ExecuteOnErrorGetUserTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUserTagsApiResponse"/>
        /// </summary>
        public partial class GetUserTagsApiResponse : Traq.Client.ApiResponse, IGetUserTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUserTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUserTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUserTagsApiResponse(ILogger<GetUserTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<UserTag>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<UserTag>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<UserTag>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUsers(ref Option<bool> includeSuspended, ref Option<string> name);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private void ValidateGetUsers(Option<string> name)
        {
            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="includeSuspended"></param>
        /// <param name="name"></param>
        private void AfterGetUsersDefaultImplementation(IGetUsersApiResponse apiResponseLocalVar, Option<bool> includeSuspended, Option<string> name)
        {
            bool suppressDefaultLog = false;
            AfterGetUsers(ref suppressDefaultLog, apiResponseLocalVar, includeSuspended, name);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="includeSuspended"></param>
        /// <param name="name"></param>
        partial void AfterGetUsers(ref bool suppressDefaultLog, IGetUsersApiResponse apiResponseLocalVar, Option<bool> includeSuspended, Option<string> name);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="includeSuspended"></param>
        /// <param name="name"></param>
        private void OnErrorGetUsersDefaultImplementation(Exception exception, string pathFormat, string path, Option<bool> includeSuspended, Option<string> name)
        {
            bool suppressDefaultLog = false;
            OnErrorGetUsers(ref suppressDefaultLog, exception, pathFormat, path, includeSuspended, name);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="includeSuspended"></param>
        /// <param name="name"></param>
        partial void OnErrorGetUsers(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<bool> includeSuspended, Option<string> name);

        /// <summary>
        /// ユーザーのリストを取得 ユーザーのリストを取得します。 &#x60;include-suspended&#x60;を指定しない場合、レスポンスにはユーザーアカウント状態が\&quot;1: 有効\&quot;であるユーザーのみが含まれます。 &#x60;include-suspended&#x60;と&#x60;name&#x60;を同時に指定することはできません。
        /// </summary>
        /// <param name="includeSuspended">アカウントがアクティブでないユーザーを含め、全てのユーザーを取得するかどうか (optional, default to false)</param>
        /// <param name="name">名前が一致するアカウントのみを取得する (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUsersApiResponse"/>&gt;</returns>
        public async Task<IGetUsersApiResponse?> GetUsersOrDefaultAsync(Option<bool> includeSuspended = default, Option<string> name = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUsersAsync(includeSuspended, name, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーのリストを取得 ユーザーのリストを取得します。 &#x60;include-suspended&#x60;を指定しない場合、レスポンスにはユーザーアカウント状態が\&quot;1: 有効\&quot;であるユーザーのみが含まれます。 &#x60;include-suspended&#x60;と&#x60;name&#x60;を同時に指定することはできません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSuspended">アカウントがアクティブでないユーザーを含め、全てのユーザーを取得するかどうか (optional, default to false)</param>
        /// <param name="name">名前が一致するアカウントのみを取得する (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUsersApiResponse"/>&gt;</returns>
        public async Task<IGetUsersApiResponse> GetUsersAsync(Option<bool> includeSuspended = default, Option<string> name = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetUsers(name);

                FormatGetUsers(ref includeSuspended, ref name);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (includeSuspended.IsSet)
                        parseQueryStringLocalVar["include-suspended"] = ClientUtils.ParameterToString(includeSuspended.Value);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUsersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUsersApiResponse>();

                        GetUsersApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUsersDefaultImplementation(apiResponseLocalVar, includeSuspended, name);

                        Events.ExecuteOnGetUsers(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUsersDefaultImplementation(e, "/users", uriBuilderLocalVar.Path, includeSuspended, name);
                Events.ExecuteOnErrorGetUsers(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUsersApiResponse"/>
        /// </summary>
        public partial class GetUsersApiResponse : Traq.Client.ApiResponse, IGetUsersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUsersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUsersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUsersApiResponse(ILogger<GetUsersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<User>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<User>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<User>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostDirectMessage(ref Guid userId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postMessageRequest"></param>
        /// <returns></returns>
        private void ValidatePostDirectMessage(Option<PostMessageRequest> postMessageRequest)
        {
            if (postMessageRequest.IsSet && postMessageRequest.Value == null)
                throw new ArgumentNullException(nameof(postMessageRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="postMessageRequest"></param>
        private void AfterPostDirectMessageDefaultImplementation(IPostDirectMessageApiResponse apiResponseLocalVar, Guid userId, Option<PostMessageRequest> postMessageRequest)
        {
            bool suppressDefaultLog = false;
            AfterPostDirectMessage(ref suppressDefaultLog, apiResponseLocalVar, userId, postMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="postMessageRequest"></param>
        partial void AfterPostDirectMessage(ref bool suppressDefaultLog, IPostDirectMessageApiResponse apiResponseLocalVar, Guid userId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="postMessageRequest"></param>
        private void OnErrorPostDirectMessageDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Option<PostMessageRequest> postMessageRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorPostDirectMessage(ref suppressDefaultLog, exception, pathFormat, path, userId, postMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="postMessageRequest"></param>
        partial void OnErrorPostDirectMessage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// ダイレクトメッセージを送信 指定したユーザーにダイレクトメッセージを送信します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostDirectMessageApiResponse"/>&gt;</returns>
        public async Task<IPostDirectMessageApiResponse?> PostDirectMessageOrDefaultAsync(Guid userId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostDirectMessageAsync(userId, postMessageRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ダイレクトメッセージを送信 指定したユーザーにダイレクトメッセージを送信します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostDirectMessageApiResponse"/>&gt;</returns>
        public async Task<IPostDirectMessageApiResponse> PostDirectMessageAsync(Guid userId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostDirectMessage(postMessageRequest);

                FormatPostDirectMessage(ref userId, postMessageRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/messages";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    if (postMessageRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postMessageRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postMessageRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostDirectMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostDirectMessageApiResponse>();

                        PostDirectMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostDirectMessageDefaultImplementation(apiResponseLocalVar, userId, postMessageRequest);

                        Events.ExecuteOnPostDirectMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostDirectMessageDefaultImplementation(e, "/users/{userId}/messages", uriBuilderLocalVar.Path, userId, postMessageRequest);
                Events.ExecuteOnErrorPostDirectMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostDirectMessageApiResponse"/>
        /// </summary>
        public partial class PostDirectMessageApiResponse : Traq.Client.ApiResponse, IPostDirectMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostDirectMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostDirectMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostDirectMessageApiResponse(ILogger<PostDirectMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.Message? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.Message>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.Message? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveUserTag(ref Guid userId, ref Guid tagId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        private void AfterRemoveUserTagDefaultImplementation(IRemoveUserTagApiResponse apiResponseLocalVar, Guid userId, Guid tagId)
        {
            bool suppressDefaultLog = false;
            AfterRemoveUserTag(ref suppressDefaultLog, apiResponseLocalVar, userId, tagId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        partial void AfterRemoveUserTag(ref bool suppressDefaultLog, IRemoveUserTagApiResponse apiResponseLocalVar, Guid userId, Guid tagId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        private void OnErrorRemoveUserTagDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Guid tagId)
        {
            bool suppressDefaultLog = false;
            OnErrorRemoveUserTag(ref suppressDefaultLog, exception, pathFormat, path, userId, tagId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        partial void OnErrorRemoveUserTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Guid tagId);

        /// <summary>
        /// ユーザーからタグを削除します 既に存在しないタグを削除しようとした場合は204を返します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUserTagApiResponse"/>&gt;</returns>
        public async Task<IRemoveUserTagApiResponse?> RemoveUserTagOrDefaultAsync(Guid userId, Guid tagId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveUserTagAsync(userId, tagId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーからタグを削除します 既に存在しないタグを削除しようとした場合は204を返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUserTagApiResponse"/>&gt;</returns>
        public async Task<IRemoveUserTagApiResponse> RemoveUserTagAsync(Guid userId, Guid tagId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRemoveUserTag(ref userId, ref tagId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/tags/{tagId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtagId%7D", Uri.EscapeDataString(tagId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemoveUserTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveUserTagApiResponse>();

                        RemoveUserTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/tags/{tagId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemoveUserTagDefaultImplementation(apiResponseLocalVar, userId, tagId);

                        Events.ExecuteOnRemoveUserTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveUserTagDefaultImplementation(e, "/users/{userId}/tags/{tagId}", uriBuilderLocalVar.Path, userId, tagId);
                Events.ExecuteOnErrorRemoveUserTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveUserTagApiResponse"/>
        /// </summary>
        public partial class RemoveUserTagApiResponse : Traq.Client.ApiResponse, IRemoveUserTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveUserTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveUserTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveUserTagApiResponse(ILogger<RemoveUserTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
