// <auto-generated>
/*
 * traQ v3
 *
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Traq.Client;
using Traq.Model;
using System.Diagnostics.CodeAnalysis;

namespace Traq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IClipApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ClipApiEvents Events { get; }

        /// <summary>
        /// メッセージをクリップフォルダに追加
        /// </summary>
        /// <remarks>
        /// 指定したメッセージを指定したクリップフォルダに追加します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="postClipFolderMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IClipMessageApiResponse"/>&gt;</returns>
        Task<IClipMessageApiResponse> ClipMessageAsync(Guid folderId, Option<PostClipFolderMessageRequest> postClipFolderMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージをクリップフォルダに追加
        /// </summary>
        /// <remarks>
        /// 指定したメッセージを指定したクリップフォルダに追加します。
        /// </remarks>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="postClipFolderMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IClipMessageApiResponse"/>?&gt;</returns>
        Task<IClipMessageApiResponse?> ClipMessageOrDefaultAsync(Guid folderId, Option<PostClipFolderMessageRequest> postClipFolderMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダを作成
        /// </summary>
        /// <remarks>
        /// クリップフォルダを作成します。 既にあるフォルダと同名のフォルダを作成することは可能です。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postClipFolderRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClipFolderApiResponse"/>&gt;</returns>
        Task<ICreateClipFolderApiResponse> CreateClipFolderAsync(Option<PostClipFolderRequest> postClipFolderRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダを作成
        /// </summary>
        /// <remarks>
        /// クリップフォルダを作成します。 既にあるフォルダと同名のフォルダを作成することは可能です。
        /// </remarks>
        /// <param name="postClipFolderRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClipFolderApiResponse"/>?&gt;</returns>
        Task<ICreateClipFolderApiResponse?> CreateClipFolderOrDefaultAsync(Option<PostClipFolderRequest> postClipFolderRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダを削除
        /// </summary>
        /// <remarks>
        /// 指定したクリップフォルダを削除します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteClipFolderApiResponse"/>&gt;</returns>
        Task<IDeleteClipFolderApiResponse> DeleteClipFolderAsync(Guid folderId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダを削除
        /// </summary>
        /// <remarks>
        /// 指定したクリップフォルダを削除します。
        /// </remarks>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteClipFolderApiResponse"/>?&gt;</returns>
        Task<IDeleteClipFolderApiResponse?> DeleteClipFolderOrDefaultAsync(Guid folderId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダ情報を編集
        /// </summary>
        /// <remarks>
        /// 指定したクリップフォルダの情報を編集します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="patchClipFolderRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditClipFolderApiResponse"/>&gt;</returns>
        Task<IEditClipFolderApiResponse> EditClipFolderAsync(Guid folderId, Option<PatchClipFolderRequest> patchClipFolderRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダ情報を編集
        /// </summary>
        /// <remarks>
        /// 指定したクリップフォルダの情報を編集します。
        /// </remarks>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="patchClipFolderRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditClipFolderApiResponse"/>?&gt;</returns>
        Task<IEditClipFolderApiResponse?> EditClipFolderOrDefaultAsync(Guid folderId, Option<PatchClipFolderRequest> patchClipFolderRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダ情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したクリップフォルダの情報を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipFolderApiResponse"/>&gt;</returns>
        Task<IGetClipFolderApiResponse> GetClipFolderAsync(Guid folderId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダ情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したクリップフォルダの情報を取得します。
        /// </remarks>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipFolderApiResponse"/>?&gt;</returns>
        Task<IGetClipFolderApiResponse?> GetClipFolderOrDefaultAsync(Guid folderId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダのリストを取得
        /// </summary>
        /// <remarks>
        /// 自身が所有するクリップフォルダのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipFoldersApiResponse"/>&gt;</returns>
        Task<IGetClipFoldersApiResponse> GetClipFoldersAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// クリップフォルダのリストを取得
        /// </summary>
        /// <remarks>
        /// 自身が所有するクリップフォルダのリストを取得します。
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipFoldersApiResponse"/>?&gt;</returns>
        Task<IGetClipFoldersApiResponse?> GetClipFoldersOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// フォルダ内のクリップのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したフォルダ内のクリップのリストを取得します。 &#x60;order&#x60;を指定しない場合、クリップした日時の新しい順で返されます。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipsApiResponse"/>&gt;</returns>
        Task<IGetClipsApiResponse> GetClipsAsync(Guid folderId, Option<int> limit = default, Option<int> offset = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// フォルダ内のクリップのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したフォルダ内のクリップのリストを取得します。 &#x60;order&#x60;を指定しない場合、クリップした日時の新しい順で返されます。
        /// </remarks>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipsApiResponse"/>?&gt;</returns>
        Task<IGetClipsApiResponse?> GetClipsOrDefaultAsync(Guid folderId, Option<int> limit = default, Option<int> offset = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のクリップを取得
        /// </summary>
        /// <remarks>
        /// 対象のメッセージの自分のクリップの一覧を返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageClipsApiResponse"/>&gt;</returns>
        Task<IGetMessageClipsApiResponse> GetMessageClipsAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のクリップを取得
        /// </summary>
        /// <remarks>
        /// 対象のメッセージの自分のクリップの一覧を返します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageClipsApiResponse"/>?&gt;</returns>
        Task<IGetMessageClipsApiResponse?> GetMessageClipsOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージをクリップフォルダから除外
        /// </summary>
        /// <remarks>
        /// 指定したフォルダから指定したメッセージのクリップを除外します。 既に外されているメッセージを指定した場合は204を返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnclipMessageApiResponse"/>&gt;</returns>
        Task<IUnclipMessageApiResponse> UnclipMessageAsync(Guid folderId, Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージをクリップフォルダから除外
        /// </summary>
        /// <remarks>
        /// 指定したフォルダから指定したメッセージのクリップを除外します。 既に外されているメッセージを指定した場合は204を返します。
        /// </remarks>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnclipMessageApiResponse"/>?&gt;</returns>
        Task<IUnclipMessageApiResponse?> UnclipMessageOrDefaultAsync(Guid folderId, Guid messageId, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IClipMessageApiResponse"/>
    /// </summary>
    public interface IClipMessageApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.ClippedMessage?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }
    }

    /// <summary>
    /// The <see cref="ICreateClipFolderApiResponse"/>
    /// </summary>
    public interface ICreateClipFolderApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.ClipFolder?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteClipFolderApiResponse"/>
    /// </summary>
    public interface IDeleteClipFolderApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IEditClipFolderApiResponse"/>
    /// </summary>
    public interface IEditClipFolderApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetClipFolderApiResponse"/>
    /// </summary>
    public interface IGetClipFolderApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.ClipFolder?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetClipFoldersApiResponse"/>
    /// </summary>
    public interface IGetClipFoldersApiResponse : Traq.Client.IApiResponse, IOk<List<ClipFolder>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetClipsApiResponse"/>
    /// </summary>
    public interface IGetClipsApiResponse : Traq.Client.IApiResponse, IOk<List<ClippedMessage>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetMessageClipsApiResponse"/>
    /// </summary>
    public interface IGetMessageClipsApiResponse : Traq.Client.IApiResponse, IOk<List<MessageClip>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IUnclipMessageApiResponse"/>
    /// </summary>
    public interface IUnclipMessageApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ClipApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnClipMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorClipMessage;

        internal void ExecuteOnClipMessage(ClipApi.ClipMessageApiResponse apiResponse)
        {
            OnClipMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorClipMessage(Exception exception)
        {
            OnErrorClipMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateClipFolder;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateClipFolder;

        internal void ExecuteOnCreateClipFolder(ClipApi.CreateClipFolderApiResponse apiResponse)
        {
            OnCreateClipFolder?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateClipFolder(Exception exception)
        {
            OnErrorCreateClipFolder?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteClipFolder;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteClipFolder;

        internal void ExecuteOnDeleteClipFolder(ClipApi.DeleteClipFolderApiResponse apiResponse)
        {
            OnDeleteClipFolder?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteClipFolder(Exception exception)
        {
            OnErrorDeleteClipFolder?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditClipFolder;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditClipFolder;

        internal void ExecuteOnEditClipFolder(ClipApi.EditClipFolderApiResponse apiResponse)
        {
            OnEditClipFolder?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditClipFolder(Exception exception)
        {
            OnErrorEditClipFolder?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetClipFolder;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetClipFolder;

        internal void ExecuteOnGetClipFolder(ClipApi.GetClipFolderApiResponse apiResponse)
        {
            OnGetClipFolder?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetClipFolder(Exception exception)
        {
            OnErrorGetClipFolder?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetClipFolders;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetClipFolders;

        internal void ExecuteOnGetClipFolders(ClipApi.GetClipFoldersApiResponse apiResponse)
        {
            OnGetClipFolders?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetClipFolders(Exception exception)
        {
            OnErrorGetClipFolders?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetClips;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetClips;

        internal void ExecuteOnGetClips(ClipApi.GetClipsApiResponse apiResponse)
        {
            OnGetClips?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetClips(Exception exception)
        {
            OnErrorGetClips?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMessageClips;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMessageClips;

        internal void ExecuteOnGetMessageClips(ClipApi.GetMessageClipsApiResponse apiResponse)
        {
            OnGetMessageClips?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMessageClips(Exception exception)
        {
            OnErrorGetMessageClips?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUnclipMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUnclipMessage;

        internal void ExecuteOnUnclipMessage(ClipApi.UnclipMessageApiResponse apiResponse)
        {
            OnUnclipMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUnclipMessage(Exception exception)
        {
            OnErrorUnclipMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ClipApi : IClipApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ClipApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ClipApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ClipApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ClipApi(ILogger<ClipApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ClipApiEvents clipApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ClipApi>();
            HttpClient = httpClient;
            Events = clipApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatClipMessage(ref Guid folderId, Option<PostClipFolderMessageRequest> postClipFolderMessageRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postClipFolderMessageRequest"></param>
        /// <returns></returns>
        private void ValidateClipMessage(Option<PostClipFolderMessageRequest> postClipFolderMessageRequest)
        {
            if (postClipFolderMessageRequest.IsSet && postClipFolderMessageRequest.Value == null)
                throw new ArgumentNullException(nameof(postClipFolderMessageRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="postClipFolderMessageRequest"></param>
        private void AfterClipMessageDefaultImplementation(IClipMessageApiResponse apiResponseLocalVar, Guid folderId, Option<PostClipFolderMessageRequest> postClipFolderMessageRequest)
        {
            bool suppressDefaultLog = false;
            AfterClipMessage(ref suppressDefaultLog, apiResponseLocalVar, folderId, postClipFolderMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="postClipFolderMessageRequest"></param>
        partial void AfterClipMessage(ref bool suppressDefaultLog, IClipMessageApiResponse apiResponseLocalVar, Guid folderId, Option<PostClipFolderMessageRequest> postClipFolderMessageRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="postClipFolderMessageRequest"></param>
        private void OnErrorClipMessageDefaultImplementation(Exception exception, string pathFormat, string path, Guid folderId, Option<PostClipFolderMessageRequest> postClipFolderMessageRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorClipMessage(ref suppressDefaultLog, exception, pathFormat, path, folderId, postClipFolderMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="postClipFolderMessageRequest"></param>
        partial void OnErrorClipMessage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid folderId, Option<PostClipFolderMessageRequest> postClipFolderMessageRequest);

        /// <summary>
        /// メッセージをクリップフォルダに追加 指定したメッセージを指定したクリップフォルダに追加します。
        /// </summary>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="postClipFolderMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IClipMessageApiResponse"/>&gt;</returns>
        public async Task<IClipMessageApiResponse?> ClipMessageOrDefaultAsync(Guid folderId, Option<PostClipFolderMessageRequest> postClipFolderMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ClipMessageAsync(folderId, postClipFolderMessageRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// メッセージをクリップフォルダに追加 指定したメッセージを指定したクリップフォルダに追加します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="postClipFolderMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IClipMessageApiResponse"/>&gt;</returns>
        public async Task<IClipMessageApiResponse> ClipMessageAsync(Guid folderId, Option<PostClipFolderMessageRequest> postClipFolderMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateClipMessage(postClipFolderMessageRequest);

                FormatClipMessage(ref folderId, postClipFolderMessageRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clip-folders/{folderId}/messages";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfolderId%7D", Uri.EscapeDataString(folderId.ToString()));

                    if (postClipFolderMessageRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postClipFolderMessageRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postClipFolderMessageRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ClipMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ClipMessageApiResponse>();

                        ClipMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clip-folders/{folderId}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterClipMessageDefaultImplementation(apiResponseLocalVar, folderId, postClipFolderMessageRequest);

                        Events.ExecuteOnClipMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorClipMessageDefaultImplementation(e, "/clip-folders/{folderId}/messages", uriBuilderLocalVar.Path, folderId, postClipFolderMessageRequest);
                Events.ExecuteOnErrorClipMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ClipMessageApiResponse"/>
        /// </summary>
        public partial class ClipMessageApiResponse : Traq.Client.ApiResponse, IClipMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ClipMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ClipMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ClipMessageApiResponse(ILogger<ClipMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.ClippedMessage? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.ClippedMessage>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.ClippedMessage? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateClipFolder(Option<PostClipFolderRequest> postClipFolderRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postClipFolderRequest"></param>
        /// <returns></returns>
        private void ValidateCreateClipFolder(Option<PostClipFolderRequest> postClipFolderRequest)
        {
            if (postClipFolderRequest.IsSet && postClipFolderRequest.Value == null)
                throw new ArgumentNullException(nameof(postClipFolderRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postClipFolderRequest"></param>
        private void AfterCreateClipFolderDefaultImplementation(ICreateClipFolderApiResponse apiResponseLocalVar, Option<PostClipFolderRequest> postClipFolderRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateClipFolder(ref suppressDefaultLog, apiResponseLocalVar, postClipFolderRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postClipFolderRequest"></param>
        partial void AfterCreateClipFolder(ref bool suppressDefaultLog, ICreateClipFolderApiResponse apiResponseLocalVar, Option<PostClipFolderRequest> postClipFolderRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postClipFolderRequest"></param>
        private void OnErrorCreateClipFolderDefaultImplementation(Exception exception, string pathFormat, string path, Option<PostClipFolderRequest> postClipFolderRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorCreateClipFolder(ref suppressDefaultLog, exception, pathFormat, path, postClipFolderRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postClipFolderRequest"></param>
        partial void OnErrorCreateClipFolder(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<PostClipFolderRequest> postClipFolderRequest);

        /// <summary>
        /// クリップフォルダを作成 クリップフォルダを作成します。 既にあるフォルダと同名のフォルダを作成することは可能です。
        /// </summary>
        /// <param name="postClipFolderRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClipFolderApiResponse"/>&gt;</returns>
        public async Task<ICreateClipFolderApiResponse?> CreateClipFolderOrDefaultAsync(Option<PostClipFolderRequest> postClipFolderRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateClipFolderAsync(postClipFolderRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// クリップフォルダを作成 クリップフォルダを作成します。 既にあるフォルダと同名のフォルダを作成することは可能です。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postClipFolderRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClipFolderApiResponse"/>&gt;</returns>
        public async Task<ICreateClipFolderApiResponse> CreateClipFolderAsync(Option<PostClipFolderRequest> postClipFolderRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateClipFolder(postClipFolderRequest);

                FormatCreateClipFolder(postClipFolderRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clip-folders";

                    if (postClipFolderRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postClipFolderRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postClipFolderRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateClipFolderApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateClipFolderApiResponse>();

                        CreateClipFolderApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clip-folders", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateClipFolderDefaultImplementation(apiResponseLocalVar, postClipFolderRequest);

                        Events.ExecuteOnCreateClipFolder(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateClipFolderDefaultImplementation(e, "/clip-folders", uriBuilderLocalVar.Path, postClipFolderRequest);
                Events.ExecuteOnErrorCreateClipFolder(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateClipFolderApiResponse"/>
        /// </summary>
        public partial class CreateClipFolderApiResponse : Traq.Client.ApiResponse, ICreateClipFolderApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateClipFolderApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateClipFolderApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateClipFolderApiResponse(ILogger<CreateClipFolderApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.ClipFolder? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.ClipFolder>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.ClipFolder? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteClipFolder(ref Guid folderId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        private void AfterDeleteClipFolderDefaultImplementation(IDeleteClipFolderApiResponse apiResponseLocalVar, Guid folderId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteClipFolder(ref suppressDefaultLog, apiResponseLocalVar, folderId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        partial void AfterDeleteClipFolder(ref bool suppressDefaultLog, IDeleteClipFolderApiResponse apiResponseLocalVar, Guid folderId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        private void OnErrorDeleteClipFolderDefaultImplementation(Exception exception, string pathFormat, string path, Guid folderId)
        {
            bool suppressDefaultLog = false;
            OnErrorDeleteClipFolder(ref suppressDefaultLog, exception, pathFormat, path, folderId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        partial void OnErrorDeleteClipFolder(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid folderId);

        /// <summary>
        /// クリップフォルダを削除 指定したクリップフォルダを削除します。
        /// </summary>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteClipFolderApiResponse"/>&gt;</returns>
        public async Task<IDeleteClipFolderApiResponse?> DeleteClipFolderOrDefaultAsync(Guid folderId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteClipFolderAsync(folderId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// クリップフォルダを削除 指定したクリップフォルダを削除します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteClipFolderApiResponse"/>&gt;</returns>
        public async Task<IDeleteClipFolderApiResponse> DeleteClipFolderAsync(Guid folderId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteClipFolder(ref folderId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clip-folders/{folderId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfolderId%7D", Uri.EscapeDataString(folderId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteClipFolderApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteClipFolderApiResponse>();

                        DeleteClipFolderApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clip-folders/{folderId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteClipFolderDefaultImplementation(apiResponseLocalVar, folderId);

                        Events.ExecuteOnDeleteClipFolder(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteClipFolderDefaultImplementation(e, "/clip-folders/{folderId}", uriBuilderLocalVar.Path, folderId);
                Events.ExecuteOnErrorDeleteClipFolder(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteClipFolderApiResponse"/>
        /// </summary>
        public partial class DeleteClipFolderApiResponse : Traq.Client.ApiResponse, IDeleteClipFolderApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteClipFolderApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteClipFolderApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteClipFolderApiResponse(ILogger<DeleteClipFolderApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditClipFolder(ref Guid folderId, Option<PatchClipFolderRequest> patchClipFolderRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="patchClipFolderRequest"></param>
        /// <returns></returns>
        private void ValidateEditClipFolder(Option<PatchClipFolderRequest> patchClipFolderRequest)
        {
            if (patchClipFolderRequest.IsSet && patchClipFolderRequest.Value == null)
                throw new ArgumentNullException(nameof(patchClipFolderRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="patchClipFolderRequest"></param>
        private void AfterEditClipFolderDefaultImplementation(IEditClipFolderApiResponse apiResponseLocalVar, Guid folderId, Option<PatchClipFolderRequest> patchClipFolderRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditClipFolder(ref suppressDefaultLog, apiResponseLocalVar, folderId, patchClipFolderRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="patchClipFolderRequest"></param>
        partial void AfterEditClipFolder(ref bool suppressDefaultLog, IEditClipFolderApiResponse apiResponseLocalVar, Guid folderId, Option<PatchClipFolderRequest> patchClipFolderRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="patchClipFolderRequest"></param>
        private void OnErrorEditClipFolderDefaultImplementation(Exception exception, string pathFormat, string path, Guid folderId, Option<PatchClipFolderRequest> patchClipFolderRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditClipFolder(ref suppressDefaultLog, exception, pathFormat, path, folderId, patchClipFolderRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="patchClipFolderRequest"></param>
        partial void OnErrorEditClipFolder(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid folderId, Option<PatchClipFolderRequest> patchClipFolderRequest);

        /// <summary>
        /// クリップフォルダ情報を編集 指定したクリップフォルダの情報を編集します。
        /// </summary>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="patchClipFolderRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditClipFolderApiResponse"/>&gt;</returns>
        public async Task<IEditClipFolderApiResponse?> EditClipFolderOrDefaultAsync(Guid folderId, Option<PatchClipFolderRequest> patchClipFolderRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditClipFolderAsync(folderId, patchClipFolderRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// クリップフォルダ情報を編集 指定したクリップフォルダの情報を編集します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="patchClipFolderRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditClipFolderApiResponse"/>&gt;</returns>
        public async Task<IEditClipFolderApiResponse> EditClipFolderAsync(Guid folderId, Option<PatchClipFolderRequest> patchClipFolderRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditClipFolder(patchClipFolderRequest);

                FormatEditClipFolder(ref folderId, patchClipFolderRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clip-folders/{folderId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfolderId%7D", Uri.EscapeDataString(folderId.ToString()));

                    if (patchClipFolderRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchClipFolderRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchClipFolderRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditClipFolderApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditClipFolderApiResponse>();

                        EditClipFolderApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clip-folders/{folderId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditClipFolderDefaultImplementation(apiResponseLocalVar, folderId, patchClipFolderRequest);

                        Events.ExecuteOnEditClipFolder(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditClipFolderDefaultImplementation(e, "/clip-folders/{folderId}", uriBuilderLocalVar.Path, folderId, patchClipFolderRequest);
                Events.ExecuteOnErrorEditClipFolder(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditClipFolderApiResponse"/>
        /// </summary>
        public partial class EditClipFolderApiResponse : Traq.Client.ApiResponse, IEditClipFolderApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditClipFolderApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditClipFolderApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditClipFolderApiResponse(ILogger<EditClipFolderApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetClipFolder(ref Guid folderId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        private void AfterGetClipFolderDefaultImplementation(IGetClipFolderApiResponse apiResponseLocalVar, Guid folderId)
        {
            bool suppressDefaultLog = false;
            AfterGetClipFolder(ref suppressDefaultLog, apiResponseLocalVar, folderId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        partial void AfterGetClipFolder(ref bool suppressDefaultLog, IGetClipFolderApiResponse apiResponseLocalVar, Guid folderId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        private void OnErrorGetClipFolderDefaultImplementation(Exception exception, string pathFormat, string path, Guid folderId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetClipFolder(ref suppressDefaultLog, exception, pathFormat, path, folderId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        partial void OnErrorGetClipFolder(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid folderId);

        /// <summary>
        /// クリップフォルダ情報を取得 指定したクリップフォルダの情報を取得します。
        /// </summary>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipFolderApiResponse"/>&gt;</returns>
        public async Task<IGetClipFolderApiResponse?> GetClipFolderOrDefaultAsync(Guid folderId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetClipFolderAsync(folderId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// クリップフォルダ情報を取得 指定したクリップフォルダの情報を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipFolderApiResponse"/>&gt;</returns>
        public async Task<IGetClipFolderApiResponse> GetClipFolderAsync(Guid folderId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetClipFolder(ref folderId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clip-folders/{folderId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfolderId%7D", Uri.EscapeDataString(folderId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetClipFolderApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetClipFolderApiResponse>();

                        GetClipFolderApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clip-folders/{folderId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetClipFolderDefaultImplementation(apiResponseLocalVar, folderId);

                        Events.ExecuteOnGetClipFolder(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetClipFolderDefaultImplementation(e, "/clip-folders/{folderId}", uriBuilderLocalVar.Path, folderId);
                Events.ExecuteOnErrorGetClipFolder(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetClipFolderApiResponse"/>
        /// </summary>
        public partial class GetClipFolderApiResponse : Traq.Client.ApiResponse, IGetClipFolderApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetClipFolderApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetClipFolderApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetClipFolderApiResponse(ILogger<GetClipFolderApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.ClipFolder? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.ClipFolder>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.ClipFolder? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetClipFoldersDefaultImplementation(IGetClipFoldersApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetClipFolders(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetClipFolders(ref bool suppressDefaultLog, IGetClipFoldersApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        private void OnErrorGetClipFoldersDefaultImplementation(Exception exception, string pathFormat, string path)
        {
            bool suppressDefaultLog = false;
            OnErrorGetClipFolders(ref suppressDefaultLog, exception, pathFormat, path);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        partial void OnErrorGetClipFolders(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path);

        /// <summary>
        /// クリップフォルダのリストを取得 自身が所有するクリップフォルダのリストを取得します。
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipFoldersApiResponse"/>&gt;</returns>
        public async Task<IGetClipFoldersApiResponse?> GetClipFoldersOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetClipFoldersAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// クリップフォルダのリストを取得 自身が所有するクリップフォルダのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipFoldersApiResponse"/>&gt;</returns>
        public async Task<IGetClipFoldersApiResponse> GetClipFoldersAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clip-folders";

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetClipFoldersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetClipFoldersApiResponse>();

                        GetClipFoldersApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clip-folders", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetClipFoldersDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetClipFolders(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetClipFoldersDefaultImplementation(e, "/clip-folders", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetClipFolders(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetClipFoldersApiResponse"/>
        /// </summary>
        public partial class GetClipFoldersApiResponse : Traq.Client.ApiResponse, IGetClipFoldersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetClipFoldersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetClipFoldersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetClipFoldersApiResponse(ILogger<GetClipFoldersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ClipFolder>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ClipFolder>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ClipFolder>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetClips(ref Guid folderId, ref Option<int> limit, ref Option<int> offset, ref Option<string> order);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="order"></param>
        /// <returns></returns>
        private void ValidateGetClips(Option<string> order)
        {
            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="order"></param>
        private void AfterGetClipsDefaultImplementation(IGetClipsApiResponse apiResponseLocalVar, Guid folderId, Option<int> limit, Option<int> offset, Option<string> order)
        {
            bool suppressDefaultLog = false;
            AfterGetClips(ref suppressDefaultLog, apiResponseLocalVar, folderId, limit, offset, order);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="order"></param>
        partial void AfterGetClips(ref bool suppressDefaultLog, IGetClipsApiResponse apiResponseLocalVar, Guid folderId, Option<int> limit, Option<int> offset, Option<string> order);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="order"></param>
        private void OnErrorGetClipsDefaultImplementation(Exception exception, string pathFormat, string path, Guid folderId, Option<int> limit, Option<int> offset, Option<string> order)
        {
            bool suppressDefaultLog = false;
            OnErrorGetClips(ref suppressDefaultLog, exception, pathFormat, path, folderId, limit, offset, order);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="order"></param>
        partial void OnErrorGetClips(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid folderId, Option<int> limit, Option<int> offset, Option<string> order);

        /// <summary>
        /// フォルダ内のクリップのリストを取得 指定したフォルダ内のクリップのリストを取得します。 &#x60;order&#x60;を指定しない場合、クリップした日時の新しい順で返されます。
        /// </summary>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipsApiResponse"/>&gt;</returns>
        public async Task<IGetClipsApiResponse?> GetClipsOrDefaultAsync(Guid folderId, Option<int> limit = default, Option<int> offset = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetClipsAsync(folderId, limit, offset, order, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// フォルダ内のクリップのリストを取得 指定したフォルダ内のクリップのリストを取得します。 &#x60;order&#x60;を指定しない場合、クリップした日時の新しい順で返されます。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClipsApiResponse"/>&gt;</returns>
        public async Task<IGetClipsApiResponse> GetClipsAsync(Guid folderId, Option<int> limit = default, Option<int> offset = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetClips(order);

                FormatGetClips(ref folderId, ref limit, ref offset, ref order);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clip-folders/{folderId}/messages";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfolderId%7D", Uri.EscapeDataString(folderId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetClipsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetClipsApiResponse>();

                        GetClipsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clip-folders/{folderId}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetClipsDefaultImplementation(apiResponseLocalVar, folderId, limit, offset, order);

                        Events.ExecuteOnGetClips(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetClipsDefaultImplementation(e, "/clip-folders/{folderId}/messages", uriBuilderLocalVar.Path, folderId, limit, offset, order);
                Events.ExecuteOnErrorGetClips(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetClipsApiResponse"/>
        /// </summary>
        public partial class GetClipsApiResponse : Traq.Client.ApiResponse, IGetClipsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetClipsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetClipsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetClipsApiResponse(ILogger<GetClipsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ClippedMessage>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ClippedMessage>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ClippedMessage>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMessageClips(ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterGetMessageClipsDefaultImplementation(IGetMessageClipsApiResponse apiResponseLocalVar, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterGetMessageClips(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterGetMessageClips(ref bool suppressDefaultLog, IGetMessageClipsApiResponse apiResponseLocalVar, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        private void OnErrorGetMessageClipsDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMessageClips(ref suppressDefaultLog, exception, pathFormat, path, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        partial void OnErrorGetMessageClips(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId);

        /// <summary>
        /// 自分のクリップを取得 対象のメッセージの自分のクリップの一覧を返します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageClipsApiResponse"/>&gt;</returns>
        public async Task<IGetMessageClipsApiResponse?> GetMessageClipsOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMessageClipsAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 自分のクリップを取得 対象のメッセージの自分のクリップの一覧を返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageClipsApiResponse"/>&gt;</returns>
        public async Task<IGetMessageClipsApiResponse> GetMessageClipsAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetMessageClips(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/clips";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMessageClipsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMessageClipsApiResponse>();

                        GetMessageClipsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/clips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMessageClipsDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnGetMessageClips(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMessageClipsDefaultImplementation(e, "/messages/{messageId}/clips", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorGetMessageClips(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMessageClipsApiResponse"/>
        /// </summary>
        public partial class GetMessageClipsApiResponse : Traq.Client.ApiResponse, IGetMessageClipsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMessageClipsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMessageClipsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessageClipsApiResponse(ILogger<GetMessageClipsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MessageClip>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MessageClip>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MessageClip>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUnclipMessage(ref Guid folderId, ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="messageId"></param>
        private void AfterUnclipMessageDefaultImplementation(IUnclipMessageApiResponse apiResponseLocalVar, Guid folderId, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterUnclipMessage(ref suppressDefaultLog, apiResponseLocalVar, folderId, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="folderId"></param>
        /// <param name="messageId"></param>
        partial void AfterUnclipMessage(ref bool suppressDefaultLog, IUnclipMessageApiResponse apiResponseLocalVar, Guid folderId, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="messageId"></param>
        private void OnErrorUnclipMessageDefaultImplementation(Exception exception, string pathFormat, string path, Guid folderId, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorUnclipMessage(ref suppressDefaultLog, exception, pathFormat, path, folderId, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="folderId"></param>
        /// <param name="messageId"></param>
        partial void OnErrorUnclipMessage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid folderId, Guid messageId);

        /// <summary>
        /// メッセージをクリップフォルダから除外 指定したフォルダから指定したメッセージのクリップを除外します。 既に外されているメッセージを指定した場合は204を返します。
        /// </summary>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnclipMessageApiResponse"/>&gt;</returns>
        public async Task<IUnclipMessageApiResponse?> UnclipMessageOrDefaultAsync(Guid folderId, Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UnclipMessageAsync(folderId, messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// メッセージをクリップフォルダから除外 指定したフォルダから指定したメッセージのクリップを除外します。 既に外されているメッセージを指定した場合は204を返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="folderId">クリップフォルダUUID</param>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnclipMessageApiResponse"/>&gt;</returns>
        public async Task<IUnclipMessageApiResponse> UnclipMessageAsync(Guid folderId, Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatUnclipMessage(ref folderId, ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clip-folders/{folderId}/messages/{messageId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BfolderId%7D", Uri.EscapeDataString(folderId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UnclipMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UnclipMessageApiResponse>();

                        UnclipMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clip-folders/{folderId}/messages/{messageId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUnclipMessageDefaultImplementation(apiResponseLocalVar, folderId, messageId);

                        Events.ExecuteOnUnclipMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUnclipMessageDefaultImplementation(e, "/clip-folders/{folderId}/messages/{messageId}", uriBuilderLocalVar.Path, folderId, messageId);
                Events.ExecuteOnErrorUnclipMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UnclipMessageApiResponse"/>
        /// </summary>
        public partial class UnclipMessageApiResponse : Traq.Client.ApiResponse, IUnclipMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UnclipMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UnclipMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UnclipMessageApiResponse(ILogger<UnclipMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
