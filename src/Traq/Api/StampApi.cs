// <auto-generated>
/*
 * traQ v3
 *
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Traq.Client;
using Traq.Model;
using System.Diagnostics.CodeAnalysis;

namespace Traq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IStampApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        StampApiEvents Events { get; }

        /// <summary>
        /// スタンプを押す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージに指定したスタンプを押します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="postMessageStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMessageStampApiResponse"/>&gt;</returns>
        Task<IAddMessageStampApiResponse> AddMessageStampAsync(Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを押す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージに指定したスタンプを押します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="postMessageStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMessageStampApiResponse"/>?&gt;</returns>
        Task<IAddMessageStampApiResponse?> AddMessageStampOrDefaultAsync(Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ画像を変更
        /// </summary>
        /// <remarks>
        /// 指定したスタンプの画像を変更します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="file">スタンプ画像(1MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeStampImageApiResponse"/>&gt;</returns>
        Task<IChangeStampImageApiResponse> ChangeStampImageAsync(Guid stampId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ画像を変更
        /// </summary>
        /// <remarks>
        /// 指定したスタンプの画像を変更します。
        /// </remarks>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="file">スタンプ画像(1MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeStampImageApiResponse"/>?&gt;</returns>
        Task<IChangeStampImageApiResponse?> ChangeStampImageOrDefaultAsync(Guid stampId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを作成
        /// </summary>
        /// <remarks>
        /// スタンプを新規作成します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">スタンプ名</param>
        /// <param name="file">スタンプ画像(1MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateStampApiResponse"/>&gt;</returns>
        Task<ICreateStampApiResponse> CreateStampAsync(string name, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを作成
        /// </summary>
        /// <remarks>
        /// スタンプを新規作成します。
        /// </remarks>
        /// <param name="name">スタンプ名</param>
        /// <param name="file">スタンプ画像(1MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateStampApiResponse"/>?&gt;</returns>
        Task<ICreateStampApiResponse?> CreateStampOrDefaultAsync(string name, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットを作成
        /// </summary>
        /// <remarks>
        /// スタンプパレットを作成します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postStampPaletteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateStampPaletteApiResponse"/>&gt;</returns>
        Task<ICreateStampPaletteApiResponse> CreateStampPaletteAsync(Option<PostStampPaletteRequest> postStampPaletteRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットを作成
        /// </summary>
        /// <remarks>
        /// スタンプパレットを作成します。
        /// </remarks>
        /// <param name="postStampPaletteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateStampPaletteApiResponse"/>?&gt;</returns>
        Task<ICreateStampPaletteApiResponse?> CreateStampPaletteOrDefaultAsync(Option<PostStampPaletteRequest> postStampPaletteRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを削除
        /// </summary>
        /// <remarks>
        /// 指定したスタンプを削除します。 対象のスタンプの削除権限が必要です。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteStampApiResponse"/>&gt;</returns>
        Task<IDeleteStampApiResponse> DeleteStampAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを削除
        /// </summary>
        /// <remarks>
        /// 指定したスタンプを削除します。 対象のスタンプの削除権限が必要です。
        /// </remarks>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteStampApiResponse"/>?&gt;</returns>
        Task<IDeleteStampApiResponse?> DeleteStampOrDefaultAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットを削除
        /// </summary>
        /// <remarks>
        /// 指定したスタンプパレットを削除します。 対象のスタンプパレットの管理権限が必要です。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteStampPaletteApiResponse"/>&gt;</returns>
        Task<IDeleteStampPaletteApiResponse> DeleteStampPaletteAsync(Guid paletteId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットを削除
        /// </summary>
        /// <remarks>
        /// 指定したスタンプパレットを削除します。 対象のスタンプパレットの管理権限が必要です。
        /// </remarks>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteStampPaletteApiResponse"/>?&gt;</returns>
        Task<IDeleteStampPaletteApiResponse?> DeleteStampPaletteOrDefaultAsync(Guid paletteId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ情報を変更
        /// </summary>
        /// <remarks>
        /// 指定したスタンプの情報を変更します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="patchStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditStampApiResponse"/>&gt;</returns>
        Task<IEditStampApiResponse> EditStampAsync(Guid stampId, Option<PatchStampRequest> patchStampRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ情報を変更
        /// </summary>
        /// <remarks>
        /// 指定したスタンプの情報を変更します。
        /// </remarks>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="patchStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditStampApiResponse"/>?&gt;</returns>
        Task<IEditStampApiResponse?> EditStampOrDefaultAsync(Guid stampId, Option<PatchStampRequest> patchStampRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットを編集
        /// </summary>
        /// <remarks>
        /// 指定したスタンプパレットを編集します。 リクエストのスタンプの配列の順番は保存されて変更されます。 対象のスタンプパレットの管理権限が必要です。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="patchStampPaletteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditStampPaletteApiResponse"/>&gt;</returns>
        Task<IEditStampPaletteApiResponse> EditStampPaletteAsync(Guid paletteId, Option<PatchStampPaletteRequest> patchStampPaletteRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットを編集
        /// </summary>
        /// <remarks>
        /// 指定したスタンプパレットを編集します。 リクエストのスタンプの配列の順番は保存されて変更されます。 対象のスタンプパレットの管理権限が必要です。
        /// </remarks>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="patchStampPaletteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditStampPaletteApiResponse"/>?&gt;</returns>
        Task<IEditStampPaletteApiResponse?> EditStampPaletteOrDefaultAsync(Guid paletteId, Option<PatchStampPaletteRequest> patchStampPaletteRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージのスタンプリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したメッセージに押されているスタンプのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageStampsApiResponse"/>&gt;</returns>
        Task<IGetMessageStampsApiResponse> GetMessageStampsAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージのスタンプリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したメッセージに押されているスタンプのリストを取得します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageStampsApiResponse"/>?&gt;</returns>
        Task<IGetMessageStampsApiResponse?> GetMessageStampsOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ履歴を取得
        /// </summary>
        /// <remarks>
        /// 自分のスタンプ履歴を最大100件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">件数 (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyStampHistoryApiResponse"/>&gt;</returns>
        Task<IGetMyStampHistoryApiResponse> GetMyStampHistoryAsync(Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ履歴を取得
        /// </summary>
        /// <remarks>
        /// 自分のスタンプ履歴を最大100件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
        /// </remarks>
        /// <param name="limit">件数 (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyStampHistoryApiResponse"/>?&gt;</returns>
        Task<IGetMyStampHistoryApiResponse?> GetMyStampHistoryOrDefaultAsync(Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したスタンプの情報を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampApiResponse"/>&gt;</returns>
        Task<IGetStampApiResponse> GetStampAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したスタンプの情報を取得します。
        /// </remarks>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampApiResponse"/>?&gt;</returns>
        Task<IGetStampApiResponse?> GetStampOrDefaultAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ画像を取得
        /// </summary>
        /// <remarks>
        /// 指定したIDのスタンプ画像を返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampImageApiResponse"/>&gt;</returns>
        Task<IGetStampImageApiResponse> GetStampImageAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ画像を取得
        /// </summary>
        /// <remarks>
        /// 指定したIDのスタンプ画像を返します。
        /// </remarks>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampImageApiResponse"/>?&gt;</returns>
        Task<IGetStampImageApiResponse?> GetStampImageOrDefaultAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットを取得
        /// </summary>
        /// <remarks>
        /// 指定したスタンプパレットの情報を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampPaletteApiResponse"/>&gt;</returns>
        Task<IGetStampPaletteApiResponse> GetStampPaletteAsync(Guid paletteId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットを取得
        /// </summary>
        /// <remarks>
        /// 指定したスタンプパレットの情報を取得します。
        /// </remarks>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampPaletteApiResponse"/>?&gt;</returns>
        Task<IGetStampPaletteApiResponse?> GetStampPaletteOrDefaultAsync(Guid paletteId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットのリストを取得
        /// </summary>
        /// <remarks>
        /// 自身が所有しているスタンプパレットのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampPalettesApiResponse"/>&gt;</returns>
        Task<IGetStampPalettesApiResponse> GetStampPalettesAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプパレットのリストを取得
        /// </summary>
        /// <remarks>
        /// 自身が所有しているスタンプパレットのリストを取得します。
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampPalettesApiResponse"/>?&gt;</returns>
        Task<IGetStampPalettesApiResponse?> GetStampPalettesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ統計情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したスタンプの統計情報を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampStatsApiResponse"/>&gt;</returns>
        Task<IGetStampStatsApiResponse> GetStampStatsAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプ統計情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したスタンプの統計情報を取得します。
        /// </remarks>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampStatsApiResponse"/>?&gt;</returns>
        Task<IGetStampStatsApiResponse?> GetStampStatsOrDefaultAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプリストを取得
        /// </summary>
        /// <remarks>
        /// スタンプのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeUnicode">Unicode絵文字を含ませるかどうか Deprecated: typeクエリを指定しなければ全てのスタンプを取得できるため、そちらを利用してください  (optional, default to true) (deprecated)</param>
        /// <param name="type">取得するスタンプの種類 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampsApiResponse"/>&gt;</returns>
        Task<IGetStampsApiResponse> GetStampsAsync(Option<bool> includeUnicode = default, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプリストを取得
        /// </summary>
        /// <remarks>
        /// スタンプのリストを取得します。
        /// </remarks>
        /// <param name="includeUnicode">Unicode絵文字を含ませるかどうか Deprecated: typeクエリを指定しなければ全てのスタンプを取得できるため、そちらを利用してください  (optional, default to true) (deprecated)</param>
        /// <param name="type">取得するスタンプの種類 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampsApiResponse"/>?&gt;</returns>
        Task<IGetStampsApiResponse?> GetStampsOrDefaultAsync(Option<bool> includeUnicode = default, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを消す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージから指定した自身が押したスタンプを削除します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMessageStampApiResponse"/>&gt;</returns>
        Task<IRemoveMessageStampApiResponse> RemoveMessageStampAsync(Guid messageId, Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを消す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージから指定した自身が押したスタンプを削除します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMessageStampApiResponse"/>?&gt;</returns>
        Task<IRemoveMessageStampApiResponse?> RemoveMessageStampOrDefaultAsync(Guid messageId, Guid stampId, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddMessageStampApiResponse"/>
    /// </summary>
    public interface IAddMessageStampApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IChangeStampImageApiResponse"/>
    /// </summary>
    public interface IChangeStampImageApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 413 ContentTooLarge
        /// </summary>
        /// <returns></returns>
        bool IsContentTooLarge { get; }
    }

    /// <summary>
    /// The <see cref="ICreateStampApiResponse"/>
    /// </summary>
    public interface ICreateStampApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.Stamp?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is 413 ContentTooLarge
        /// </summary>
        /// <returns></returns>
        bool IsContentTooLarge { get; }
    }

    /// <summary>
    /// The <see cref="ICreateStampPaletteApiResponse"/>
    /// </summary>
    public interface ICreateStampPaletteApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.StampPalette?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteStampApiResponse"/>
    /// </summary>
    public interface IDeleteStampApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteStampPaletteApiResponse"/>
    /// </summary>
    public interface IDeleteStampPaletteApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IEditStampApiResponse"/>
    /// </summary>
    public interface IEditStampApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }
    }

    /// <summary>
    /// The <see cref="IEditStampPaletteApiResponse"/>
    /// </summary>
    public interface IEditStampPaletteApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetMessageStampsApiResponse"/>
    /// </summary>
    public interface IGetMessageStampsApiResponse : Traq.Client.IApiResponse, IOk<List<MessageStamp>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetMyStampHistoryApiResponse"/>
    /// </summary>
    public interface IGetMyStampHistoryApiResponse : Traq.Client.IApiResponse, IOk<List<StampHistoryEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetStampApiResponse"/>
    /// </summary>
    public interface IGetStampApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.Stamp?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetStampImageApiResponse"/>
    /// </summary>
    public interface IGetStampImageApiResponse : Traq.Client.IApiResponse, IOk<System.IO.Stream?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetStampPaletteApiResponse"/>
    /// </summary>
    public interface IGetStampPaletteApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.StampPalette?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetStampPalettesApiResponse"/>
    /// </summary>
    public interface IGetStampPalettesApiResponse : Traq.Client.IApiResponse, IOk<List<StampPalette>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetStampStatsApiResponse"/>
    /// </summary>
    public interface IGetStampStatsApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.StampStats?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetStampsApiResponse"/>
    /// </summary>
    public interface IGetStampsApiResponse : Traq.Client.IApiResponse, IOk<List<StampWithThumbnail>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveMessageStampApiResponse"/>
    /// </summary>
    public interface IRemoveMessageStampApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class StampApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddMessageStamp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddMessageStamp;

        internal void ExecuteOnAddMessageStamp(StampApi.AddMessageStampApiResponse apiResponse)
        {
            OnAddMessageStamp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddMessageStamp(Exception exception)
        {
            OnErrorAddMessageStamp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeStampImage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeStampImage;

        internal void ExecuteOnChangeStampImage(StampApi.ChangeStampImageApiResponse apiResponse)
        {
            OnChangeStampImage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeStampImage(Exception exception)
        {
            OnErrorChangeStampImage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateStamp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateStamp;

        internal void ExecuteOnCreateStamp(StampApi.CreateStampApiResponse apiResponse)
        {
            OnCreateStamp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateStamp(Exception exception)
        {
            OnErrorCreateStamp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateStampPalette;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateStampPalette;

        internal void ExecuteOnCreateStampPalette(StampApi.CreateStampPaletteApiResponse apiResponse)
        {
            OnCreateStampPalette?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateStampPalette(Exception exception)
        {
            OnErrorCreateStampPalette?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteStamp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteStamp;

        internal void ExecuteOnDeleteStamp(StampApi.DeleteStampApiResponse apiResponse)
        {
            OnDeleteStamp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteStamp(Exception exception)
        {
            OnErrorDeleteStamp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteStampPalette;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteStampPalette;

        internal void ExecuteOnDeleteStampPalette(StampApi.DeleteStampPaletteApiResponse apiResponse)
        {
            OnDeleteStampPalette?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteStampPalette(Exception exception)
        {
            OnErrorDeleteStampPalette?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditStamp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditStamp;

        internal void ExecuteOnEditStamp(StampApi.EditStampApiResponse apiResponse)
        {
            OnEditStamp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditStamp(Exception exception)
        {
            OnErrorEditStamp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditStampPalette;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditStampPalette;

        internal void ExecuteOnEditStampPalette(StampApi.EditStampPaletteApiResponse apiResponse)
        {
            OnEditStampPalette?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditStampPalette(Exception exception)
        {
            OnErrorEditStampPalette?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMessageStamps;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMessageStamps;

        internal void ExecuteOnGetMessageStamps(StampApi.GetMessageStampsApiResponse apiResponse)
        {
            OnGetMessageStamps?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMessageStamps(Exception exception)
        {
            OnErrorGetMessageStamps?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMyStampHistory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMyStampHistory;

        internal void ExecuteOnGetMyStampHistory(StampApi.GetMyStampHistoryApiResponse apiResponse)
        {
            OnGetMyStampHistory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMyStampHistory(Exception exception)
        {
            OnErrorGetMyStampHistory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetStamp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetStamp;

        internal void ExecuteOnGetStamp(StampApi.GetStampApiResponse apiResponse)
        {
            OnGetStamp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetStamp(Exception exception)
        {
            OnErrorGetStamp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetStampImage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetStampImage;

        internal void ExecuteOnGetStampImage(StampApi.GetStampImageApiResponse apiResponse)
        {
            OnGetStampImage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetStampImage(Exception exception)
        {
            OnErrorGetStampImage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetStampPalette;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetStampPalette;

        internal void ExecuteOnGetStampPalette(StampApi.GetStampPaletteApiResponse apiResponse)
        {
            OnGetStampPalette?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetStampPalette(Exception exception)
        {
            OnErrorGetStampPalette?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetStampPalettes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetStampPalettes;

        internal void ExecuteOnGetStampPalettes(StampApi.GetStampPalettesApiResponse apiResponse)
        {
            OnGetStampPalettes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetStampPalettes(Exception exception)
        {
            OnErrorGetStampPalettes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetStampStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetStampStats;

        internal void ExecuteOnGetStampStats(StampApi.GetStampStatsApiResponse apiResponse)
        {
            OnGetStampStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetStampStats(Exception exception)
        {
            OnErrorGetStampStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetStamps;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetStamps;

        internal void ExecuteOnGetStamps(StampApi.GetStampsApiResponse apiResponse)
        {
            OnGetStamps?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetStamps(Exception exception)
        {
            OnErrorGetStamps?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveMessageStamp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveMessageStamp;

        internal void ExecuteOnRemoveMessageStamp(StampApi.RemoveMessageStampApiResponse apiResponse)
        {
            OnRemoveMessageStamp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveMessageStamp(Exception exception)
        {
            OnErrorRemoveMessageStamp?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class StampApi : IStampApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<StampApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public StampApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="StampApi"/> class.
        /// </summary>
        /// <returns></returns>
        public StampApi(ILogger<StampApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, StampApiEvents stampApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<StampApi>();
            HttpClient = httpClient;
            Events = stampApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatAddMessageStamp(ref Guid messageId, ref Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postMessageStampRequest"></param>
        /// <returns></returns>
        private void ValidateAddMessageStamp(Option<PostMessageStampRequest> postMessageStampRequest)
        {
            if (postMessageStampRequest.IsSet && postMessageStampRequest.Value == null)
                throw new ArgumentNullException(nameof(postMessageStampRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        /// <param name="postMessageStampRequest"></param>
        private void AfterAddMessageStampDefaultImplementation(IAddMessageStampApiResponse apiResponseLocalVar, Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest)
        {
            bool suppressDefaultLog = false;
            AfterAddMessageStamp(ref suppressDefaultLog, apiResponseLocalVar, messageId, stampId, postMessageStampRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        /// <param name="postMessageStampRequest"></param>
        partial void AfterAddMessageStamp(ref bool suppressDefaultLog, IAddMessageStampApiResponse apiResponseLocalVar, Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        /// <param name="postMessageStampRequest"></param>
        private void OnErrorAddMessageStampDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorAddMessageStamp(ref suppressDefaultLog, exception, pathFormat, path, messageId, stampId, postMessageStampRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        /// <param name="postMessageStampRequest"></param>
        partial void OnErrorAddMessageStamp(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest);

        /// <summary>
        /// スタンプを押す 指定したメッセージに指定したスタンプを押します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="postMessageStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMessageStampApiResponse"/>&gt;</returns>
        public async Task<IAddMessageStampApiResponse?> AddMessageStampOrDefaultAsync(Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddMessageStampAsync(messageId, stampId, postMessageStampRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプを押す 指定したメッセージに指定したスタンプを押します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="postMessageStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMessageStampApiResponse"/>&gt;</returns>
        public async Task<IAddMessageStampApiResponse> AddMessageStampAsync(Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddMessageStamp(postMessageStampRequest);

                FormatAddMessageStamp(ref messageId, ref stampId, postMessageStampRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/stamps/{stampId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    if (postMessageStampRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postMessageStampRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postMessageStampRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AddMessageStampApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddMessageStampApiResponse>();

                        AddMessageStampApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/stamps/{stampId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddMessageStampDefaultImplementation(apiResponseLocalVar, messageId, stampId, postMessageStampRequest);

                        Events.ExecuteOnAddMessageStamp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddMessageStampDefaultImplementation(e, "/messages/{messageId}/stamps/{stampId}", uriBuilderLocalVar.Path, messageId, stampId, postMessageStampRequest);
                Events.ExecuteOnErrorAddMessageStamp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddMessageStampApiResponse"/>
        /// </summary>
        public partial class AddMessageStampApiResponse : Traq.Client.ApiResponse, IAddMessageStampApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddMessageStampApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddMessageStampApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddMessageStampApiResponse(ILogger<AddMessageStampApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeStampImage(ref Guid stampId, ref System.IO.Stream file);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="file"></param>
        /// <returns></returns>
        private void ValidateChangeStampImage(System.IO.Stream file)
        {
            if (file == null)
                throw new ArgumentNullException(nameof(file));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        /// <param name="file"></param>
        private void AfterChangeStampImageDefaultImplementation(IChangeStampImageApiResponse apiResponseLocalVar, Guid stampId, System.IO.Stream file)
        {
            bool suppressDefaultLog = false;
            AfterChangeStampImage(ref suppressDefaultLog, apiResponseLocalVar, stampId, file);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        /// <param name="file"></param>
        partial void AfterChangeStampImage(ref bool suppressDefaultLog, IChangeStampImageApiResponse apiResponseLocalVar, Guid stampId, System.IO.Stream file);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        /// <param name="file"></param>
        private void OnErrorChangeStampImageDefaultImplementation(Exception exception, string pathFormat, string path, Guid stampId, System.IO.Stream file)
        {
            bool suppressDefaultLog = false;
            OnErrorChangeStampImage(ref suppressDefaultLog, exception, pathFormat, path, stampId, file);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        /// <param name="file"></param>
        partial void OnErrorChangeStampImage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid stampId, System.IO.Stream file);

        /// <summary>
        /// スタンプ画像を変更 指定したスタンプの画像を変更します。
        /// </summary>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="file">スタンプ画像(1MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeStampImageApiResponse"/>&gt;</returns>
        public async Task<IChangeStampImageApiResponse?> ChangeStampImageOrDefaultAsync(Guid stampId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeStampImageAsync(stampId, file, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプ画像を変更 指定したスタンプの画像を変更します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="file">スタンプ画像(1MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeStampImageApiResponse"/>&gt;</returns>
        public async Task<IChangeStampImageApiResponse> ChangeStampImageAsync(Guid stampId, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeStampImage(file);

                FormatChangeStampImage(ref stampId, ref file);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamps/{stampId}/image";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));                    multipartContentLocalVar.Add(new StreamContent(file));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "multipart/form-data"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeStampImageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeStampImageApiResponse>();

                        ChangeStampImageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamps/{stampId}/image", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeStampImageDefaultImplementation(apiResponseLocalVar, stampId, file);

                        Events.ExecuteOnChangeStampImage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeStampImageDefaultImplementation(e, "/stamps/{stampId}/image", uriBuilderLocalVar.Path, stampId, file);
                Events.ExecuteOnErrorChangeStampImage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeStampImageApiResponse"/>
        /// </summary>
        public partial class ChangeStampImageApiResponse : Traq.Client.ApiResponse, IChangeStampImageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeStampImageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeStampImageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeStampImageApiResponse(ILogger<ChangeStampImageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 413 ContentTooLarge
            /// </summary>
            /// <returns></returns>
            public bool IsContentTooLarge => 413 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateStamp(ref string name, ref System.IO.Stream file);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <param name="file"></param>
        /// <returns></returns>
        private void ValidateCreateStamp(string name, System.IO.Stream file)
        {
            if (name == null)
                throw new ArgumentNullException(nameof(name));

            if (file == null)
                throw new ArgumentNullException(nameof(file));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="file"></param>
        private void AfterCreateStampDefaultImplementation(ICreateStampApiResponse apiResponseLocalVar, string name, System.IO.Stream file)
        {
            bool suppressDefaultLog = false;
            AfterCreateStamp(ref suppressDefaultLog, apiResponseLocalVar, name, file);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="file"></param>
        partial void AfterCreateStamp(ref bool suppressDefaultLog, ICreateStampApiResponse apiResponseLocalVar, string name, System.IO.Stream file);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="name"></param>
        /// <param name="file"></param>
        private void OnErrorCreateStampDefaultImplementation(Exception exception, string pathFormat, string path, string name, System.IO.Stream file)
        {
            bool suppressDefaultLog = false;
            OnErrorCreateStamp(ref suppressDefaultLog, exception, pathFormat, path, name, file);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="name"></param>
        /// <param name="file"></param>
        partial void OnErrorCreateStamp(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string name, System.IO.Stream file);

        /// <summary>
        /// スタンプを作成 スタンプを新規作成します。
        /// </summary>
        /// <param name="name">スタンプ名</param>
        /// <param name="file">スタンプ画像(1MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateStampApiResponse"/>&gt;</returns>
        public async Task<ICreateStampApiResponse?> CreateStampOrDefaultAsync(string name, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateStampAsync(name, file, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプを作成 スタンプを新規作成します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">スタンプ名</param>
        /// <param name="file">スタンプ画像(1MBまでのpng, jpeg, gif)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateStampApiResponse"/>&gt;</returns>
        public async Task<ICreateStampApiResponse> CreateStampAsync(string name, System.IO.Stream file, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateStamp(name, file);

                FormatCreateStamp(ref name, ref file);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamps";

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));

                    formParameterLocalVars.Add(new KeyValuePair<string?, string?>("name", ClientUtils.ParameterToString(name)));

                    multipartContentLocalVar.Add(new StreamContent(file));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "multipart/form-data"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateStampApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateStampApiResponse>();

                        CreateStampApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamps", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateStampDefaultImplementation(apiResponseLocalVar, name, file);

                        Events.ExecuteOnCreateStamp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateStampDefaultImplementation(e, "/stamps", uriBuilderLocalVar.Path, name, file);
                Events.ExecuteOnErrorCreateStamp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateStampApiResponse"/>
        /// </summary>
        public partial class CreateStampApiResponse : Traq.Client.ApiResponse, ICreateStampApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateStampApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateStampApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateStampApiResponse(ILogger<CreateStampApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.Stamp? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.Stamp>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.Stamp? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 413 ContentTooLarge
            /// </summary>
            /// <returns></returns>
            public bool IsContentTooLarge => 413 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateStampPalette(Option<PostStampPaletteRequest> postStampPaletteRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postStampPaletteRequest"></param>
        /// <returns></returns>
        private void ValidateCreateStampPalette(Option<PostStampPaletteRequest> postStampPaletteRequest)
        {
            if (postStampPaletteRequest.IsSet && postStampPaletteRequest.Value == null)
                throw new ArgumentNullException(nameof(postStampPaletteRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postStampPaletteRequest"></param>
        private void AfterCreateStampPaletteDefaultImplementation(ICreateStampPaletteApiResponse apiResponseLocalVar, Option<PostStampPaletteRequest> postStampPaletteRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateStampPalette(ref suppressDefaultLog, apiResponseLocalVar, postStampPaletteRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postStampPaletteRequest"></param>
        partial void AfterCreateStampPalette(ref bool suppressDefaultLog, ICreateStampPaletteApiResponse apiResponseLocalVar, Option<PostStampPaletteRequest> postStampPaletteRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postStampPaletteRequest"></param>
        private void OnErrorCreateStampPaletteDefaultImplementation(Exception exception, string pathFormat, string path, Option<PostStampPaletteRequest> postStampPaletteRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorCreateStampPalette(ref suppressDefaultLog, exception, pathFormat, path, postStampPaletteRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postStampPaletteRequest"></param>
        partial void OnErrorCreateStampPalette(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<PostStampPaletteRequest> postStampPaletteRequest);

        /// <summary>
        /// スタンプパレットを作成 スタンプパレットを作成します。
        /// </summary>
        /// <param name="postStampPaletteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateStampPaletteApiResponse"/>&gt;</returns>
        public async Task<ICreateStampPaletteApiResponse?> CreateStampPaletteOrDefaultAsync(Option<PostStampPaletteRequest> postStampPaletteRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateStampPaletteAsync(postStampPaletteRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプパレットを作成 スタンプパレットを作成します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postStampPaletteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateStampPaletteApiResponse"/>&gt;</returns>
        public async Task<ICreateStampPaletteApiResponse> CreateStampPaletteAsync(Option<PostStampPaletteRequest> postStampPaletteRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateStampPalette(postStampPaletteRequest);

                FormatCreateStampPalette(postStampPaletteRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamp-palettes";

                    if (postStampPaletteRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postStampPaletteRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postStampPaletteRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateStampPaletteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateStampPaletteApiResponse>();

                        CreateStampPaletteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamp-palettes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateStampPaletteDefaultImplementation(apiResponseLocalVar, postStampPaletteRequest);

                        Events.ExecuteOnCreateStampPalette(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateStampPaletteDefaultImplementation(e, "/stamp-palettes", uriBuilderLocalVar.Path, postStampPaletteRequest);
                Events.ExecuteOnErrorCreateStampPalette(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateStampPaletteApiResponse"/>
        /// </summary>
        public partial class CreateStampPaletteApiResponse : Traq.Client.ApiResponse, ICreateStampPaletteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateStampPaletteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateStampPaletteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateStampPaletteApiResponse(ILogger<CreateStampPaletteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.StampPalette? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.StampPalette>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.StampPalette? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteStamp(ref Guid stampId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        private void AfterDeleteStampDefaultImplementation(IDeleteStampApiResponse apiResponseLocalVar, Guid stampId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteStamp(ref suppressDefaultLog, apiResponseLocalVar, stampId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        partial void AfterDeleteStamp(ref bool suppressDefaultLog, IDeleteStampApiResponse apiResponseLocalVar, Guid stampId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        private void OnErrorDeleteStampDefaultImplementation(Exception exception, string pathFormat, string path, Guid stampId)
        {
            bool suppressDefaultLog = false;
            OnErrorDeleteStamp(ref suppressDefaultLog, exception, pathFormat, path, stampId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        partial void OnErrorDeleteStamp(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid stampId);

        /// <summary>
        /// スタンプを削除 指定したスタンプを削除します。 対象のスタンプの削除権限が必要です。
        /// </summary>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteStampApiResponse"/>&gt;</returns>
        public async Task<IDeleteStampApiResponse?> DeleteStampOrDefaultAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteStampAsync(stampId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプを削除 指定したスタンプを削除します。 対象のスタンプの削除権限が必要です。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteStampApiResponse"/>&gt;</returns>
        public async Task<IDeleteStampApiResponse> DeleteStampAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteStamp(ref stampId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamps/{stampId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteStampApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteStampApiResponse>();

                        DeleteStampApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamps/{stampId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteStampDefaultImplementation(apiResponseLocalVar, stampId);

                        Events.ExecuteOnDeleteStamp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteStampDefaultImplementation(e, "/stamps/{stampId}", uriBuilderLocalVar.Path, stampId);
                Events.ExecuteOnErrorDeleteStamp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteStampApiResponse"/>
        /// </summary>
        public partial class DeleteStampApiResponse : Traq.Client.ApiResponse, IDeleteStampApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteStampApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteStampApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteStampApiResponse(ILogger<DeleteStampApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteStampPalette(ref Guid paletteId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="paletteId"></param>
        private void AfterDeleteStampPaletteDefaultImplementation(IDeleteStampPaletteApiResponse apiResponseLocalVar, Guid paletteId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteStampPalette(ref suppressDefaultLog, apiResponseLocalVar, paletteId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="paletteId"></param>
        partial void AfterDeleteStampPalette(ref bool suppressDefaultLog, IDeleteStampPaletteApiResponse apiResponseLocalVar, Guid paletteId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="paletteId"></param>
        private void OnErrorDeleteStampPaletteDefaultImplementation(Exception exception, string pathFormat, string path, Guid paletteId)
        {
            bool suppressDefaultLog = false;
            OnErrorDeleteStampPalette(ref suppressDefaultLog, exception, pathFormat, path, paletteId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="paletteId"></param>
        partial void OnErrorDeleteStampPalette(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid paletteId);

        /// <summary>
        /// スタンプパレットを削除 指定したスタンプパレットを削除します。 対象のスタンプパレットの管理権限が必要です。
        /// </summary>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteStampPaletteApiResponse"/>&gt;</returns>
        public async Task<IDeleteStampPaletteApiResponse?> DeleteStampPaletteOrDefaultAsync(Guid paletteId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteStampPaletteAsync(paletteId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプパレットを削除 指定したスタンプパレットを削除します。 対象のスタンプパレットの管理権限が必要です。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteStampPaletteApiResponse"/>&gt;</returns>
        public async Task<IDeleteStampPaletteApiResponse> DeleteStampPaletteAsync(Guid paletteId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteStampPalette(ref paletteId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamp-palettes/{paletteId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BpaletteId%7D", Uri.EscapeDataString(paletteId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteStampPaletteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteStampPaletteApiResponse>();

                        DeleteStampPaletteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamp-palettes/{paletteId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteStampPaletteDefaultImplementation(apiResponseLocalVar, paletteId);

                        Events.ExecuteOnDeleteStampPalette(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteStampPaletteDefaultImplementation(e, "/stamp-palettes/{paletteId}", uriBuilderLocalVar.Path, paletteId);
                Events.ExecuteOnErrorDeleteStampPalette(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteStampPaletteApiResponse"/>
        /// </summary>
        public partial class DeleteStampPaletteApiResponse : Traq.Client.ApiResponse, IDeleteStampPaletteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteStampPaletteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteStampPaletteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteStampPaletteApiResponse(ILogger<DeleteStampPaletteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditStamp(ref Guid stampId, Option<PatchStampRequest> patchStampRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="patchStampRequest"></param>
        /// <returns></returns>
        private void ValidateEditStamp(Option<PatchStampRequest> patchStampRequest)
        {
            if (patchStampRequest.IsSet && patchStampRequest.Value == null)
                throw new ArgumentNullException(nameof(patchStampRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        /// <param name="patchStampRequest"></param>
        private void AfterEditStampDefaultImplementation(IEditStampApiResponse apiResponseLocalVar, Guid stampId, Option<PatchStampRequest> patchStampRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditStamp(ref suppressDefaultLog, apiResponseLocalVar, stampId, patchStampRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        /// <param name="patchStampRequest"></param>
        partial void AfterEditStamp(ref bool suppressDefaultLog, IEditStampApiResponse apiResponseLocalVar, Guid stampId, Option<PatchStampRequest> patchStampRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        /// <param name="patchStampRequest"></param>
        private void OnErrorEditStampDefaultImplementation(Exception exception, string pathFormat, string path, Guid stampId, Option<PatchStampRequest> patchStampRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditStamp(ref suppressDefaultLog, exception, pathFormat, path, stampId, patchStampRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        /// <param name="patchStampRequest"></param>
        partial void OnErrorEditStamp(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid stampId, Option<PatchStampRequest> patchStampRequest);

        /// <summary>
        /// スタンプ情報を変更 指定したスタンプの情報を変更します。
        /// </summary>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="patchStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditStampApiResponse"/>&gt;</returns>
        public async Task<IEditStampApiResponse?> EditStampOrDefaultAsync(Guid stampId, Option<PatchStampRequest> patchStampRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditStampAsync(stampId, patchStampRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプ情報を変更 指定したスタンプの情報を変更します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="patchStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditStampApiResponse"/>&gt;</returns>
        public async Task<IEditStampApiResponse> EditStampAsync(Guid stampId, Option<PatchStampRequest> patchStampRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditStamp(patchStampRequest);

                FormatEditStamp(ref stampId, patchStampRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamps/{stampId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    if (patchStampRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchStampRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchStampRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditStampApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditStampApiResponse>();

                        EditStampApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamps/{stampId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditStampDefaultImplementation(apiResponseLocalVar, stampId, patchStampRequest);

                        Events.ExecuteOnEditStamp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditStampDefaultImplementation(e, "/stamps/{stampId}", uriBuilderLocalVar.Path, stampId, patchStampRequest);
                Events.ExecuteOnErrorEditStamp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditStampApiResponse"/>
        /// </summary>
        public partial class EditStampApiResponse : Traq.Client.ApiResponse, IEditStampApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditStampApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditStampApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditStampApiResponse(ILogger<EditStampApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditStampPalette(ref Guid paletteId, Option<PatchStampPaletteRequest> patchStampPaletteRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="patchStampPaletteRequest"></param>
        /// <returns></returns>
        private void ValidateEditStampPalette(Option<PatchStampPaletteRequest> patchStampPaletteRequest)
        {
            if (patchStampPaletteRequest.IsSet && patchStampPaletteRequest.Value == null)
                throw new ArgumentNullException(nameof(patchStampPaletteRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="paletteId"></param>
        /// <param name="patchStampPaletteRequest"></param>
        private void AfterEditStampPaletteDefaultImplementation(IEditStampPaletteApiResponse apiResponseLocalVar, Guid paletteId, Option<PatchStampPaletteRequest> patchStampPaletteRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditStampPalette(ref suppressDefaultLog, apiResponseLocalVar, paletteId, patchStampPaletteRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="paletteId"></param>
        /// <param name="patchStampPaletteRequest"></param>
        partial void AfterEditStampPalette(ref bool suppressDefaultLog, IEditStampPaletteApiResponse apiResponseLocalVar, Guid paletteId, Option<PatchStampPaletteRequest> patchStampPaletteRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="paletteId"></param>
        /// <param name="patchStampPaletteRequest"></param>
        private void OnErrorEditStampPaletteDefaultImplementation(Exception exception, string pathFormat, string path, Guid paletteId, Option<PatchStampPaletteRequest> patchStampPaletteRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditStampPalette(ref suppressDefaultLog, exception, pathFormat, path, paletteId, patchStampPaletteRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="paletteId"></param>
        /// <param name="patchStampPaletteRequest"></param>
        partial void OnErrorEditStampPalette(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid paletteId, Option<PatchStampPaletteRequest> patchStampPaletteRequest);

        /// <summary>
        /// スタンプパレットを編集 指定したスタンプパレットを編集します。 リクエストのスタンプの配列の順番は保存されて変更されます。 対象のスタンプパレットの管理権限が必要です。
        /// </summary>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="patchStampPaletteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditStampPaletteApiResponse"/>&gt;</returns>
        public async Task<IEditStampPaletteApiResponse?> EditStampPaletteOrDefaultAsync(Guid paletteId, Option<PatchStampPaletteRequest> patchStampPaletteRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditStampPaletteAsync(paletteId, patchStampPaletteRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプパレットを編集 指定したスタンプパレットを編集します。 リクエストのスタンプの配列の順番は保存されて変更されます。 対象のスタンプパレットの管理権限が必要です。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="patchStampPaletteRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditStampPaletteApiResponse"/>&gt;</returns>
        public async Task<IEditStampPaletteApiResponse> EditStampPaletteAsync(Guid paletteId, Option<PatchStampPaletteRequest> patchStampPaletteRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditStampPalette(patchStampPaletteRequest);

                FormatEditStampPalette(ref paletteId, patchStampPaletteRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamp-palettes/{paletteId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BpaletteId%7D", Uri.EscapeDataString(paletteId.ToString()));

                    if (patchStampPaletteRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchStampPaletteRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchStampPaletteRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditStampPaletteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditStampPaletteApiResponse>();

                        EditStampPaletteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamp-palettes/{paletteId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditStampPaletteDefaultImplementation(apiResponseLocalVar, paletteId, patchStampPaletteRequest);

                        Events.ExecuteOnEditStampPalette(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditStampPaletteDefaultImplementation(e, "/stamp-palettes/{paletteId}", uriBuilderLocalVar.Path, paletteId, patchStampPaletteRequest);
                Events.ExecuteOnErrorEditStampPalette(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditStampPaletteApiResponse"/>
        /// </summary>
        public partial class EditStampPaletteApiResponse : Traq.Client.ApiResponse, IEditStampPaletteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditStampPaletteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditStampPaletteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditStampPaletteApiResponse(ILogger<EditStampPaletteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMessageStamps(ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterGetMessageStampsDefaultImplementation(IGetMessageStampsApiResponse apiResponseLocalVar, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterGetMessageStamps(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterGetMessageStamps(ref bool suppressDefaultLog, IGetMessageStampsApiResponse apiResponseLocalVar, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        private void OnErrorGetMessageStampsDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMessageStamps(ref suppressDefaultLog, exception, pathFormat, path, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        partial void OnErrorGetMessageStamps(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId);

        /// <summary>
        /// メッセージのスタンプリストを取得 指定したメッセージに押されているスタンプのリストを取得します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageStampsApiResponse"/>&gt;</returns>
        public async Task<IGetMessageStampsApiResponse?> GetMessageStampsOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMessageStampsAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// メッセージのスタンプリストを取得 指定したメッセージに押されているスタンプのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageStampsApiResponse"/>&gt;</returns>
        public async Task<IGetMessageStampsApiResponse> GetMessageStampsAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetMessageStamps(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/stamps";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMessageStampsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMessageStampsApiResponse>();

                        GetMessageStampsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/stamps", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMessageStampsDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnGetMessageStamps(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMessageStampsDefaultImplementation(e, "/messages/{messageId}/stamps", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorGetMessageStamps(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMessageStampsApiResponse"/>
        /// </summary>
        public partial class GetMessageStampsApiResponse : Traq.Client.ApiResponse, IGetMessageStampsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMessageStampsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMessageStampsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessageStampsApiResponse(ILogger<GetMessageStampsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MessageStamp>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MessageStamp>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MessageStamp>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMyStampHistory(ref Option<int> limit);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        private void AfterGetMyStampHistoryDefaultImplementation(IGetMyStampHistoryApiResponse apiResponseLocalVar, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterGetMyStampHistory(ref suppressDefaultLog, apiResponseLocalVar, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        partial void AfterGetMyStampHistory(ref bool suppressDefaultLog, IGetMyStampHistoryApiResponse apiResponseLocalVar, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="limit"></param>
        private void OnErrorGetMyStampHistoryDefaultImplementation(Exception exception, string pathFormat, string path, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMyStampHistory(ref suppressDefaultLog, exception, pathFormat, path, limit);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="limit"></param>
        partial void OnErrorGetMyStampHistory(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<int> limit);

        /// <summary>
        /// スタンプ履歴を取得 自分のスタンプ履歴を最大100件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
        /// </summary>
        /// <param name="limit">件数 (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyStampHistoryApiResponse"/>&gt;</returns>
        public async Task<IGetMyStampHistoryApiResponse?> GetMyStampHistoryOrDefaultAsync(Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMyStampHistoryAsync(limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプ履歴を取得 自分のスタンプ履歴を最大100件まで取得します。 結果は降順で返されます。  このAPIが返すスタンプ履歴は厳密な履歴ではありません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">件数 (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyStampHistoryApiResponse"/>&gt;</returns>
        public async Task<IGetMyStampHistoryApiResponse> GetMyStampHistoryAsync(Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetMyStampHistory(ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/stamp-history";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMyStampHistoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMyStampHistoryApiResponse>();

                        GetMyStampHistoryApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/stamp-history", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMyStampHistoryDefaultImplementation(apiResponseLocalVar, limit);

                        Events.ExecuteOnGetMyStampHistory(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMyStampHistoryDefaultImplementation(e, "/users/me/stamp-history", uriBuilderLocalVar.Path, limit);
                Events.ExecuteOnErrorGetMyStampHistory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMyStampHistoryApiResponse"/>
        /// </summary>
        public partial class GetMyStampHistoryApiResponse : Traq.Client.ApiResponse, IGetMyStampHistoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMyStampHistoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMyStampHistoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMyStampHistoryApiResponse(ILogger<GetMyStampHistoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<StampHistoryEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<StampHistoryEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<StampHistoryEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetStamp(ref Guid stampId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        private void AfterGetStampDefaultImplementation(IGetStampApiResponse apiResponseLocalVar, Guid stampId)
        {
            bool suppressDefaultLog = false;
            AfterGetStamp(ref suppressDefaultLog, apiResponseLocalVar, stampId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        partial void AfterGetStamp(ref bool suppressDefaultLog, IGetStampApiResponse apiResponseLocalVar, Guid stampId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        private void OnErrorGetStampDefaultImplementation(Exception exception, string pathFormat, string path, Guid stampId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetStamp(ref suppressDefaultLog, exception, pathFormat, path, stampId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        partial void OnErrorGetStamp(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid stampId);

        /// <summary>
        /// スタンプ情報を取得 指定したスタンプの情報を取得します。
        /// </summary>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampApiResponse"/>&gt;</returns>
        public async Task<IGetStampApiResponse?> GetStampOrDefaultAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetStampAsync(stampId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプ情報を取得 指定したスタンプの情報を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampApiResponse"/>&gt;</returns>
        public async Task<IGetStampApiResponse> GetStampAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetStamp(ref stampId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamps/{stampId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetStampApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetStampApiResponse>();

                        GetStampApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamps/{stampId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetStampDefaultImplementation(apiResponseLocalVar, stampId);

                        Events.ExecuteOnGetStamp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetStampDefaultImplementation(e, "/stamps/{stampId}", uriBuilderLocalVar.Path, stampId);
                Events.ExecuteOnErrorGetStamp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetStampApiResponse"/>
        /// </summary>
        public partial class GetStampApiResponse : Traq.Client.ApiResponse, IGetStampApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetStampApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetStampApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetStampApiResponse(ILogger<GetStampApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.Stamp? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.Stamp>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.Stamp? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetStampImage(ref Guid stampId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        private void AfterGetStampImageDefaultImplementation(IGetStampImageApiResponse apiResponseLocalVar, Guid stampId)
        {
            bool suppressDefaultLog = false;
            AfterGetStampImage(ref suppressDefaultLog, apiResponseLocalVar, stampId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        partial void AfterGetStampImage(ref bool suppressDefaultLog, IGetStampImageApiResponse apiResponseLocalVar, Guid stampId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        private void OnErrorGetStampImageDefaultImplementation(Exception exception, string pathFormat, string path, Guid stampId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetStampImage(ref suppressDefaultLog, exception, pathFormat, path, stampId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        partial void OnErrorGetStampImage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid stampId);

        /// <summary>
        /// スタンプ画像を取得 指定したIDのスタンプ画像を返します。
        /// </summary>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampImageApiResponse"/>&gt;</returns>
        public async Task<IGetStampImageApiResponse?> GetStampImageOrDefaultAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetStampImageAsync(stampId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプ画像を取得 指定したIDのスタンプ画像を返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampImageApiResponse"/>&gt;</returns>
        public async Task<IGetStampImageApiResponse> GetStampImageAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetStampImage(ref stampId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamps/{stampId}/image";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "image/png",
                        "image/gif",
                        "image/jpeg"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetStampImageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetStampImageApiResponse>();

                        GetStampImageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamps/{stampId}/image", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetStampImageDefaultImplementation(apiResponseLocalVar, stampId);

                        Events.ExecuteOnGetStampImage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetStampImageDefaultImplementation(e, "/stamps/{stampId}/image", uriBuilderLocalVar.Path, stampId);
                Events.ExecuteOnErrorGetStampImage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetStampImageApiResponse"/>
        /// </summary>
        public partial class GetStampImageApiResponse : Traq.Client.ApiResponse, IGetStampImageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetStampImageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetStampImageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetStampImageApiResponse(ILogger<GetStampImageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public System.IO.Stream? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<System.IO.Stream>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out System.IO.Stream? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetStampPalette(ref Guid paletteId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="paletteId"></param>
        private void AfterGetStampPaletteDefaultImplementation(IGetStampPaletteApiResponse apiResponseLocalVar, Guid paletteId)
        {
            bool suppressDefaultLog = false;
            AfterGetStampPalette(ref suppressDefaultLog, apiResponseLocalVar, paletteId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="paletteId"></param>
        partial void AfterGetStampPalette(ref bool suppressDefaultLog, IGetStampPaletteApiResponse apiResponseLocalVar, Guid paletteId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="paletteId"></param>
        private void OnErrorGetStampPaletteDefaultImplementation(Exception exception, string pathFormat, string path, Guid paletteId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetStampPalette(ref suppressDefaultLog, exception, pathFormat, path, paletteId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="paletteId"></param>
        partial void OnErrorGetStampPalette(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid paletteId);

        /// <summary>
        /// スタンプパレットを取得 指定したスタンプパレットの情報を取得します。
        /// </summary>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampPaletteApiResponse"/>&gt;</returns>
        public async Task<IGetStampPaletteApiResponse?> GetStampPaletteOrDefaultAsync(Guid paletteId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetStampPaletteAsync(paletteId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプパレットを取得 指定したスタンプパレットの情報を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="paletteId">スタンプパレットUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampPaletteApiResponse"/>&gt;</returns>
        public async Task<IGetStampPaletteApiResponse> GetStampPaletteAsync(Guid paletteId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetStampPalette(ref paletteId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamp-palettes/{paletteId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BpaletteId%7D", Uri.EscapeDataString(paletteId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetStampPaletteApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetStampPaletteApiResponse>();

                        GetStampPaletteApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamp-palettes/{paletteId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetStampPaletteDefaultImplementation(apiResponseLocalVar, paletteId);

                        Events.ExecuteOnGetStampPalette(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetStampPaletteDefaultImplementation(e, "/stamp-palettes/{paletteId}", uriBuilderLocalVar.Path, paletteId);
                Events.ExecuteOnErrorGetStampPalette(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetStampPaletteApiResponse"/>
        /// </summary>
        public partial class GetStampPaletteApiResponse : Traq.Client.ApiResponse, IGetStampPaletteApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetStampPaletteApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetStampPaletteApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetStampPaletteApiResponse(ILogger<GetStampPaletteApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.StampPalette? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.StampPalette>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.StampPalette? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetStampPalettesDefaultImplementation(IGetStampPalettesApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetStampPalettes(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetStampPalettes(ref bool suppressDefaultLog, IGetStampPalettesApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        private void OnErrorGetStampPalettesDefaultImplementation(Exception exception, string pathFormat, string path)
        {
            bool suppressDefaultLog = false;
            OnErrorGetStampPalettes(ref suppressDefaultLog, exception, pathFormat, path);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        partial void OnErrorGetStampPalettes(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path);

        /// <summary>
        /// スタンプパレットのリストを取得 自身が所有しているスタンプパレットのリストを取得します。
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampPalettesApiResponse"/>&gt;</returns>
        public async Task<IGetStampPalettesApiResponse?> GetStampPalettesOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetStampPalettesAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプパレットのリストを取得 自身が所有しているスタンプパレットのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampPalettesApiResponse"/>&gt;</returns>
        public async Task<IGetStampPalettesApiResponse> GetStampPalettesAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamp-palettes";

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetStampPalettesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetStampPalettesApiResponse>();

                        GetStampPalettesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamp-palettes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetStampPalettesDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetStampPalettes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetStampPalettesDefaultImplementation(e, "/stamp-palettes", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetStampPalettes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetStampPalettesApiResponse"/>
        /// </summary>
        public partial class GetStampPalettesApiResponse : Traq.Client.ApiResponse, IGetStampPalettesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetStampPalettesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetStampPalettesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetStampPalettesApiResponse(ILogger<GetStampPalettesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<StampPalette>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<StampPalette>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<StampPalette>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetStampStats(ref Guid stampId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        private void AfterGetStampStatsDefaultImplementation(IGetStampStatsApiResponse apiResponseLocalVar, Guid stampId)
        {
            bool suppressDefaultLog = false;
            AfterGetStampStats(ref suppressDefaultLog, apiResponseLocalVar, stampId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="stampId"></param>
        partial void AfterGetStampStats(ref bool suppressDefaultLog, IGetStampStatsApiResponse apiResponseLocalVar, Guid stampId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        private void OnErrorGetStampStatsDefaultImplementation(Exception exception, string pathFormat, string path, Guid stampId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetStampStats(ref suppressDefaultLog, exception, pathFormat, path, stampId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="stampId"></param>
        partial void OnErrorGetStampStats(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid stampId);

        /// <summary>
        /// スタンプ統計情報を取得 指定したスタンプの統計情報を取得します。
        /// </summary>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampStatsApiResponse"/>&gt;</returns>
        public async Task<IGetStampStatsApiResponse?> GetStampStatsOrDefaultAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetStampStatsAsync(stampId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプ統計情報を取得 指定したスタンプの統計情報を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampStatsApiResponse"/>&gt;</returns>
        public async Task<IGetStampStatsApiResponse> GetStampStatsAsync(Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetStampStats(ref stampId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamps/{stampId}/stats";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetStampStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetStampStatsApiResponse>();

                        GetStampStatsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamps/{stampId}/stats", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetStampStatsDefaultImplementation(apiResponseLocalVar, stampId);

                        Events.ExecuteOnGetStampStats(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetStampStatsDefaultImplementation(e, "/stamps/{stampId}/stats", uriBuilderLocalVar.Path, stampId);
                Events.ExecuteOnErrorGetStampStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetStampStatsApiResponse"/>
        /// </summary>
        public partial class GetStampStatsApiResponse : Traq.Client.ApiResponse, IGetStampStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetStampStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetStampStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetStampStatsApiResponse(ILogger<GetStampStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.StampStats? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.StampStats>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.StampStats? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetStamps(ref Option<bool> includeUnicode, ref Option<string> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private void ValidateGetStamps(Option<string> type)
        {
            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="includeUnicode"></param>
        /// <param name="type"></param>
        private void AfterGetStampsDefaultImplementation(IGetStampsApiResponse apiResponseLocalVar, Option<bool> includeUnicode, Option<string> type)
        {
            bool suppressDefaultLog = false;
            AfterGetStamps(ref suppressDefaultLog, apiResponseLocalVar, includeUnicode, type);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="includeUnicode"></param>
        /// <param name="type"></param>
        partial void AfterGetStamps(ref bool suppressDefaultLog, IGetStampsApiResponse apiResponseLocalVar, Option<bool> includeUnicode, Option<string> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="includeUnicode"></param>
        /// <param name="type"></param>
        private void OnErrorGetStampsDefaultImplementation(Exception exception, string pathFormat, string path, Option<bool> includeUnicode, Option<string> type)
        {
            bool suppressDefaultLog = false;
            OnErrorGetStamps(ref suppressDefaultLog, exception, pathFormat, path, includeUnicode, type);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="includeUnicode"></param>
        /// <param name="type"></param>
        partial void OnErrorGetStamps(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<bool> includeUnicode, Option<string> type);

        /// <summary>
        /// スタンプリストを取得 スタンプのリストを取得します。
        /// </summary>
        /// <param name="includeUnicode">Unicode絵文字を含ませるかどうか Deprecated: typeクエリを指定しなければ全てのスタンプを取得できるため、そちらを利用してください  (optional, default to true)</param>
        /// <param name="type">取得するスタンプの種類 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampsApiResponse"/>&gt;</returns>
        public async Task<IGetStampsApiResponse?> GetStampsOrDefaultAsync(Option<bool> includeUnicode = default, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetStampsAsync(includeUnicode, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプリストを取得 スタンプのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeUnicode">Unicode絵文字を含ませるかどうか Deprecated: typeクエリを指定しなければ全てのスタンプを取得できるため、そちらを利用してください  (optional, default to true)</param>
        /// <param name="type">取得するスタンプの種類 (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetStampsApiResponse"/>&gt;</returns>
        public async Task<IGetStampsApiResponse> GetStampsAsync(Option<bool> includeUnicode = default, Option<string> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetStamps(type);

                FormatGetStamps(ref includeUnicode, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/stamps";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (includeUnicode.IsSet)
                        parseQueryStringLocalVar["include-unicode"] = ClientUtils.ParameterToString(includeUnicode.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetStampsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetStampsApiResponse>();

                        GetStampsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/stamps", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetStampsDefaultImplementation(apiResponseLocalVar, includeUnicode, type);

                        Events.ExecuteOnGetStamps(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetStampsDefaultImplementation(e, "/stamps", uriBuilderLocalVar.Path, includeUnicode, type);
                Events.ExecuteOnErrorGetStamps(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetStampsApiResponse"/>
        /// </summary>
        public partial class GetStampsApiResponse : Traq.Client.ApiResponse, IGetStampsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetStampsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetStampsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetStampsApiResponse(ILogger<GetStampsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<StampWithThumbnail>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<StampWithThumbnail>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<StampWithThumbnail>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveMessageStamp(ref Guid messageId, ref Guid stampId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        private void AfterRemoveMessageStampDefaultImplementation(IRemoveMessageStampApiResponse apiResponseLocalVar, Guid messageId, Guid stampId)
        {
            bool suppressDefaultLog = false;
            AfterRemoveMessageStamp(ref suppressDefaultLog, apiResponseLocalVar, messageId, stampId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        partial void AfterRemoveMessageStamp(ref bool suppressDefaultLog, IRemoveMessageStampApiResponse apiResponseLocalVar, Guid messageId, Guid stampId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        private void OnErrorRemoveMessageStampDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId, Guid stampId)
        {
            bool suppressDefaultLog = false;
            OnErrorRemoveMessageStamp(ref suppressDefaultLog, exception, pathFormat, path, messageId, stampId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        partial void OnErrorRemoveMessageStamp(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId, Guid stampId);

        /// <summary>
        /// スタンプを消す 指定したメッセージから指定した自身が押したスタンプを削除します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMessageStampApiResponse"/>&gt;</returns>
        public async Task<IRemoveMessageStampApiResponse?> RemoveMessageStampOrDefaultAsync(Guid messageId, Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveMessageStampAsync(messageId, stampId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプを消す 指定したメッセージから指定した自身が押したスタンプを削除します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMessageStampApiResponse"/>&gt;</returns>
        public async Task<IRemoveMessageStampApiResponse> RemoveMessageStampAsync(Guid messageId, Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRemoveMessageStamp(ref messageId, ref stampId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/stamps/{stampId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemoveMessageStampApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveMessageStampApiResponse>();

                        RemoveMessageStampApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/stamps/{stampId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemoveMessageStampDefaultImplementation(apiResponseLocalVar, messageId, stampId);

                        Events.ExecuteOnRemoveMessageStamp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveMessageStampDefaultImplementation(e, "/messages/{messageId}/stamps/{stampId}", uriBuilderLocalVar.Path, messageId, stampId);
                Events.ExecuteOnErrorRemoveMessageStamp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveMessageStampApiResponse"/>
        /// </summary>
        public partial class RemoveMessageStampApiResponse : Traq.Client.ApiResponse, IRemoveMessageStampApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveMessageStampApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveMessageStampApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveMessageStampApiResponse(ILogger<RemoveMessageStampApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
