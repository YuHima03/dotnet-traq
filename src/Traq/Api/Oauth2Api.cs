// <auto-generated>
/*
 * traQ v3
 *
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Traq.Client;
using Traq.Model;
using System.Diagnostics.CodeAnalysis;

namespace Traq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IOauth2Api : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        Oauth2ApiEvents Events { get; }

        /// <summary>
        /// OAuth2クライアントを作成
        /// </summary>
        /// <remarks>
        /// OAuth2クライアントを作成します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClientApiResponse"/>&gt;</returns>
        Task<ICreateClientApiResponse> CreateClientAsync(Option<PostClientRequest> postClientRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2クライアントを作成
        /// </summary>
        /// <remarks>
        /// OAuth2クライアントを作成します。
        /// </remarks>
        /// <param name="postClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClientApiResponse"/>?&gt;</returns>
        Task<ICreateClientApiResponse?> CreateClientOrDefaultAsync(Option<PostClientRequest> postClientRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2クライアントを削除
        /// </summary>
        /// <remarks>
        /// 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteClientApiResponse"/>&gt;</returns>
        Task<IDeleteClientApiResponse> DeleteClientAsync(string clientId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2クライアントを削除
        /// </summary>
        /// <remarks>
        /// 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
        /// </remarks>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteClientApiResponse"/>?&gt;</returns>
        Task<IDeleteClientApiResponse?> DeleteClientOrDefaultAsync(string clientId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2クライアント情報を変更
        /// </summary>
        /// <remarks>
        /// 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="patchClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditClientApiResponse"/>&gt;</returns>
        Task<IEditClientApiResponse> EditClientAsync(string clientId, Option<PatchClientRequest> patchClientRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2クライアント情報を変更
        /// </summary>
        /// <remarks>
        /// 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
        /// </remarks>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="patchClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditClientApiResponse"/>?&gt;</returns>
        Task<IEditClientApiResponse?> EditClientOrDefaultAsync(string clientId, Option<PatchClientRequest> patchClientRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2クライアント情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="detail">詳細情報を含めるかどうか (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClientApiResponse"/>&gt;</returns>
        Task<IGetClientApiResponse> GetClientAsync(string clientId, Option<bool> detail = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2クライアント情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
        /// </remarks>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="detail">詳細情報を含めるかどうか (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClientApiResponse"/>?&gt;</returns>
        Task<IGetClientApiResponse?> GetClientOrDefaultAsync(string clientId, Option<bool> detail = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2クライアントのリストを取得
        /// </summary>
        /// <remarks>
        /// 自身が開発者のOAuth2クライアントのリストを取得します。 &#x60;all&#x60;が&#x60;true&#x60;の場合、全開発者の全クライアントのリストを返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="all">全てのクライアントを取得するかどうか (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClientsApiResponse"/>&gt;</returns>
        Task<IGetClientsApiResponse> GetClientsAsync(Option<bool> all = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2クライアントのリストを取得
        /// </summary>
        /// <remarks>
        /// 自身が開発者のOAuth2クライアントのリストを取得します。 &#x60;all&#x60;が&#x60;true&#x60;の場合、全開発者の全クライアントのリストを返します。
        /// </remarks>
        /// <param name="all">全てのクライアントを取得するかどうか (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClientsApiResponse"/>?&gt;</returns>
        Task<IGetClientsApiResponse?> GetClientsOrDefaultAsync(Option<bool> all = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 有効トークンのリストを取得
        /// </summary>
        /// <remarks>
        /// 有効な自分に発行されたOAuth2トークンのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyTokensApiResponse"/>&gt;</returns>
        Task<IGetMyTokensApiResponse> GetMyTokensAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 有効トークンのリストを取得
        /// </summary>
        /// <remarks>
        /// 有効な自分に発行されたOAuth2トークンのリストを取得します。
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyTokensApiResponse"/>?&gt;</returns>
        Task<IGetMyTokensApiResponse?> GetMyTokensOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 認可エンドポイント
        /// </summary>
        /// <remarks>
        /// OAuth2 認可エンドポイント
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <param name="responseType"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="codeChallenge"> (optional)</param>
        /// <param name="codeChallengeMethod"> (optional)</param>
        /// <param name="nonce"> (optional)</param>
        /// <param name="prompt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOAuth2AuthorizeApiResponse"/>&gt;</returns>
        Task<IGetOAuth2AuthorizeApiResponse> GetOAuth2AuthorizeAsync(string clientId, Option<OAuth2ResponseType> responseType = default, Option<string> redirectUri = default, Option<string> scope = default, Option<string> state = default, Option<string> codeChallenge = default, Option<string> codeChallengeMethod = default, Option<string> nonce = default, Option<OAuth2Prompt> prompt = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 認可エンドポイント
        /// </summary>
        /// <remarks>
        /// OAuth2 認可エンドポイント
        /// </remarks>
        /// <param name="clientId"></param>
        /// <param name="responseType"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="codeChallenge"> (optional)</param>
        /// <param name="codeChallengeMethod"> (optional)</param>
        /// <param name="nonce"> (optional)</param>
        /// <param name="prompt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOAuth2AuthorizeApiResponse"/>?&gt;</returns>
        Task<IGetOAuth2AuthorizeApiResponse?> GetOAuth2AuthorizeOrDefaultAsync(string clientId, Option<OAuth2ResponseType> responseType = default, Option<string> redirectUri = default, Option<string> scope = default, Option<string> state = default, Option<string> codeChallenge = default, Option<string> codeChallengeMethod = default, Option<string> nonce = default, Option<OAuth2Prompt> prompt = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 認可エンドポイント
        /// </summary>
        /// <remarks>
        /// OAuth2 認可エンドポイント
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <param name="responseType"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="codeChallenge"> (optional)</param>
        /// <param name="codeChallengeMethod"> (optional)</param>
        /// <param name="nonce"> (optional)</param>
        /// <param name="prompt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2AuthorizeApiResponse"/>&gt;</returns>
        Task<IPostOAuth2AuthorizeApiResponse> PostOAuth2AuthorizeAsync(string clientId, Option<OAuth2ResponseType> responseType = default, Option<string> redirectUri = default, Option<string> scope = default, Option<string> state = default, Option<string> codeChallenge = default, Option<string> codeChallengeMethod = default, Option<string> nonce = default, Option<OAuth2Prompt> prompt = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 認可エンドポイント
        /// </summary>
        /// <remarks>
        /// OAuth2 認可エンドポイント
        /// </remarks>
        /// <param name="clientId"></param>
        /// <param name="responseType"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="codeChallenge"> (optional)</param>
        /// <param name="codeChallengeMethod"> (optional)</param>
        /// <param name="nonce"> (optional)</param>
        /// <param name="prompt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2AuthorizeApiResponse"/>?&gt;</returns>
        Task<IPostOAuth2AuthorizeApiResponse?> PostOAuth2AuthorizeOrDefaultAsync(string clientId, Option<OAuth2ResponseType> responseType = default, Option<string> redirectUri = default, Option<string> scope = default, Option<string> state = default, Option<string> codeChallenge = default, Option<string> codeChallengeMethod = default, Option<string> nonce = default, Option<OAuth2Prompt> prompt = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 認可承諾API
        /// </summary>
        /// <remarks>
        /// OAuth2 認可承諾
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submit">承諾する場合は\\\&quot;approve\\\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2AuthorizeDecideApiResponse"/>&gt;</returns>
        Task<IPostOAuth2AuthorizeDecideApiResponse> PostOAuth2AuthorizeDecideAsync(string submit, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 認可承諾API
        /// </summary>
        /// <remarks>
        /// OAuth2 認可承諾
        /// </remarks>
        /// <param name="submit">承諾する場合は\\\&quot;approve\\\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2AuthorizeDecideApiResponse"/>?&gt;</returns>
        Task<IPostOAuth2AuthorizeDecideApiResponse?> PostOAuth2AuthorizeDecideOrDefaultAsync(string submit, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 トークンエンドポイント
        /// </summary>
        /// <remarks>
        /// OAuth2 トークンエンドポイント
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType"></param>
        /// <param name="code"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="clientId"> (optional)</param>
        /// <param name="codeVerifier"> (optional)</param>
        /// <param name="username"> (optional)</param>
        /// <param name="password"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="refreshToken"> (optional)</param>
        /// <param name="clientSecret"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2TokenApiResponse"/>&gt;</returns>
        Task<IPostOAuth2TokenApiResponse> PostOAuth2TokenAsync(string grantType, Option<string> code = default, Option<string> redirectUri = default, Option<string> clientId = default, Option<string> codeVerifier = default, Option<string> username = default, Option<string> password = default, Option<string> scope = default, Option<string> refreshToken = default, Option<string> clientSecret = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 トークンエンドポイント
        /// </summary>
        /// <remarks>
        /// OAuth2 トークンエンドポイント
        /// </remarks>
        /// <param name="grantType"></param>
        /// <param name="code"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="clientId"> (optional)</param>
        /// <param name="codeVerifier"> (optional)</param>
        /// <param name="username"> (optional)</param>
        /// <param name="password"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="refreshToken"> (optional)</param>
        /// <param name="clientSecret"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2TokenApiResponse"/>?&gt;</returns>
        Task<IPostOAuth2TokenApiResponse?> PostOAuth2TokenOrDefaultAsync(string grantType, Option<string> code = default, Option<string> redirectUri = default, Option<string> clientId = default, Option<string> codeVerifier = default, Option<string> username = default, Option<string> password = default, Option<string> scope = default, Option<string> refreshToken = default, Option<string> clientSecret = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuthクライアントのトークンを削除
        /// </summary>
        /// <remarks>
        /// 自分が許可している指定したOAuthクライアントのアクセストークンを全てRevokeします。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeClientTokensApiResponse"/>&gt;</returns>
        Task<IRevokeClientTokensApiResponse> RevokeClientTokensAsync(string clientId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuthクライアントのトークンを削除
        /// </summary>
        /// <remarks>
        /// 自分が許可している指定したOAuthクライアントのアクセストークンを全てRevokeします。
        /// </remarks>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeClientTokensApiResponse"/>?&gt;</returns>
        Task<IRevokeClientTokensApiResponse?> RevokeClientTokensOrDefaultAsync(string clientId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// トークンの認可を取り消す
        /// </summary>
        /// <remarks>
        /// 自分の指定したトークンの認可を取り消します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenId">OAuth2トークンUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeMyTokenApiResponse"/>&gt;</returns>
        Task<IRevokeMyTokenApiResponse> RevokeMyTokenAsync(Guid tokenId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// トークンの認可を取り消す
        /// </summary>
        /// <remarks>
        /// 自分の指定したトークンの認可を取り消します。
        /// </remarks>
        /// <param name="tokenId">OAuth2トークンUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeMyTokenApiResponse"/>?&gt;</returns>
        Task<IRevokeMyTokenApiResponse?> RevokeMyTokenOrDefaultAsync(Guid tokenId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 トークン無効化エンドポイント
        /// </summary>
        /// <remarks>
        /// OAuth2 トークン無効化エンドポイント
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">無効化するOAuth2トークンまたはOAuth2リフレッシュトークン</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeOAuth2TokenApiResponse"/>&gt;</returns>
        Task<IRevokeOAuth2TokenApiResponse> RevokeOAuth2TokenAsync(string token, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// OAuth2 トークン無効化エンドポイント
        /// </summary>
        /// <remarks>
        /// OAuth2 トークン無効化エンドポイント
        /// </remarks>
        /// <param name="token">無効化するOAuth2トークンまたはOAuth2リフレッシュトークン</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeOAuth2TokenApiResponse"/>?&gt;</returns>
        Task<IRevokeOAuth2TokenApiResponse?> RevokeOAuth2TokenOrDefaultAsync(string token, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateClientApiResponse"/>
    /// </summary>
    public interface ICreateClientApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.OAuth2ClientDetail?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteClientApiResponse"/>
    /// </summary>
    public interface IDeleteClientApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IEditClientApiResponse"/>
    /// </summary>
    public interface IEditClientApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetClientApiResponse"/>
    /// </summary>
    public interface IGetClientApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.GetClient200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetClientsApiResponse"/>
    /// </summary>
    public interface IGetClientsApiResponse : Traq.Client.IApiResponse, IOk<List<OAuth2Client>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetMyTokensApiResponse"/>
    /// </summary>
    public interface IGetMyTokensApiResponse : Traq.Client.IApiResponse, IOk<List<ActiveOAuth2Token>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetOAuth2AuthorizeApiResponse"/>
    /// </summary>
    public interface IGetOAuth2AuthorizeApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 302 Found
        /// </summary>
        /// <returns></returns>
        bool IsFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IPostOAuth2AuthorizeApiResponse"/>
    /// </summary>
    public interface IPostOAuth2AuthorizeApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 302 Found
        /// </summary>
        /// <returns></returns>
        bool IsFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IPostOAuth2AuthorizeDecideApiResponse"/>
    /// </summary>
    public interface IPostOAuth2AuthorizeDecideApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 302 Found
        /// </summary>
        /// <returns></returns>
        bool IsFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IPostOAuth2TokenApiResponse"/>
    /// </summary>
    public interface IPostOAuth2TokenApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.OAuth2Token?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IRevokeClientTokensApiResponse"/>
    /// </summary>
    public interface IRevokeClientTokensApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IRevokeMyTokenApiResponse"/>
    /// </summary>
    public interface IRevokeMyTokenApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IRevokeOAuth2TokenApiResponse"/>
    /// </summary>
    public interface IRevokeOAuth2TokenApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class Oauth2ApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateClient;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateClient;

        internal void ExecuteOnCreateClient(Oauth2Api.CreateClientApiResponse apiResponse)
        {
            OnCreateClient?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateClient(Exception exception)
        {
            OnErrorCreateClient?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteClient;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteClient;

        internal void ExecuteOnDeleteClient(Oauth2Api.DeleteClientApiResponse apiResponse)
        {
            OnDeleteClient?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteClient(Exception exception)
        {
            OnErrorDeleteClient?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditClient;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditClient;

        internal void ExecuteOnEditClient(Oauth2Api.EditClientApiResponse apiResponse)
        {
            OnEditClient?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditClient(Exception exception)
        {
            OnErrorEditClient?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetClient;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetClient;

        internal void ExecuteOnGetClient(Oauth2Api.GetClientApiResponse apiResponse)
        {
            OnGetClient?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetClient(Exception exception)
        {
            OnErrorGetClient?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetClients;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetClients;

        internal void ExecuteOnGetClients(Oauth2Api.GetClientsApiResponse apiResponse)
        {
            OnGetClients?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetClients(Exception exception)
        {
            OnErrorGetClients?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMyTokens;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMyTokens;

        internal void ExecuteOnGetMyTokens(Oauth2Api.GetMyTokensApiResponse apiResponse)
        {
            OnGetMyTokens?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMyTokens(Exception exception)
        {
            OnErrorGetMyTokens?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetOAuth2Authorize;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetOAuth2Authorize;

        internal void ExecuteOnGetOAuth2Authorize(Oauth2Api.GetOAuth2AuthorizeApiResponse apiResponse)
        {
            OnGetOAuth2Authorize?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetOAuth2Authorize(Exception exception)
        {
            OnErrorGetOAuth2Authorize?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostOAuth2Authorize;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostOAuth2Authorize;

        internal void ExecuteOnPostOAuth2Authorize(Oauth2Api.PostOAuth2AuthorizeApiResponse apiResponse)
        {
            OnPostOAuth2Authorize?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostOAuth2Authorize(Exception exception)
        {
            OnErrorPostOAuth2Authorize?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostOAuth2AuthorizeDecide;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostOAuth2AuthorizeDecide;

        internal void ExecuteOnPostOAuth2AuthorizeDecide(Oauth2Api.PostOAuth2AuthorizeDecideApiResponse apiResponse)
        {
            OnPostOAuth2AuthorizeDecide?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostOAuth2AuthorizeDecide(Exception exception)
        {
            OnErrorPostOAuth2AuthorizeDecide?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostOAuth2Token;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostOAuth2Token;

        internal void ExecuteOnPostOAuth2Token(Oauth2Api.PostOAuth2TokenApiResponse apiResponse)
        {
            OnPostOAuth2Token?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostOAuth2Token(Exception exception)
        {
            OnErrorPostOAuth2Token?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRevokeClientTokens;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRevokeClientTokens;

        internal void ExecuteOnRevokeClientTokens(Oauth2Api.RevokeClientTokensApiResponse apiResponse)
        {
            OnRevokeClientTokens?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRevokeClientTokens(Exception exception)
        {
            OnErrorRevokeClientTokens?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRevokeMyToken;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRevokeMyToken;

        internal void ExecuteOnRevokeMyToken(Oauth2Api.RevokeMyTokenApiResponse apiResponse)
        {
            OnRevokeMyToken?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRevokeMyToken(Exception exception)
        {
            OnErrorRevokeMyToken?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRevokeOAuth2Token;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRevokeOAuth2Token;

        internal void ExecuteOnRevokeOAuth2Token(Oauth2Api.RevokeOAuth2TokenApiResponse apiResponse)
        {
            OnRevokeOAuth2Token?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRevokeOAuth2Token(Exception exception)
        {
            OnErrorRevokeOAuth2Token?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class Oauth2Api : IOauth2Api
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<Oauth2Api> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public Oauth2ApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="Oauth2Api"/> class.
        /// </summary>
        /// <returns></returns>
        public Oauth2Api(ILogger<Oauth2Api> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, Oauth2ApiEvents oauth2ApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<Oauth2Api>();
            HttpClient = httpClient;
            Events = oauth2ApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatCreateClient(Option<PostClientRequest> postClientRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postClientRequest"></param>
        /// <returns></returns>
        private void ValidateCreateClient(Option<PostClientRequest> postClientRequest)
        {
            if (postClientRequest.IsSet && postClientRequest.Value == null)
                throw new ArgumentNullException(nameof(postClientRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postClientRequest"></param>
        private void AfterCreateClientDefaultImplementation(ICreateClientApiResponse apiResponseLocalVar, Option<PostClientRequest> postClientRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateClient(ref suppressDefaultLog, apiResponseLocalVar, postClientRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postClientRequest"></param>
        partial void AfterCreateClient(ref bool suppressDefaultLog, ICreateClientApiResponse apiResponseLocalVar, Option<PostClientRequest> postClientRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postClientRequest"></param>
        private void OnErrorCreateClientDefaultImplementation(Exception exception, string pathFormat, string path, Option<PostClientRequest> postClientRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorCreateClient(ref suppressDefaultLog, exception, pathFormat, path, postClientRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postClientRequest"></param>
        partial void OnErrorCreateClient(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<PostClientRequest> postClientRequest);

        /// <summary>
        /// OAuth2クライアントを作成 OAuth2クライアントを作成します。
        /// </summary>
        /// <param name="postClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClientApiResponse"/>&gt;</returns>
        public async Task<ICreateClientApiResponse?> CreateClientOrDefaultAsync(Option<PostClientRequest> postClientRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateClientAsync(postClientRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2クライアントを作成 OAuth2クライアントを作成します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateClientApiResponse"/>&gt;</returns>
        public async Task<ICreateClientApiResponse> CreateClientAsync(Option<PostClientRequest> postClientRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateClient(postClientRequest);

                FormatCreateClient(postClientRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clients";

                    if (postClientRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postClientRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postClientRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateClientApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateClientApiResponse>();

                        CreateClientApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clients", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateClientDefaultImplementation(apiResponseLocalVar, postClientRequest);

                        Events.ExecuteOnCreateClient(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateClientDefaultImplementation(e, "/clients", uriBuilderLocalVar.Path, postClientRequest);
                Events.ExecuteOnErrorCreateClient(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateClientApiResponse"/>
        /// </summary>
        public partial class CreateClientApiResponse : Traq.Client.ApiResponse, ICreateClientApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateClientApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateClientApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateClientApiResponse(ILogger<CreateClientApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.OAuth2ClientDetail? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.OAuth2ClientDetail>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.OAuth2ClientDetail? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteClient(ref string clientId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="clientId"></param>
        /// <returns></returns>
        private void ValidateDeleteClient(string clientId)
        {
            if (clientId == null)
                throw new ArgumentNullException(nameof(clientId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        private void AfterDeleteClientDefaultImplementation(IDeleteClientApiResponse apiResponseLocalVar, string clientId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteClient(ref suppressDefaultLog, apiResponseLocalVar, clientId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        partial void AfterDeleteClient(ref bool suppressDefaultLog, IDeleteClientApiResponse apiResponseLocalVar, string clientId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        private void OnErrorDeleteClientDefaultImplementation(Exception exception, string pathFormat, string path, string clientId)
        {
            bool suppressDefaultLog = false;
            OnErrorDeleteClient(ref suppressDefaultLog, exception, pathFormat, path, clientId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        partial void OnErrorDeleteClient(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string clientId);

        /// <summary>
        /// OAuth2クライアントを削除 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
        /// </summary>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteClientApiResponse"/>&gt;</returns>
        public async Task<IDeleteClientApiResponse?> DeleteClientOrDefaultAsync(string clientId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteClientAsync(clientId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2クライアントを削除 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteClientApiResponse"/>&gt;</returns>
        public async Task<IDeleteClientApiResponse> DeleteClientAsync(string clientId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteClient(clientId);

                FormatDeleteClient(ref clientId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clients/{clientId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BclientId%7D", Uri.EscapeDataString(clientId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteClientApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteClientApiResponse>();

                        DeleteClientApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clients/{clientId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteClientDefaultImplementation(apiResponseLocalVar, clientId);

                        Events.ExecuteOnDeleteClient(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteClientDefaultImplementation(e, "/clients/{clientId}", uriBuilderLocalVar.Path, clientId);
                Events.ExecuteOnErrorDeleteClient(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteClientApiResponse"/>
        /// </summary>
        public partial class DeleteClientApiResponse : Traq.Client.ApiResponse, IDeleteClientApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteClientApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteClientApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteClientApiResponse(ILogger<DeleteClientApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditClient(ref string clientId, Option<PatchClientRequest> patchClientRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="clientId"></param>
        /// <param name="patchClientRequest"></param>
        /// <returns></returns>
        private void ValidateEditClient(string clientId, Option<PatchClientRequest> patchClientRequest)
        {
            if (clientId == null)
                throw new ArgumentNullException(nameof(clientId));

            if (patchClientRequest.IsSet && patchClientRequest.Value == null)
                throw new ArgumentNullException(nameof(patchClientRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        /// <param name="patchClientRequest"></param>
        private void AfterEditClientDefaultImplementation(IEditClientApiResponse apiResponseLocalVar, string clientId, Option<PatchClientRequest> patchClientRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditClient(ref suppressDefaultLog, apiResponseLocalVar, clientId, patchClientRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        /// <param name="patchClientRequest"></param>
        partial void AfterEditClient(ref bool suppressDefaultLog, IEditClientApiResponse apiResponseLocalVar, string clientId, Option<PatchClientRequest> patchClientRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        /// <param name="patchClientRequest"></param>
        private void OnErrorEditClientDefaultImplementation(Exception exception, string pathFormat, string path, string clientId, Option<PatchClientRequest> patchClientRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditClient(ref suppressDefaultLog, exception, pathFormat, path, clientId, patchClientRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        /// <param name="patchClientRequest"></param>
        partial void OnErrorEditClient(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string clientId, Option<PatchClientRequest> patchClientRequest);

        /// <summary>
        /// OAuth2クライアント情報を変更 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
        /// </summary>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="patchClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditClientApiResponse"/>&gt;</returns>
        public async Task<IEditClientApiResponse?> EditClientOrDefaultAsync(string clientId, Option<PatchClientRequest> patchClientRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditClientAsync(clientId, patchClientRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2クライアント情報を変更 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="patchClientRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditClientApiResponse"/>&gt;</returns>
        public async Task<IEditClientApiResponse> EditClientAsync(string clientId, Option<PatchClientRequest> patchClientRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditClient(clientId, patchClientRequest);

                FormatEditClient(ref clientId, patchClientRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clients/{clientId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BclientId%7D", Uri.EscapeDataString(clientId.ToString()));

                    if (patchClientRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchClientRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchClientRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditClientApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditClientApiResponse>();

                        EditClientApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clients/{clientId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditClientDefaultImplementation(apiResponseLocalVar, clientId, patchClientRequest);

                        Events.ExecuteOnEditClient(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditClientDefaultImplementation(e, "/clients/{clientId}", uriBuilderLocalVar.Path, clientId, patchClientRequest);
                Events.ExecuteOnErrorEditClient(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditClientApiResponse"/>
        /// </summary>
        public partial class EditClientApiResponse : Traq.Client.ApiResponse, IEditClientApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditClientApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditClientApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditClientApiResponse(ILogger<EditClientApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetClient(ref string clientId, ref Option<bool> detail);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="clientId"></param>
        /// <returns></returns>
        private void ValidateGetClient(string clientId)
        {
            if (clientId == null)
                throw new ArgumentNullException(nameof(clientId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        /// <param name="detail"></param>
        private void AfterGetClientDefaultImplementation(IGetClientApiResponse apiResponseLocalVar, string clientId, Option<bool> detail)
        {
            bool suppressDefaultLog = false;
            AfterGetClient(ref suppressDefaultLog, apiResponseLocalVar, clientId, detail);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        /// <param name="detail"></param>
        partial void AfterGetClient(ref bool suppressDefaultLog, IGetClientApiResponse apiResponseLocalVar, string clientId, Option<bool> detail);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        /// <param name="detail"></param>
        private void OnErrorGetClientDefaultImplementation(Exception exception, string pathFormat, string path, string clientId, Option<bool> detail)
        {
            bool suppressDefaultLog = false;
            OnErrorGetClient(ref suppressDefaultLog, exception, pathFormat, path, clientId, detail);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        /// <param name="detail"></param>
        partial void OnErrorGetClient(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string clientId, Option<bool> detail);

        /// <summary>
        /// OAuth2クライアント情報を取得 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
        /// </summary>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="detail">詳細情報を含めるかどうか (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClientApiResponse"/>&gt;</returns>
        public async Task<IGetClientApiResponse?> GetClientOrDefaultAsync(string clientId, Option<bool> detail = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetClientAsync(clientId, detail, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2クライアント情報を取得 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="detail">詳細情報を含めるかどうか (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClientApiResponse"/>&gt;</returns>
        public async Task<IGetClientApiResponse> GetClientAsync(string clientId, Option<bool> detail = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetClient(clientId);

                FormatGetClient(ref clientId, ref detail);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clients/{clientId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BclientId%7D", Uri.EscapeDataString(clientId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (detail.IsSet)
                        parseQueryStringLocalVar["detail"] = ClientUtils.ParameterToString(detail.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetClientApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetClientApiResponse>();

                        GetClientApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clients/{clientId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetClientDefaultImplementation(apiResponseLocalVar, clientId, detail);

                        Events.ExecuteOnGetClient(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetClientDefaultImplementation(e, "/clients/{clientId}", uriBuilderLocalVar.Path, clientId, detail);
                Events.ExecuteOnErrorGetClient(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetClientApiResponse"/>
        /// </summary>
        public partial class GetClientApiResponse : Traq.Client.ApiResponse, IGetClientApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetClientApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetClientApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetClientApiResponse(ILogger<GetClientApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.GetClient200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.GetClient200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.GetClient200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetClients(ref Option<bool> all);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="all"></param>
        private void AfterGetClientsDefaultImplementation(IGetClientsApiResponse apiResponseLocalVar, Option<bool> all)
        {
            bool suppressDefaultLog = false;
            AfterGetClients(ref suppressDefaultLog, apiResponseLocalVar, all);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="all"></param>
        partial void AfterGetClients(ref bool suppressDefaultLog, IGetClientsApiResponse apiResponseLocalVar, Option<bool> all);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="all"></param>
        private void OnErrorGetClientsDefaultImplementation(Exception exception, string pathFormat, string path, Option<bool> all)
        {
            bool suppressDefaultLog = false;
            OnErrorGetClients(ref suppressDefaultLog, exception, pathFormat, path, all);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="all"></param>
        partial void OnErrorGetClients(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<bool> all);

        /// <summary>
        /// OAuth2クライアントのリストを取得 自身が開発者のOAuth2クライアントのリストを取得します。 &#x60;all&#x60;が&#x60;true&#x60;の場合、全開発者の全クライアントのリストを返します。
        /// </summary>
        /// <param name="all">全てのクライアントを取得するかどうか (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClientsApiResponse"/>&gt;</returns>
        public async Task<IGetClientsApiResponse?> GetClientsOrDefaultAsync(Option<bool> all = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetClientsAsync(all, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2クライアントのリストを取得 自身が開発者のOAuth2クライアントのリストを取得します。 &#x60;all&#x60;が&#x60;true&#x60;の場合、全開発者の全クライアントのリストを返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="all">全てのクライアントを取得するかどうか (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetClientsApiResponse"/>&gt;</returns>
        public async Task<IGetClientsApiResponse> GetClientsAsync(Option<bool> all = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetClients(ref all);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clients";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (all.IsSet)
                        parseQueryStringLocalVar["all"] = ClientUtils.ParameterToString(all.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetClientsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetClientsApiResponse>();

                        GetClientsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clients", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetClientsDefaultImplementation(apiResponseLocalVar, all);

                        Events.ExecuteOnGetClients(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetClientsDefaultImplementation(e, "/clients", uriBuilderLocalVar.Path, all);
                Events.ExecuteOnErrorGetClients(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetClientsApiResponse"/>
        /// </summary>
        public partial class GetClientsApiResponse : Traq.Client.ApiResponse, IGetClientsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetClientsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetClientsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetClientsApiResponse(ILogger<GetClientsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<OAuth2Client>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<OAuth2Client>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<OAuth2Client>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetMyTokensDefaultImplementation(IGetMyTokensApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetMyTokens(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetMyTokens(ref bool suppressDefaultLog, IGetMyTokensApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        private void OnErrorGetMyTokensDefaultImplementation(Exception exception, string pathFormat, string path)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMyTokens(ref suppressDefaultLog, exception, pathFormat, path);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        partial void OnErrorGetMyTokens(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path);

        /// <summary>
        /// 有効トークンのリストを取得 有効な自分に発行されたOAuth2トークンのリストを取得します。
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyTokensApiResponse"/>&gt;</returns>
        public async Task<IGetMyTokensApiResponse?> GetMyTokensOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMyTokensAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 有効トークンのリストを取得 有効な自分に発行されたOAuth2トークンのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyTokensApiResponse"/>&gt;</returns>
        public async Task<IGetMyTokensApiResponse> GetMyTokensAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/tokens";

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMyTokensApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMyTokensApiResponse>();

                        GetMyTokensApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/tokens", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMyTokensDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetMyTokens(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMyTokensDefaultImplementation(e, "/users/me/tokens", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetMyTokens(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMyTokensApiResponse"/>
        /// </summary>
        public partial class GetMyTokensApiResponse : Traq.Client.ApiResponse, IGetMyTokensApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMyTokensApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMyTokensApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMyTokensApiResponse(ILogger<GetMyTokensApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ActiveOAuth2Token>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ActiveOAuth2Token>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ActiveOAuth2Token>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetOAuth2Authorize(ref string clientId, ref Option<OAuth2ResponseType> responseType, ref Option<string> redirectUri, ref Option<string> scope, ref Option<string> state, ref Option<string> codeChallenge, ref Option<string> codeChallengeMethod, ref Option<string> nonce, ref Option<OAuth2Prompt> prompt);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="clientId"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <returns></returns>
        private void ValidateGetOAuth2Authorize(string clientId, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce)
        {
            if (clientId == null)
                throw new ArgumentNullException(nameof(clientId));

            if (redirectUri.IsSet && redirectUri.Value == null)
                throw new ArgumentNullException(nameof(redirectUri));

            if (scope.IsSet && scope.Value == null)
                throw new ArgumentNullException(nameof(scope));

            if (state.IsSet && state.Value == null)
                throw new ArgumentNullException(nameof(state));

            if (codeChallenge.IsSet && codeChallenge.Value == null)
                throw new ArgumentNullException(nameof(codeChallenge));

            if (codeChallengeMethod.IsSet && codeChallengeMethod.Value == null)
                throw new ArgumentNullException(nameof(codeChallengeMethod));

            if (nonce.IsSet && nonce.Value == null)
                throw new ArgumentNullException(nameof(nonce));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        /// <param name="responseType"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <param name="prompt"></param>
        private void AfterGetOAuth2AuthorizeDefaultImplementation(IGetOAuth2AuthorizeApiResponse apiResponseLocalVar, string clientId, Option<OAuth2ResponseType> responseType, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce, Option<OAuth2Prompt> prompt)
        {
            bool suppressDefaultLog = false;
            AfterGetOAuth2Authorize(ref suppressDefaultLog, apiResponseLocalVar, clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        /// <param name="responseType"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <param name="prompt"></param>
        partial void AfterGetOAuth2Authorize(ref bool suppressDefaultLog, IGetOAuth2AuthorizeApiResponse apiResponseLocalVar, string clientId, Option<OAuth2ResponseType> responseType, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce, Option<OAuth2Prompt> prompt);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        /// <param name="responseType"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <param name="prompt"></param>
        private void OnErrorGetOAuth2AuthorizeDefaultImplementation(Exception exception, string pathFormat, string path, string clientId, Option<OAuth2ResponseType> responseType, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce, Option<OAuth2Prompt> prompt)
        {
            bool suppressDefaultLog = false;
            OnErrorGetOAuth2Authorize(ref suppressDefaultLog, exception, pathFormat, path, clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        /// <param name="responseType"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <param name="prompt"></param>
        partial void OnErrorGetOAuth2Authorize(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string clientId, Option<OAuth2ResponseType> responseType, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce, Option<OAuth2Prompt> prompt);

        /// <summary>
        /// OAuth2 認可エンドポイント OAuth2 認可エンドポイント
        /// </summary>
        /// <param name="clientId"></param>
        /// <param name="responseType"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="codeChallenge"> (optional)</param>
        /// <param name="codeChallengeMethod"> (optional)</param>
        /// <param name="nonce"> (optional)</param>
        /// <param name="prompt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOAuth2AuthorizeApiResponse"/>&gt;</returns>
        public async Task<IGetOAuth2AuthorizeApiResponse?> GetOAuth2AuthorizeOrDefaultAsync(string clientId, Option<OAuth2ResponseType> responseType = default, Option<string> redirectUri = default, Option<string> scope = default, Option<string> state = default, Option<string> codeChallenge = default, Option<string> codeChallengeMethod = default, Option<string> nonce = default, Option<OAuth2Prompt> prompt = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetOAuth2AuthorizeAsync(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2 認可エンドポイント OAuth2 認可エンドポイント
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <param name="responseType"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="codeChallenge"> (optional)</param>
        /// <param name="codeChallengeMethod"> (optional)</param>
        /// <param name="nonce"> (optional)</param>
        /// <param name="prompt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetOAuth2AuthorizeApiResponse"/>&gt;</returns>
        public async Task<IGetOAuth2AuthorizeApiResponse> GetOAuth2AuthorizeAsync(string clientId, Option<OAuth2ResponseType> responseType = default, Option<string> redirectUri = default, Option<string> scope = default, Option<string> state = default, Option<string> codeChallenge = default, Option<string> codeChallengeMethod = default, Option<string> nonce = default, Option<OAuth2Prompt> prompt = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetOAuth2Authorize(clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce);

                FormatGetOAuth2Authorize(ref clientId, ref responseType, ref redirectUri, ref scope, ref state, ref codeChallenge, ref codeChallengeMethod, ref nonce, ref prompt);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/oauth2/authorize";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["client_id"] = ClientUtils.ParameterToString(clientId);

                    if (responseType.IsSet)
                        parseQueryStringLocalVar["response_type"] = ClientUtils.ParameterToString(responseType.Value);

                    if (redirectUri.IsSet)
                        parseQueryStringLocalVar["redirect_uri"] = ClientUtils.ParameterToString(redirectUri.Value);

                    if (scope.IsSet)
                        parseQueryStringLocalVar["scope"] = ClientUtils.ParameterToString(scope.Value);

                    if (state.IsSet)
                        parseQueryStringLocalVar["state"] = ClientUtils.ParameterToString(state.Value);

                    if (codeChallenge.IsSet)
                        parseQueryStringLocalVar["code_challenge"] = ClientUtils.ParameterToString(codeChallenge.Value);

                    if (codeChallengeMethod.IsSet)
                        parseQueryStringLocalVar["code_challenge_method"] = ClientUtils.ParameterToString(codeChallengeMethod.Value);

                    if (nonce.IsSet)
                        parseQueryStringLocalVar["nonce"] = ClientUtils.ParameterToString(nonce.Value);

                    if (prompt.IsSet)
                        parseQueryStringLocalVar["prompt"] = ClientUtils.ParameterToString(prompt.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetOAuth2AuthorizeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetOAuth2AuthorizeApiResponse>();

                        GetOAuth2AuthorizeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/oauth2/authorize", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetOAuth2AuthorizeDefaultImplementation(apiResponseLocalVar, clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt);

                        Events.ExecuteOnGetOAuth2Authorize(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetOAuth2AuthorizeDefaultImplementation(e, "/oauth2/authorize", uriBuilderLocalVar.Path, clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt);
                Events.ExecuteOnErrorGetOAuth2Authorize(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetOAuth2AuthorizeApiResponse"/>
        /// </summary>
        public partial class GetOAuth2AuthorizeApiResponse : Traq.Client.ApiResponse, IGetOAuth2AuthorizeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetOAuth2AuthorizeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetOAuth2AuthorizeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetOAuth2AuthorizeApiResponse(ILogger<GetOAuth2AuthorizeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 302 Found
            /// </summary>
            /// <returns></returns>
            public bool IsFound => 302 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostOAuth2Authorize(ref string clientId, ref Option<OAuth2ResponseType> responseType, ref Option<string> redirectUri, ref Option<string> scope, ref Option<string> state, ref Option<string> codeChallenge, ref Option<string> codeChallengeMethod, ref Option<string> nonce, ref Option<OAuth2Prompt> prompt);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="clientId"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <returns></returns>
        private void ValidatePostOAuth2Authorize(string clientId, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce)
        {
            if (clientId == null)
                throw new ArgumentNullException(nameof(clientId));

            if (redirectUri.IsSet && redirectUri.Value == null)
                throw new ArgumentNullException(nameof(redirectUri));

            if (scope.IsSet && scope.Value == null)
                throw new ArgumentNullException(nameof(scope));

            if (state.IsSet && state.Value == null)
                throw new ArgumentNullException(nameof(state));

            if (codeChallenge.IsSet && codeChallenge.Value == null)
                throw new ArgumentNullException(nameof(codeChallenge));

            if (codeChallengeMethod.IsSet && codeChallengeMethod.Value == null)
                throw new ArgumentNullException(nameof(codeChallengeMethod));

            if (nonce.IsSet && nonce.Value == null)
                throw new ArgumentNullException(nameof(nonce));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        /// <param name="responseType"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <param name="prompt"></param>
        private void AfterPostOAuth2AuthorizeDefaultImplementation(IPostOAuth2AuthorizeApiResponse apiResponseLocalVar, string clientId, Option<OAuth2ResponseType> responseType, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce, Option<OAuth2Prompt> prompt)
        {
            bool suppressDefaultLog = false;
            AfterPostOAuth2Authorize(ref suppressDefaultLog, apiResponseLocalVar, clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        /// <param name="responseType"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <param name="prompt"></param>
        partial void AfterPostOAuth2Authorize(ref bool suppressDefaultLog, IPostOAuth2AuthorizeApiResponse apiResponseLocalVar, string clientId, Option<OAuth2ResponseType> responseType, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce, Option<OAuth2Prompt> prompt);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        /// <param name="responseType"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <param name="prompt"></param>
        private void OnErrorPostOAuth2AuthorizeDefaultImplementation(Exception exception, string pathFormat, string path, string clientId, Option<OAuth2ResponseType> responseType, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce, Option<OAuth2Prompt> prompt)
        {
            bool suppressDefaultLog = false;
            OnErrorPostOAuth2Authorize(ref suppressDefaultLog, exception, pathFormat, path, clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        /// <param name="responseType"></param>
        /// <param name="redirectUri"></param>
        /// <param name="scope"></param>
        /// <param name="state"></param>
        /// <param name="codeChallenge"></param>
        /// <param name="codeChallengeMethod"></param>
        /// <param name="nonce"></param>
        /// <param name="prompt"></param>
        partial void OnErrorPostOAuth2Authorize(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string clientId, Option<OAuth2ResponseType> responseType, Option<string> redirectUri, Option<string> scope, Option<string> state, Option<string> codeChallenge, Option<string> codeChallengeMethod, Option<string> nonce, Option<OAuth2Prompt> prompt);

        /// <summary>
        /// OAuth2 認可エンドポイント OAuth2 認可エンドポイント
        /// </summary>
        /// <param name="clientId"></param>
        /// <param name="responseType"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="codeChallenge"> (optional)</param>
        /// <param name="codeChallengeMethod"> (optional)</param>
        /// <param name="nonce"> (optional)</param>
        /// <param name="prompt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2AuthorizeApiResponse"/>&gt;</returns>
        public async Task<IPostOAuth2AuthorizeApiResponse?> PostOAuth2AuthorizeOrDefaultAsync(string clientId, Option<OAuth2ResponseType> responseType = default, Option<string> redirectUri = default, Option<string> scope = default, Option<string> state = default, Option<string> codeChallenge = default, Option<string> codeChallengeMethod = default, Option<string> nonce = default, Option<OAuth2Prompt> prompt = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostOAuth2AuthorizeAsync(clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2 認可エンドポイント OAuth2 認可エンドポイント
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId"></param>
        /// <param name="responseType"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="state"> (optional)</param>
        /// <param name="codeChallenge"> (optional)</param>
        /// <param name="codeChallengeMethod"> (optional)</param>
        /// <param name="nonce"> (optional)</param>
        /// <param name="prompt"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2AuthorizeApiResponse"/>&gt;</returns>
        public async Task<IPostOAuth2AuthorizeApiResponse> PostOAuth2AuthorizeAsync(string clientId, Option<OAuth2ResponseType> responseType = default, Option<string> redirectUri = default, Option<string> scope = default, Option<string> state = default, Option<string> codeChallenge = default, Option<string> codeChallengeMethod = default, Option<string> nonce = default, Option<OAuth2Prompt> prompt = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostOAuth2Authorize(clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce);

                FormatPostOAuth2Authorize(ref clientId, ref responseType, ref redirectUri, ref scope, ref state, ref codeChallenge, ref codeChallengeMethod, ref nonce, ref prompt);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/oauth2/authorize";

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));

                    formParameterLocalVars.Add(new KeyValuePair<string?, string?>("client_id", ClientUtils.ParameterToString(clientId)));

                    if (responseType.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("response_type", ClientUtils.ParameterToString(responseType.Value)));

                    if (redirectUri.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("redirect_uri", ClientUtils.ParameterToString(redirectUri.Value)));

                    if (scope.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("scope", ClientUtils.ParameterToString(scope.Value)));

                    if (state.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("state", ClientUtils.ParameterToString(state.Value)));

                    if (codeChallenge.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("code_challenge", ClientUtils.ParameterToString(codeChallenge.Value)));

                    if (codeChallengeMethod.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("code_challenge_method", ClientUtils.ParameterToString(codeChallengeMethod.Value)));

                    if (nonce.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("nonce", ClientUtils.ParameterToString(nonce.Value)));

                    if (prompt.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("prompt", ClientUtils.ParameterToString(prompt.Value)));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostOAuth2AuthorizeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostOAuth2AuthorizeApiResponse>();

                        PostOAuth2AuthorizeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/oauth2/authorize", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostOAuth2AuthorizeDefaultImplementation(apiResponseLocalVar, clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt);

                        Events.ExecuteOnPostOAuth2Authorize(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostOAuth2AuthorizeDefaultImplementation(e, "/oauth2/authorize", uriBuilderLocalVar.Path, clientId, responseType, redirectUri, scope, state, codeChallenge, codeChallengeMethod, nonce, prompt);
                Events.ExecuteOnErrorPostOAuth2Authorize(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostOAuth2AuthorizeApiResponse"/>
        /// </summary>
        public partial class PostOAuth2AuthorizeApiResponse : Traq.Client.ApiResponse, IPostOAuth2AuthorizeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostOAuth2AuthorizeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostOAuth2AuthorizeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostOAuth2AuthorizeApiResponse(ILogger<PostOAuth2AuthorizeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 302 Found
            /// </summary>
            /// <returns></returns>
            public bool IsFound => 302 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostOAuth2AuthorizeDecide(ref string submit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="submit"></param>
        /// <returns></returns>
        private void ValidatePostOAuth2AuthorizeDecide(string submit)
        {
            if (submit == null)
                throw new ArgumentNullException(nameof(submit));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submit"></param>
        private void AfterPostOAuth2AuthorizeDecideDefaultImplementation(IPostOAuth2AuthorizeDecideApiResponse apiResponseLocalVar, string submit)
        {
            bool suppressDefaultLog = false;
            AfterPostOAuth2AuthorizeDecide(ref suppressDefaultLog, apiResponseLocalVar, submit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="submit"></param>
        partial void AfterPostOAuth2AuthorizeDecide(ref bool suppressDefaultLog, IPostOAuth2AuthorizeDecideApiResponse apiResponseLocalVar, string submit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="submit"></param>
        private void OnErrorPostOAuth2AuthorizeDecideDefaultImplementation(Exception exception, string pathFormat, string path, string submit)
        {
            bool suppressDefaultLog = false;
            OnErrorPostOAuth2AuthorizeDecide(ref suppressDefaultLog, exception, pathFormat, path, submit);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="submit"></param>
        partial void OnErrorPostOAuth2AuthorizeDecide(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string submit);

        /// <summary>
        /// OAuth2 認可承諾API OAuth2 認可承諾
        /// </summary>
        /// <param name="submit">承諾する場合は\\\&quot;approve\\\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2AuthorizeDecideApiResponse"/>&gt;</returns>
        public async Task<IPostOAuth2AuthorizeDecideApiResponse?> PostOAuth2AuthorizeDecideOrDefaultAsync(string submit, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostOAuth2AuthorizeDecideAsync(submit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2 認可承諾API OAuth2 認可承諾
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="submit">承諾する場合は\\\&quot;approve\\\&quot;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2AuthorizeDecideApiResponse"/>&gt;</returns>
        public async Task<IPostOAuth2AuthorizeDecideApiResponse> PostOAuth2AuthorizeDecideAsync(string submit, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostOAuth2AuthorizeDecide(submit);

                FormatPostOAuth2AuthorizeDecide(ref submit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/oauth2/authorize/decide";

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));

                    formParameterLocalVars.Add(new KeyValuePair<string?, string?>("submit", ClientUtils.ParameterToString(submit)));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostOAuth2AuthorizeDecideApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostOAuth2AuthorizeDecideApiResponse>();

                        PostOAuth2AuthorizeDecideApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/oauth2/authorize/decide", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostOAuth2AuthorizeDecideDefaultImplementation(apiResponseLocalVar, submit);

                        Events.ExecuteOnPostOAuth2AuthorizeDecide(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostOAuth2AuthorizeDecideDefaultImplementation(e, "/oauth2/authorize/decide", uriBuilderLocalVar.Path, submit);
                Events.ExecuteOnErrorPostOAuth2AuthorizeDecide(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostOAuth2AuthorizeDecideApiResponse"/>
        /// </summary>
        public partial class PostOAuth2AuthorizeDecideApiResponse : Traq.Client.ApiResponse, IPostOAuth2AuthorizeDecideApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostOAuth2AuthorizeDecideApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostOAuth2AuthorizeDecideApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostOAuth2AuthorizeDecideApiResponse(ILogger<PostOAuth2AuthorizeDecideApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 302 Found
            /// </summary>
            /// <returns></returns>
            public bool IsFound => 302 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostOAuth2Token(ref string grantType, ref Option<string> code, ref Option<string> redirectUri, ref Option<string> clientId, ref Option<string> codeVerifier, ref Option<string> username, ref Option<string> password, ref Option<string> scope, ref Option<string> refreshToken, ref Option<string> clientSecret);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="grantType"></param>
        /// <param name="code"></param>
        /// <param name="redirectUri"></param>
        /// <param name="clientId"></param>
        /// <param name="codeVerifier"></param>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="scope"></param>
        /// <param name="refreshToken"></param>
        /// <param name="clientSecret"></param>
        /// <returns></returns>
        private void ValidatePostOAuth2Token(string grantType, Option<string> code, Option<string> redirectUri, Option<string> clientId, Option<string> codeVerifier, Option<string> username, Option<string> password, Option<string> scope, Option<string> refreshToken, Option<string> clientSecret)
        {
            if (grantType == null)
                throw new ArgumentNullException(nameof(grantType));

            if (code.IsSet && code.Value == null)
                throw new ArgumentNullException(nameof(code));

            if (redirectUri.IsSet && redirectUri.Value == null)
                throw new ArgumentNullException(nameof(redirectUri));

            if (clientId.IsSet && clientId.Value == null)
                throw new ArgumentNullException(nameof(clientId));

            if (codeVerifier.IsSet && codeVerifier.Value == null)
                throw new ArgumentNullException(nameof(codeVerifier));

            if (username.IsSet && username.Value == null)
                throw new ArgumentNullException(nameof(username));

            if (password.IsSet && password.Value == null)
                throw new ArgumentNullException(nameof(password));

            if (scope.IsSet && scope.Value == null)
                throw new ArgumentNullException(nameof(scope));

            if (refreshToken.IsSet && refreshToken.Value == null)
                throw new ArgumentNullException(nameof(refreshToken));

            if (clientSecret.IsSet && clientSecret.Value == null)
                throw new ArgumentNullException(nameof(clientSecret));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="grantType"></param>
        /// <param name="code"></param>
        /// <param name="redirectUri"></param>
        /// <param name="clientId"></param>
        /// <param name="codeVerifier"></param>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="scope"></param>
        /// <param name="refreshToken"></param>
        /// <param name="clientSecret"></param>
        private void AfterPostOAuth2TokenDefaultImplementation(IPostOAuth2TokenApiResponse apiResponseLocalVar, string grantType, Option<string> code, Option<string> redirectUri, Option<string> clientId, Option<string> codeVerifier, Option<string> username, Option<string> password, Option<string> scope, Option<string> refreshToken, Option<string> clientSecret)
        {
            bool suppressDefaultLog = false;
            AfterPostOAuth2Token(ref suppressDefaultLog, apiResponseLocalVar, grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="grantType"></param>
        /// <param name="code"></param>
        /// <param name="redirectUri"></param>
        /// <param name="clientId"></param>
        /// <param name="codeVerifier"></param>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="scope"></param>
        /// <param name="refreshToken"></param>
        /// <param name="clientSecret"></param>
        partial void AfterPostOAuth2Token(ref bool suppressDefaultLog, IPostOAuth2TokenApiResponse apiResponseLocalVar, string grantType, Option<string> code, Option<string> redirectUri, Option<string> clientId, Option<string> codeVerifier, Option<string> username, Option<string> password, Option<string> scope, Option<string> refreshToken, Option<string> clientSecret);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="grantType"></param>
        /// <param name="code"></param>
        /// <param name="redirectUri"></param>
        /// <param name="clientId"></param>
        /// <param name="codeVerifier"></param>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="scope"></param>
        /// <param name="refreshToken"></param>
        /// <param name="clientSecret"></param>
        private void OnErrorPostOAuth2TokenDefaultImplementation(Exception exception, string pathFormat, string path, string grantType, Option<string> code, Option<string> redirectUri, Option<string> clientId, Option<string> codeVerifier, Option<string> username, Option<string> password, Option<string> scope, Option<string> refreshToken, Option<string> clientSecret)
        {
            bool suppressDefaultLog = false;
            OnErrorPostOAuth2Token(ref suppressDefaultLog, exception, pathFormat, path, grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="grantType"></param>
        /// <param name="code"></param>
        /// <param name="redirectUri"></param>
        /// <param name="clientId"></param>
        /// <param name="codeVerifier"></param>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="scope"></param>
        /// <param name="refreshToken"></param>
        /// <param name="clientSecret"></param>
        partial void OnErrorPostOAuth2Token(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string grantType, Option<string> code, Option<string> redirectUri, Option<string> clientId, Option<string> codeVerifier, Option<string> username, Option<string> password, Option<string> scope, Option<string> refreshToken, Option<string> clientSecret);

        /// <summary>
        /// OAuth2 トークンエンドポイント OAuth2 トークンエンドポイント
        /// </summary>
        /// <param name="grantType"></param>
        /// <param name="code"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="clientId"> (optional)</param>
        /// <param name="codeVerifier"> (optional)</param>
        /// <param name="username"> (optional)</param>
        /// <param name="password"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="refreshToken"> (optional)</param>
        /// <param name="clientSecret"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2TokenApiResponse"/>&gt;</returns>
        public async Task<IPostOAuth2TokenApiResponse?> PostOAuth2TokenOrDefaultAsync(string grantType, Option<string> code = default, Option<string> redirectUri = default, Option<string> clientId = default, Option<string> codeVerifier = default, Option<string> username = default, Option<string> password = default, Option<string> scope = default, Option<string> refreshToken = default, Option<string> clientSecret = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostOAuth2TokenAsync(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2 トークンエンドポイント OAuth2 トークンエンドポイント
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType"></param>
        /// <param name="code"> (optional)</param>
        /// <param name="redirectUri"> (optional)</param>
        /// <param name="clientId"> (optional)</param>
        /// <param name="codeVerifier"> (optional)</param>
        /// <param name="username"> (optional)</param>
        /// <param name="password"> (optional)</param>
        /// <param name="scope"> (optional)</param>
        /// <param name="refreshToken"> (optional)</param>
        /// <param name="clientSecret"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostOAuth2TokenApiResponse"/>&gt;</returns>
        public async Task<IPostOAuth2TokenApiResponse> PostOAuth2TokenAsync(string grantType, Option<string> code = default, Option<string> redirectUri = default, Option<string> clientId = default, Option<string> codeVerifier = default, Option<string> username = default, Option<string> password = default, Option<string> scope = default, Option<string> refreshToken = default, Option<string> clientSecret = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostOAuth2Token(grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret);

                FormatPostOAuth2Token(ref grantType, ref code, ref redirectUri, ref clientId, ref codeVerifier, ref username, ref password, ref scope, ref refreshToken, ref clientSecret);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/oauth2/token";

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));

                    formParameterLocalVars.Add(new KeyValuePair<string?, string?>("grant_type", ClientUtils.ParameterToString(grantType)));

                    if (code.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("code", ClientUtils.ParameterToString(code.Value)));

                    if (redirectUri.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("redirect_uri", ClientUtils.ParameterToString(redirectUri.Value)));

                    if (clientId.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("client_id", ClientUtils.ParameterToString(clientId.Value)));

                    if (codeVerifier.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("code_verifier", ClientUtils.ParameterToString(codeVerifier.Value)));

                    if (username.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("username", ClientUtils.ParameterToString(username.Value)));

                    if (password.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("password", ClientUtils.ParameterToString(password.Value)));

                    if (scope.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("scope", ClientUtils.ParameterToString(scope.Value)));

                    if (refreshToken.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("refresh_token", ClientUtils.ParameterToString(refreshToken.Value)));

                    if (clientSecret.IsSet)
                        formParameterLocalVars.Add(new KeyValuePair<string?, string?>("client_secret", ClientUtils.ParameterToString(clientSecret.Value)));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostOAuth2TokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostOAuth2TokenApiResponse>();

                        PostOAuth2TokenApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/oauth2/token", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostOAuth2TokenDefaultImplementation(apiResponseLocalVar, grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret);

                        Events.ExecuteOnPostOAuth2Token(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostOAuth2TokenDefaultImplementation(e, "/oauth2/token", uriBuilderLocalVar.Path, grantType, code, redirectUri, clientId, codeVerifier, username, password, scope, refreshToken, clientSecret);
                Events.ExecuteOnErrorPostOAuth2Token(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostOAuth2TokenApiResponse"/>
        /// </summary>
        public partial class PostOAuth2TokenApiResponse : Traq.Client.ApiResponse, IPostOAuth2TokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostOAuth2TokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostOAuth2TokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostOAuth2TokenApiResponse(ILogger<PostOAuth2TokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.OAuth2Token? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.OAuth2Token>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.OAuth2Token? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRevokeClientTokens(ref string clientId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="clientId"></param>
        /// <returns></returns>
        private void ValidateRevokeClientTokens(string clientId)
        {
            if (clientId == null)
                throw new ArgumentNullException(nameof(clientId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        private void AfterRevokeClientTokensDefaultImplementation(IRevokeClientTokensApiResponse apiResponseLocalVar, string clientId)
        {
            bool suppressDefaultLog = false;
            AfterRevokeClientTokens(ref suppressDefaultLog, apiResponseLocalVar, clientId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="clientId"></param>
        partial void AfterRevokeClientTokens(ref bool suppressDefaultLog, IRevokeClientTokensApiResponse apiResponseLocalVar, string clientId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        private void OnErrorRevokeClientTokensDefaultImplementation(Exception exception, string pathFormat, string path, string clientId)
        {
            bool suppressDefaultLog = false;
            OnErrorRevokeClientTokens(ref suppressDefaultLog, exception, pathFormat, path, clientId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="clientId"></param>
        partial void OnErrorRevokeClientTokens(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string clientId);

        /// <summary>
        /// OAuthクライアントのトークンを削除 自分が許可している指定したOAuthクライアントのアクセストークンを全てRevokeします。
        /// </summary>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeClientTokensApiResponse"/>&gt;</returns>
        public async Task<IRevokeClientTokensApiResponse?> RevokeClientTokensOrDefaultAsync(string clientId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RevokeClientTokensAsync(clientId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuthクライアントのトークンを削除 自分が許可している指定したOAuthクライアントのアクセストークンを全てRevokeします。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">OAuth2クライアントUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeClientTokensApiResponse"/>&gt;</returns>
        public async Task<IRevokeClientTokensApiResponse> RevokeClientTokensAsync(string clientId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRevokeClientTokens(clientId);

                FormatRevokeClientTokens(ref clientId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/clients/{clientId}/tokens";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BclientId%7D", Uri.EscapeDataString(clientId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RevokeClientTokensApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RevokeClientTokensApiResponse>();

                        RevokeClientTokensApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/clients/{clientId}/tokens", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRevokeClientTokensDefaultImplementation(apiResponseLocalVar, clientId);

                        Events.ExecuteOnRevokeClientTokens(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRevokeClientTokensDefaultImplementation(e, "/clients/{clientId}/tokens", uriBuilderLocalVar.Path, clientId);
                Events.ExecuteOnErrorRevokeClientTokens(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RevokeClientTokensApiResponse"/>
        /// </summary>
        public partial class RevokeClientTokensApiResponse : Traq.Client.ApiResponse, IRevokeClientTokensApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RevokeClientTokensApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RevokeClientTokensApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RevokeClientTokensApiResponse(ILogger<RevokeClientTokensApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRevokeMyToken(ref Guid tokenId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tokenId"></param>
        private void AfterRevokeMyTokenDefaultImplementation(IRevokeMyTokenApiResponse apiResponseLocalVar, Guid tokenId)
        {
            bool suppressDefaultLog = false;
            AfterRevokeMyToken(ref suppressDefaultLog, apiResponseLocalVar, tokenId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tokenId"></param>
        partial void AfterRevokeMyToken(ref bool suppressDefaultLog, IRevokeMyTokenApiResponse apiResponseLocalVar, Guid tokenId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="tokenId"></param>
        private void OnErrorRevokeMyTokenDefaultImplementation(Exception exception, string pathFormat, string path, Guid tokenId)
        {
            bool suppressDefaultLog = false;
            OnErrorRevokeMyToken(ref suppressDefaultLog, exception, pathFormat, path, tokenId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="tokenId"></param>
        partial void OnErrorRevokeMyToken(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid tokenId);

        /// <summary>
        /// トークンの認可を取り消す 自分の指定したトークンの認可を取り消します。
        /// </summary>
        /// <param name="tokenId">OAuth2トークンUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeMyTokenApiResponse"/>&gt;</returns>
        public async Task<IRevokeMyTokenApiResponse?> RevokeMyTokenOrDefaultAsync(Guid tokenId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RevokeMyTokenAsync(tokenId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// トークンの認可を取り消す 自分の指定したトークンの認可を取り消します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tokenId">OAuth2トークンUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeMyTokenApiResponse"/>&gt;</returns>
        public async Task<IRevokeMyTokenApiResponse> RevokeMyTokenAsync(Guid tokenId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRevokeMyToken(ref tokenId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/tokens/{tokenId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtokenId%7D", Uri.EscapeDataString(tokenId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RevokeMyTokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RevokeMyTokenApiResponse>();

                        RevokeMyTokenApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/tokens/{tokenId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRevokeMyTokenDefaultImplementation(apiResponseLocalVar, tokenId);

                        Events.ExecuteOnRevokeMyToken(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRevokeMyTokenDefaultImplementation(e, "/users/me/tokens/{tokenId}", uriBuilderLocalVar.Path, tokenId);
                Events.ExecuteOnErrorRevokeMyToken(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RevokeMyTokenApiResponse"/>
        /// </summary>
        public partial class RevokeMyTokenApiResponse : Traq.Client.ApiResponse, IRevokeMyTokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RevokeMyTokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RevokeMyTokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RevokeMyTokenApiResponse(ILogger<RevokeMyTokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRevokeOAuth2Token(ref string token);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        private void ValidateRevokeOAuth2Token(string token)
        {
            if (token == null)
                throw new ArgumentNullException(nameof(token));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="token"></param>
        private void AfterRevokeOAuth2TokenDefaultImplementation(IRevokeOAuth2TokenApiResponse apiResponseLocalVar, string token)
        {
            bool suppressDefaultLog = false;
            AfterRevokeOAuth2Token(ref suppressDefaultLog, apiResponseLocalVar, token);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="token"></param>
        partial void AfterRevokeOAuth2Token(ref bool suppressDefaultLog, IRevokeOAuth2TokenApiResponse apiResponseLocalVar, string token);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="token"></param>
        private void OnErrorRevokeOAuth2TokenDefaultImplementation(Exception exception, string pathFormat, string path, string token)
        {
            bool suppressDefaultLog = false;
            OnErrorRevokeOAuth2Token(ref suppressDefaultLog, exception, pathFormat, path, token);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="token"></param>
        partial void OnErrorRevokeOAuth2Token(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, string token);

        /// <summary>
        /// OAuth2 トークン無効化エンドポイント OAuth2 トークン無効化エンドポイント
        /// </summary>
        /// <param name="token">無効化するOAuth2トークンまたはOAuth2リフレッシュトークン</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeOAuth2TokenApiResponse"/>&gt;</returns>
        public async Task<IRevokeOAuth2TokenApiResponse?> RevokeOAuth2TokenOrDefaultAsync(string token, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RevokeOAuth2TokenAsync(token, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// OAuth2 トークン無効化エンドポイント OAuth2 トークン無効化エンドポイント
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">無効化するOAuth2トークンまたはOAuth2リフレッシュトークン</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRevokeOAuth2TokenApiResponse"/>&gt;</returns>
        public async Task<IRevokeOAuth2TokenApiResponse> RevokeOAuth2TokenAsync(string token, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRevokeOAuth2Token(token);

                FormatRevokeOAuth2Token(ref token);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/oauth2/revoke";

                    MultipartContent multipartContentLocalVar = new MultipartContent();

                    httpRequestMessageLocalVar.Content = multipartContentLocalVar;

                    List<KeyValuePair<string?, string?>> formParameterLocalVars = new List<KeyValuePair<string?, string?>>();

                    multipartContentLocalVar.Add(new FormUrlEncodedContent(formParameterLocalVars));

                    formParameterLocalVars.Add(new KeyValuePair<string?, string?>("token", ClientUtils.ParameterToString(token)));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RevokeOAuth2TokenApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RevokeOAuth2TokenApiResponse>();

                        RevokeOAuth2TokenApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/oauth2/revoke", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRevokeOAuth2TokenDefaultImplementation(apiResponseLocalVar, token);

                        Events.ExecuteOnRevokeOAuth2Token(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRevokeOAuth2TokenDefaultImplementation(e, "/oauth2/revoke", uriBuilderLocalVar.Path, token);
                Events.ExecuteOnErrorRevokeOAuth2Token(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RevokeOAuth2TokenApiResponse"/>
        /// </summary>
        public partial class RevokeOAuth2TokenApiResponse : Traq.Client.ApiResponse, IRevokeOAuth2TokenApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RevokeOAuth2TokenApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RevokeOAuth2TokenApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RevokeOAuth2TokenApiResponse(ILogger<RevokeOAuth2TokenApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
