// <auto-generated>
/*
 * traQ v3
 *
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Traq.Client;
using Traq.Model;
using System.Diagnostics.CodeAnalysis;

namespace Traq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IMessageApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        MessageApiEvents Events { get; }

        /// <summary>
        /// スタンプを押す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージに指定したスタンプを押します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="postMessageStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMessageStampApiResponse"/>&gt;</returns>
        Task<IAddMessageStampApiResponse> AddMessageStampAsync(Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを押す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージに指定したスタンプを押します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="postMessageStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMessageStampApiResponse"/>?&gt;</returns>
        Task<IAddMessageStampApiResponse?> AddMessageStampOrDefaultAsync(Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ピン留めする
        /// </summary>
        /// <remarks>
        /// 指定したメッセージをピン留めします。 アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePinApiResponse"/>&gt;</returns>
        Task<ICreatePinApiResponse> CreatePinAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ピン留めする
        /// </summary>
        /// <remarks>
        /// 指定したメッセージをピン留めします。 アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePinApiResponse"/>?&gt;</returns>
        Task<ICreatePinApiResponse?> CreatePinOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージを削除
        /// </summary>
        /// <remarks>
        /// 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteMessageApiResponse"/>&gt;</returns>
        Task<IDeleteMessageApiResponse> DeleteMessageAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージを削除
        /// </summary>
        /// <remarks>
        /// 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteMessageApiResponse"/>?&gt;</returns>
        Task<IDeleteMessageApiResponse?> DeleteMessageOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージを編集
        /// </summary>
        /// <remarks>
        /// 指定したメッセージを編集します。 自身が投稿したメッセージのみ編集することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditMessageApiResponse"/>&gt;</returns>
        Task<IEditMessageApiResponse> EditMessageAsync(Guid messageId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージを編集
        /// </summary>
        /// <remarks>
        /// 指定したメッセージを編集します。 自身が投稿したメッセージのみ編集することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditMessageApiResponse"/>?&gt;</returns>
        Task<IEditMessageApiResponse?> EditMessageOrDefaultAsync(Guid messageId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ダイレクトメッセージのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーとのダイレクトメッセージのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDirectMessagesApiResponse"/>&gt;</returns>
        Task<IGetDirectMessagesApiResponse> GetDirectMessagesAsync(Guid userId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ダイレクトメッセージのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーとのダイレクトメッセージのリストを取得します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDirectMessagesApiResponse"/>?&gt;</returns>
        Task<IGetDirectMessagesApiResponse?> GetDirectMessagesOrDefaultAsync(Guid userId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージを取得
        /// </summary>
        /// <remarks>
        /// 指定したメッセージを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageApiResponse"/>&gt;</returns>
        Task<IGetMessageApiResponse> GetMessageAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージを取得
        /// </summary>
        /// <remarks>
        /// 指定したメッセージを取得します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageApiResponse"/>?&gt;</returns>
        Task<IGetMessageApiResponse?> GetMessageOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のクリップを取得
        /// </summary>
        /// <remarks>
        /// 対象のメッセージの自分のクリップの一覧を返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageClipsApiResponse"/>&gt;</returns>
        Task<IGetMessageClipsApiResponse> GetMessageClipsAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のクリップを取得
        /// </summary>
        /// <remarks>
        /// 対象のメッセージの自分のクリップの一覧を返します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageClipsApiResponse"/>?&gt;</returns>
        Task<IGetMessageClipsApiResponse?> GetMessageClipsOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージのスタンプリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したメッセージに押されているスタンプのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageStampsApiResponse"/>&gt;</returns>
        Task<IGetMessageStampsApiResponse> GetMessageStampsAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージのスタンプリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したメッセージに押されているスタンプのリストを取得します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageStampsApiResponse"/>?&gt;</returns>
        Task<IGetMessageStampsApiResponse?> GetMessageStampsOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルメッセージのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルのメッセージのリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessagesApiResponse"/>&gt;</returns>
        Task<IGetMessagesApiResponse> GetMessagesAsync(Guid channelId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルメッセージのリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルのメッセージのリストを取得します。
        /// </remarks>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessagesApiResponse"/>?&gt;</returns>
        Task<IGetMessagesApiResponse?> GetMessagesOrDefaultAsync(Guid channelId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ピン留めを取得
        /// </summary>
        /// <remarks>
        /// 指定したメッセージのピン留め情報を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPinApiResponse"/>&gt;</returns>
        Task<IGetPinApiResponse> GetPinAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ピン留めを取得
        /// </summary>
        /// <remarks>
        /// 指定したメッセージのピン留め情報を取得します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPinApiResponse"/>?&gt;</returns>
        Task<IGetPinApiResponse?> GetPinOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ダイレクトメッセージを送信
        /// </summary>
        /// <remarks>
        /// 指定したユーザーにダイレクトメッセージを送信します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostDirectMessageApiResponse"/>&gt;</returns>
        Task<IPostDirectMessageApiResponse> PostDirectMessageAsync(Guid userId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ダイレクトメッセージを送信
        /// </summary>
        /// <remarks>
        /// 指定したユーザーにダイレクトメッセージを送信します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostDirectMessageApiResponse"/>?&gt;</returns>
        Task<IPostDirectMessageApiResponse?> PostDirectMessageOrDefaultAsync(Guid userId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルにメッセージを投稿
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。 アーカイブされているチャンネルに投稿することはできません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostMessageApiResponse"/>&gt;</returns>
        Task<IPostMessageApiResponse> PostMessageAsync(Guid channelId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// チャンネルにメッセージを投稿
        /// </summary>
        /// <remarks>
        /// 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。 アーカイブされているチャンネルに投稿することはできません。
        /// </remarks>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostMessageApiResponse"/>?&gt;</returns>
        Task<IPostMessageApiResponse?> PostMessageOrDefaultAsync(Guid channelId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを消す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージから指定した自身が押したスタンプを削除します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMessageStampApiResponse"/>&gt;</returns>
        Task<IRemoveMessageStampApiResponse> RemoveMessageStampAsync(Guid messageId, Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// スタンプを消す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージから指定した自身が押したスタンプを削除します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMessageStampApiResponse"/>?&gt;</returns>
        Task<IRemoveMessageStampApiResponse?> RemoveMessageStampOrDefaultAsync(Guid messageId, Guid stampId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ピン留めを外す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージのピン留めを外します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemovePinApiResponse"/>&gt;</returns>
        Task<IRemovePinApiResponse> RemovePinAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ピン留めを外す
        /// </summary>
        /// <remarks>
        /// 指定したメッセージのピン留めを外します。
        /// </remarks>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemovePinApiResponse"/>?&gt;</returns>
        Task<IRemovePinApiResponse?> RemovePinOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージを検索
        /// </summary>
        /// <remarks>
        /// メッセージを検索します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="word">検索ワード Simple-Query-String-Syntaxをパースして検索します  (optional)</param>
        /// <param name="after">投稿日時が指定日時より後 (optional)</param>
        /// <param name="before">投稿日時が指定日時より前 (optional)</param>
        /// <param name="varIn">メッセージが投稿されたチャンネル (optional)</param>
        /// <param name="to">メンションされたユーザー (optional)</param>
        /// <param name="from">メッセージを投稿したユーザー (optional)</param>
        /// <param name="citation">引用しているメッセージ (optional)</param>
        /// <param name="bot">メッセージを投稿したユーザーがBotかどうか (optional)</param>
        /// <param name="hasURL">メッセージがURLを含むか (optional)</param>
        /// <param name="hasAttachments">メッセージが添付ファイルを含むか (optional)</param>
        /// <param name="hasImage">メッセージが画像を含むか (optional)</param>
        /// <param name="hasVideo">メッセージが動画を含むか (optional)</param>
        /// <param name="hasAudio">メッセージが音声ファイルを含むか (optional)</param>
        /// <param name="limit">検索結果から取得するメッセージの最大件数 (optional)</param>
        /// <param name="offset">検索結果から取得するメッセージのオフセット (optional)</param>
        /// <param name="sort">ソート順 (作成日時が新しい &#x60;createdAt&#x60;, 作成日時が古い &#x60;-createdAt&#x60;, 更新日時が新しい &#x60;updatedAt&#x60;, 更新日時が古い &#x60;-updatedAt&#x60;) (optional, default to -createdAt)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchMessagesApiResponse"/>&gt;</returns>
        Task<ISearchMessagesApiResponse> SearchMessagesAsync(Option<string> word = default, Option<DateTimeOffset> after = default, Option<DateTimeOffset> before = default, Option<Guid> varIn = default, Option<List<Guid>> to = default, Option<List<Guid>> from = default, Option<Guid> citation = default, Option<bool> bot = default, Option<bool> hasURL = default, Option<bool> hasAttachments = default, Option<bool> hasImage = default, Option<bool> hasVideo = default, Option<bool> hasAudio = default, Option<int> limit = default, Option<int> offset = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// メッセージを検索
        /// </summary>
        /// <remarks>
        /// メッセージを検索します。
        /// </remarks>
        /// <param name="word">検索ワード Simple-Query-String-Syntaxをパースして検索します  (optional)</param>
        /// <param name="after">投稿日時が指定日時より後 (optional)</param>
        /// <param name="before">投稿日時が指定日時より前 (optional)</param>
        /// <param name="varIn">メッセージが投稿されたチャンネル (optional)</param>
        /// <param name="to">メンションされたユーザー (optional)</param>
        /// <param name="from">メッセージを投稿したユーザー (optional)</param>
        /// <param name="citation">引用しているメッセージ (optional)</param>
        /// <param name="bot">メッセージを投稿したユーザーがBotかどうか (optional)</param>
        /// <param name="hasURL">メッセージがURLを含むか (optional)</param>
        /// <param name="hasAttachments">メッセージが添付ファイルを含むか (optional)</param>
        /// <param name="hasImage">メッセージが画像を含むか (optional)</param>
        /// <param name="hasVideo">メッセージが動画を含むか (optional)</param>
        /// <param name="hasAudio">メッセージが音声ファイルを含むか (optional)</param>
        /// <param name="limit">検索結果から取得するメッセージの最大件数 (optional)</param>
        /// <param name="offset">検索結果から取得するメッセージのオフセット (optional)</param>
        /// <param name="sort">ソート順 (作成日時が新しい &#x60;createdAt&#x60;, 作成日時が古い &#x60;-createdAt&#x60;, 更新日時が新しい &#x60;updatedAt&#x60;, 更新日時が古い &#x60;-updatedAt&#x60;) (optional, default to -createdAt)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchMessagesApiResponse"/>?&gt;</returns>
        Task<ISearchMessagesApiResponse?> SearchMessagesOrDefaultAsync(Option<string> word = default, Option<DateTimeOffset> after = default, Option<DateTimeOffset> before = default, Option<Guid> varIn = default, Option<List<Guid>> to = default, Option<List<Guid>> from = default, Option<Guid> citation = default, Option<bool> bot = default, Option<bool> hasURL = default, Option<bool> hasAttachments = default, Option<bool> hasImage = default, Option<bool> hasVideo = default, Option<bool> hasAudio = default, Option<int> limit = default, Option<int> offset = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddMessageStampApiResponse"/>
    /// </summary>
    public interface IAddMessageStampApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ICreatePinApiResponse"/>
    /// </summary>
    public interface ICreatePinApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.MessagePin?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteMessageApiResponse"/>
    /// </summary>
    public interface IDeleteMessageApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IEditMessageApiResponse"/>
    /// </summary>
    public interface IEditMessageApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetDirectMessagesApiResponse"/>
    /// </summary>
    public interface IGetDirectMessagesApiResponse : Traq.Client.IApiResponse, IOk<List<Message>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetMessageApiResponse"/>
    /// </summary>
    public interface IGetMessageApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.Message?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetMessageClipsApiResponse"/>
    /// </summary>
    public interface IGetMessageClipsApiResponse : Traq.Client.IApiResponse, IOk<List<MessageClip>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetMessageStampsApiResponse"/>
    /// </summary>
    public interface IGetMessageStampsApiResponse : Traq.Client.IApiResponse, IOk<List<MessageStamp>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetMessagesApiResponse"/>
    /// </summary>
    public interface IGetMessagesApiResponse : Traq.Client.IApiResponse, IOk<List<Message>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetPinApiResponse"/>
    /// </summary>
    public interface IGetPinApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.MessagePin?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IPostDirectMessageApiResponse"/>
    /// </summary>
    public interface IPostDirectMessageApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.Message?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IPostMessageApiResponse"/>
    /// </summary>
    public interface IPostMessageApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.Message?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveMessageStampApiResponse"/>
    /// </summary>
    public interface IRemoveMessageStampApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IRemovePinApiResponse"/>
    /// </summary>
    public interface IRemovePinApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ISearchMessagesApiResponse"/>
    /// </summary>
    public interface ISearchMessagesApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.MessageSearchResult?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 503 ServiceUnavailable
        /// </summary>
        /// <returns></returns>
        bool IsServiceUnavailable { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class MessageApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddMessageStamp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddMessageStamp;

        internal void ExecuteOnAddMessageStamp(MessageApi.AddMessageStampApiResponse apiResponse)
        {
            OnAddMessageStamp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddMessageStamp(Exception exception)
        {
            OnErrorAddMessageStamp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreatePin;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreatePin;

        internal void ExecuteOnCreatePin(MessageApi.CreatePinApiResponse apiResponse)
        {
            OnCreatePin?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreatePin(Exception exception)
        {
            OnErrorCreatePin?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteMessage;

        internal void ExecuteOnDeleteMessage(MessageApi.DeleteMessageApiResponse apiResponse)
        {
            OnDeleteMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteMessage(Exception exception)
        {
            OnErrorDeleteMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditMessage;

        internal void ExecuteOnEditMessage(MessageApi.EditMessageApiResponse apiResponse)
        {
            OnEditMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditMessage(Exception exception)
        {
            OnErrorEditMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetDirectMessages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetDirectMessages;

        internal void ExecuteOnGetDirectMessages(MessageApi.GetDirectMessagesApiResponse apiResponse)
        {
            OnGetDirectMessages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetDirectMessages(Exception exception)
        {
            OnErrorGetDirectMessages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMessage;

        internal void ExecuteOnGetMessage(MessageApi.GetMessageApiResponse apiResponse)
        {
            OnGetMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMessage(Exception exception)
        {
            OnErrorGetMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMessageClips;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMessageClips;

        internal void ExecuteOnGetMessageClips(MessageApi.GetMessageClipsApiResponse apiResponse)
        {
            OnGetMessageClips?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMessageClips(Exception exception)
        {
            OnErrorGetMessageClips?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMessageStamps;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMessageStamps;

        internal void ExecuteOnGetMessageStamps(MessageApi.GetMessageStampsApiResponse apiResponse)
        {
            OnGetMessageStamps?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMessageStamps(Exception exception)
        {
            OnErrorGetMessageStamps?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMessages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMessages;

        internal void ExecuteOnGetMessages(MessageApi.GetMessagesApiResponse apiResponse)
        {
            OnGetMessages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMessages(Exception exception)
        {
            OnErrorGetMessages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetPin;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetPin;

        internal void ExecuteOnGetPin(MessageApi.GetPinApiResponse apiResponse)
        {
            OnGetPin?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetPin(Exception exception)
        {
            OnErrorGetPin?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostDirectMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostDirectMessage;

        internal void ExecuteOnPostDirectMessage(MessageApi.PostDirectMessageApiResponse apiResponse)
        {
            OnPostDirectMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostDirectMessage(Exception exception)
        {
            OnErrorPostDirectMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPostMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPostMessage;

        internal void ExecuteOnPostMessage(MessageApi.PostMessageApiResponse apiResponse)
        {
            OnPostMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPostMessage(Exception exception)
        {
            OnErrorPostMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveMessageStamp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveMessageStamp;

        internal void ExecuteOnRemoveMessageStamp(MessageApi.RemoveMessageStampApiResponse apiResponse)
        {
            OnRemoveMessageStamp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveMessageStamp(Exception exception)
        {
            OnErrorRemoveMessageStamp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemovePin;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemovePin;

        internal void ExecuteOnRemovePin(MessageApi.RemovePinApiResponse apiResponse)
        {
            OnRemovePin?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemovePin(Exception exception)
        {
            OnErrorRemovePin?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSearchMessages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSearchMessages;

        internal void ExecuteOnSearchMessages(MessageApi.SearchMessagesApiResponse apiResponse)
        {
            OnSearchMessages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchMessages(Exception exception)
        {
            OnErrorSearchMessages?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class MessageApi : IMessageApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<MessageApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public MessageApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessageApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MessageApi(ILogger<MessageApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, MessageApiEvents messageApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<MessageApi>();
            HttpClient = httpClient;
            Events = messageApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatAddMessageStamp(ref Guid messageId, ref Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postMessageStampRequest"></param>
        /// <returns></returns>
        private void ValidateAddMessageStamp(Option<PostMessageStampRequest> postMessageStampRequest)
        {
            if (postMessageStampRequest.IsSet && postMessageStampRequest.Value == null)
                throw new ArgumentNullException(nameof(postMessageStampRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        /// <param name="postMessageStampRequest"></param>
        private void AfterAddMessageStampDefaultImplementation(IAddMessageStampApiResponse apiResponseLocalVar, Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest)
        {
            bool suppressDefaultLog = false;
            AfterAddMessageStamp(ref suppressDefaultLog, apiResponseLocalVar, messageId, stampId, postMessageStampRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        /// <param name="postMessageStampRequest"></param>
        partial void AfterAddMessageStamp(ref bool suppressDefaultLog, IAddMessageStampApiResponse apiResponseLocalVar, Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        /// <param name="postMessageStampRequest"></param>
        private void OnErrorAddMessageStampDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorAddMessageStamp(ref suppressDefaultLog, exception, pathFormat, path, messageId, stampId, postMessageStampRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        /// <param name="postMessageStampRequest"></param>
        partial void OnErrorAddMessageStamp(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest);

        /// <summary>
        /// スタンプを押す 指定したメッセージに指定したスタンプを押します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="postMessageStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMessageStampApiResponse"/>&gt;</returns>
        public async Task<IAddMessageStampApiResponse?> AddMessageStampOrDefaultAsync(Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddMessageStampAsync(messageId, stampId, postMessageStampRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプを押す 指定したメッセージに指定したスタンプを押します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="postMessageStampRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMessageStampApiResponse"/>&gt;</returns>
        public async Task<IAddMessageStampApiResponse> AddMessageStampAsync(Guid messageId, Guid stampId, Option<PostMessageStampRequest> postMessageStampRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddMessageStamp(postMessageStampRequest);

                FormatAddMessageStamp(ref messageId, ref stampId, postMessageStampRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/stamps/{stampId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    if (postMessageStampRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postMessageStampRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postMessageStampRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AddMessageStampApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddMessageStampApiResponse>();

                        AddMessageStampApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/stamps/{stampId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddMessageStampDefaultImplementation(apiResponseLocalVar, messageId, stampId, postMessageStampRequest);

                        Events.ExecuteOnAddMessageStamp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddMessageStampDefaultImplementation(e, "/messages/{messageId}/stamps/{stampId}", uriBuilderLocalVar.Path, messageId, stampId, postMessageStampRequest);
                Events.ExecuteOnErrorAddMessageStamp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddMessageStampApiResponse"/>
        /// </summary>
        public partial class AddMessageStampApiResponse : Traq.Client.ApiResponse, IAddMessageStampApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddMessageStampApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddMessageStampApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddMessageStampApiResponse(ILogger<AddMessageStampApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreatePin(ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterCreatePinDefaultImplementation(ICreatePinApiResponse apiResponseLocalVar, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterCreatePin(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterCreatePin(ref bool suppressDefaultLog, ICreatePinApiResponse apiResponseLocalVar, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        private void OnErrorCreatePinDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorCreatePin(ref suppressDefaultLog, exception, pathFormat, path, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        partial void OnErrorCreatePin(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId);

        /// <summary>
        /// ピン留めする 指定したメッセージをピン留めします。 アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePinApiResponse"/>&gt;</returns>
        public async Task<ICreatePinApiResponse?> CreatePinOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreatePinAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ピン留めする 指定したメッセージをピン留めします。 アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreatePinApiResponse"/>&gt;</returns>
        public async Task<ICreatePinApiResponse> CreatePinAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatCreatePin(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/pin";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreatePinApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreatePinApiResponse>();

                        CreatePinApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/pin", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreatePinDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnCreatePin(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreatePinDefaultImplementation(e, "/messages/{messageId}/pin", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorCreatePin(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreatePinApiResponse"/>
        /// </summary>
        public partial class CreatePinApiResponse : Traq.Client.ApiResponse, ICreatePinApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreatePinApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreatePinApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreatePinApiResponse(ILogger<CreatePinApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.MessagePin? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.MessagePin>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.MessagePin? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteMessage(ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterDeleteMessageDefaultImplementation(IDeleteMessageApiResponse apiResponseLocalVar, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteMessage(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterDeleteMessage(ref bool suppressDefaultLog, IDeleteMessageApiResponse apiResponseLocalVar, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        private void OnErrorDeleteMessageDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorDeleteMessage(ref suppressDefaultLog, exception, pathFormat, path, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        partial void OnErrorDeleteMessage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId);

        /// <summary>
        /// メッセージを削除 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteMessageApiResponse"/>&gt;</returns>
        public async Task<IDeleteMessageApiResponse?> DeleteMessageOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteMessageAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// メッセージを削除 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteMessageApiResponse"/>&gt;</returns>
        public async Task<IDeleteMessageApiResponse> DeleteMessageAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteMessage(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteMessageApiResponse>();

                        DeleteMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteMessageDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnDeleteMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteMessageDefaultImplementation(e, "/messages/{messageId}", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorDeleteMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteMessageApiResponse"/>
        /// </summary>
        public partial class DeleteMessageApiResponse : Traq.Client.ApiResponse, IDeleteMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteMessageApiResponse(ILogger<DeleteMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditMessage(ref Guid messageId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postMessageRequest"></param>
        /// <returns></returns>
        private void ValidateEditMessage(Option<PostMessageRequest> postMessageRequest)
        {
            if (postMessageRequest.IsSet && postMessageRequest.Value == null)
                throw new ArgumentNullException(nameof(postMessageRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="postMessageRequest"></param>
        private void AfterEditMessageDefaultImplementation(IEditMessageApiResponse apiResponseLocalVar, Guid messageId, Option<PostMessageRequest> postMessageRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditMessage(ref suppressDefaultLog, apiResponseLocalVar, messageId, postMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="postMessageRequest"></param>
        partial void AfterEditMessage(ref bool suppressDefaultLog, IEditMessageApiResponse apiResponseLocalVar, Guid messageId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="postMessageRequest"></param>
        private void OnErrorEditMessageDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId, Option<PostMessageRequest> postMessageRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditMessage(ref suppressDefaultLog, exception, pathFormat, path, messageId, postMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="postMessageRequest"></param>
        partial void OnErrorEditMessage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// メッセージを編集 指定したメッセージを編集します。 自身が投稿したメッセージのみ編集することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditMessageApiResponse"/>&gt;</returns>
        public async Task<IEditMessageApiResponse?> EditMessageOrDefaultAsync(Guid messageId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditMessageAsync(messageId, postMessageRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// メッセージを編集 指定したメッセージを編集します。 自身が投稿したメッセージのみ編集することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditMessageApiResponse"/>&gt;</returns>
        public async Task<IEditMessageApiResponse> EditMessageAsync(Guid messageId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditMessage(postMessageRequest);

                FormatEditMessage(ref messageId, postMessageRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    if (postMessageRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postMessageRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postMessageRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditMessageApiResponse>();

                        EditMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditMessageDefaultImplementation(apiResponseLocalVar, messageId, postMessageRequest);

                        Events.ExecuteOnEditMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditMessageDefaultImplementation(e, "/messages/{messageId}", uriBuilderLocalVar.Path, messageId, postMessageRequest);
                Events.ExecuteOnErrorEditMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditMessageApiResponse"/>
        /// </summary>
        public partial class EditMessageApiResponse : Traq.Client.ApiResponse, IEditMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditMessageApiResponse(ILogger<EditMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetDirectMessages(ref Guid userId, ref Option<int> limit, ref Option<int> offset, ref Option<DateTimeOffset> since, ref Option<DateTimeOffset> until, ref Option<bool> inclusive, ref Option<string> order);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="order"></param>
        /// <returns></returns>
        private void ValidateGetDirectMessages(Option<string> order)
        {
            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        private void AfterGetDirectMessagesDefaultImplementation(IGetDirectMessagesApiResponse apiResponseLocalVar, Guid userId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order)
        {
            bool suppressDefaultLog = false;
            AfterGetDirectMessages(ref suppressDefaultLog, apiResponseLocalVar, userId, limit, offset, since, until, inclusive, order);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        partial void AfterGetDirectMessages(ref bool suppressDefaultLog, IGetDirectMessagesApiResponse apiResponseLocalVar, Guid userId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        private void OnErrorGetDirectMessagesDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order)
        {
            bool suppressDefaultLog = false;
            OnErrorGetDirectMessages(ref suppressDefaultLog, exception, pathFormat, path, userId, limit, offset, since, until, inclusive, order);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        partial void OnErrorGetDirectMessages(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order);

        /// <summary>
        /// ダイレクトメッセージのリストを取得 指定したユーザーとのダイレクトメッセージのリストを取得します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDirectMessagesApiResponse"/>&gt;</returns>
        public async Task<IGetDirectMessagesApiResponse?> GetDirectMessagesOrDefaultAsync(Guid userId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetDirectMessagesAsync(userId, limit, offset, since, until, inclusive, order, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ダイレクトメッセージのリストを取得 指定したユーザーとのダイレクトメッセージのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetDirectMessagesApiResponse"/>&gt;</returns>
        public async Task<IGetDirectMessagesApiResponse> GetDirectMessagesAsync(Guid userId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetDirectMessages(order);

                FormatGetDirectMessages(ref userId, ref limit, ref offset, ref since, ref until, ref inclusive, ref order);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/messages";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (until.IsSet)
                        parseQueryStringLocalVar["until"] = ClientUtils.ParameterToString(until.Value);

                    if (inclusive.IsSet)
                        parseQueryStringLocalVar["inclusive"] = ClientUtils.ParameterToString(inclusive.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetDirectMessagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetDirectMessagesApiResponse>();

                        GetDirectMessagesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetDirectMessagesDefaultImplementation(apiResponseLocalVar, userId, limit, offset, since, until, inclusive, order);

                        Events.ExecuteOnGetDirectMessages(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetDirectMessagesDefaultImplementation(e, "/users/{userId}/messages", uriBuilderLocalVar.Path, userId, limit, offset, since, until, inclusive, order);
                Events.ExecuteOnErrorGetDirectMessages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetDirectMessagesApiResponse"/>
        /// </summary>
        public partial class GetDirectMessagesApiResponse : Traq.Client.ApiResponse, IGetDirectMessagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetDirectMessagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetDirectMessagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetDirectMessagesApiResponse(ILogger<GetDirectMessagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Message>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Message>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Message>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMessage(ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterGetMessageDefaultImplementation(IGetMessageApiResponse apiResponseLocalVar, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterGetMessage(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterGetMessage(ref bool suppressDefaultLog, IGetMessageApiResponse apiResponseLocalVar, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        private void OnErrorGetMessageDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMessage(ref suppressDefaultLog, exception, pathFormat, path, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        partial void OnErrorGetMessage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId);

        /// <summary>
        /// メッセージを取得 指定したメッセージを取得します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageApiResponse"/>&gt;</returns>
        public async Task<IGetMessageApiResponse?> GetMessageOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMessageAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// メッセージを取得 指定したメッセージを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageApiResponse"/>&gt;</returns>
        public async Task<IGetMessageApiResponse> GetMessageAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetMessage(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMessageApiResponse>();

                        GetMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMessageDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnGetMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMessageDefaultImplementation(e, "/messages/{messageId}", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorGetMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMessageApiResponse"/>
        /// </summary>
        public partial class GetMessageApiResponse : Traq.Client.ApiResponse, IGetMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessageApiResponse(ILogger<GetMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.Message? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.Message>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.Message? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMessageClips(ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterGetMessageClipsDefaultImplementation(IGetMessageClipsApiResponse apiResponseLocalVar, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterGetMessageClips(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterGetMessageClips(ref bool suppressDefaultLog, IGetMessageClipsApiResponse apiResponseLocalVar, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        private void OnErrorGetMessageClipsDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMessageClips(ref suppressDefaultLog, exception, pathFormat, path, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        partial void OnErrorGetMessageClips(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId);

        /// <summary>
        /// 自分のクリップを取得 対象のメッセージの自分のクリップの一覧を返します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageClipsApiResponse"/>&gt;</returns>
        public async Task<IGetMessageClipsApiResponse?> GetMessageClipsOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMessageClipsAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 自分のクリップを取得 対象のメッセージの自分のクリップの一覧を返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageClipsApiResponse"/>&gt;</returns>
        public async Task<IGetMessageClipsApiResponse> GetMessageClipsAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetMessageClips(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/clips";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMessageClipsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMessageClipsApiResponse>();

                        GetMessageClipsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/clips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMessageClipsDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnGetMessageClips(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMessageClipsDefaultImplementation(e, "/messages/{messageId}/clips", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorGetMessageClips(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMessageClipsApiResponse"/>
        /// </summary>
        public partial class GetMessageClipsApiResponse : Traq.Client.ApiResponse, IGetMessageClipsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMessageClipsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMessageClipsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessageClipsApiResponse(ILogger<GetMessageClipsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MessageClip>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MessageClip>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MessageClip>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMessageStamps(ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterGetMessageStampsDefaultImplementation(IGetMessageStampsApiResponse apiResponseLocalVar, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterGetMessageStamps(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterGetMessageStamps(ref bool suppressDefaultLog, IGetMessageStampsApiResponse apiResponseLocalVar, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        private void OnErrorGetMessageStampsDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMessageStamps(ref suppressDefaultLog, exception, pathFormat, path, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        partial void OnErrorGetMessageStamps(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId);

        /// <summary>
        /// メッセージのスタンプリストを取得 指定したメッセージに押されているスタンプのリストを取得します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageStampsApiResponse"/>&gt;</returns>
        public async Task<IGetMessageStampsApiResponse?> GetMessageStampsOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMessageStampsAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// メッセージのスタンプリストを取得 指定したメッセージに押されているスタンプのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageStampsApiResponse"/>&gt;</returns>
        public async Task<IGetMessageStampsApiResponse> GetMessageStampsAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetMessageStamps(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/stamps";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMessageStampsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMessageStampsApiResponse>();

                        GetMessageStampsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/stamps", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMessageStampsDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnGetMessageStamps(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMessageStampsDefaultImplementation(e, "/messages/{messageId}/stamps", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorGetMessageStamps(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMessageStampsApiResponse"/>
        /// </summary>
        public partial class GetMessageStampsApiResponse : Traq.Client.ApiResponse, IGetMessageStampsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMessageStampsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMessageStampsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessageStampsApiResponse(ILogger<GetMessageStampsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MessageStamp>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MessageStamp>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MessageStamp>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMessages(ref Guid channelId, ref Option<int> limit, ref Option<int> offset, ref Option<DateTimeOffset> since, ref Option<DateTimeOffset> until, ref Option<bool> inclusive, ref Option<string> order);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="order"></param>
        /// <returns></returns>
        private void ValidateGetMessages(Option<string> order)
        {
            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        private void AfterGetMessagesDefaultImplementation(IGetMessagesApiResponse apiResponseLocalVar, Guid channelId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order)
        {
            bool suppressDefaultLog = false;
            AfterGetMessages(ref suppressDefaultLog, apiResponseLocalVar, channelId, limit, offset, since, until, inclusive, order);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        partial void AfterGetMessages(ref bool suppressDefaultLog, IGetMessagesApiResponse apiResponseLocalVar, Guid channelId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        private void OnErrorGetMessagesDefaultImplementation(Exception exception, string pathFormat, string path, Guid channelId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMessages(ref suppressDefaultLog, exception, pathFormat, path, channelId, limit, offset, since, until, inclusive, order);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="since"></param>
        /// <param name="until"></param>
        /// <param name="inclusive"></param>
        /// <param name="order"></param>
        partial void OnErrorGetMessages(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid channelId, Option<int> limit, Option<int> offset, Option<DateTimeOffset> since, Option<DateTimeOffset> until, Option<bool> inclusive, Option<string> order);

        /// <summary>
        /// チャンネルメッセージのリストを取得 指定したチャンネルのメッセージのリストを取得します。
        /// </summary>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessagesApiResponse"/>&gt;</returns>
        public async Task<IGetMessagesApiResponse?> GetMessagesOrDefaultAsync(Guid channelId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMessagesAsync(channelId, limit, offset, since, until, inclusive, order, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// チャンネルメッセージのリストを取得 指定したチャンネルのメッセージのリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="limit">取得する件数 (optional)</param>
        /// <param name="offset">取得するオフセット (optional, default to 0)</param>
        /// <param name="since">取得する時間範囲の開始日時 (optional, default to &quot;0000-01-01T00:00Z&quot;)</param>
        /// <param name="until">取得する時間範囲の終了日時 (optional)</param>
        /// <param name="inclusive">範囲の端を含めるかどうか (optional, default to false)</param>
        /// <param name="order">昇順か降順か (optional, default to desc)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessagesApiResponse"/>&gt;</returns>
        public async Task<IGetMessagesApiResponse> GetMessagesAsync(Guid channelId, Option<int> limit = default, Option<int> offset = default, Option<DateTimeOffset> since = default, Option<DateTimeOffset> until = default, Option<bool> inclusive = default, Option<string> order = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetMessages(order);

                FormatGetMessages(ref channelId, ref limit, ref offset, ref since, ref until, ref inclusive, ref order);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/channels/{channelId}/messages";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BchannelId%7D", Uri.EscapeDataString(channelId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (since.IsSet)
                        parseQueryStringLocalVar["since"] = ClientUtils.ParameterToString(since.Value);

                    if (until.IsSet)
                        parseQueryStringLocalVar["until"] = ClientUtils.ParameterToString(until.Value);

                    if (inclusive.IsSet)
                        parseQueryStringLocalVar["inclusive"] = ClientUtils.ParameterToString(inclusive.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMessagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMessagesApiResponse>();

                        GetMessagesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channels/{channelId}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMessagesDefaultImplementation(apiResponseLocalVar, channelId, limit, offset, since, until, inclusive, order);

                        Events.ExecuteOnGetMessages(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMessagesDefaultImplementation(e, "/channels/{channelId}/messages", uriBuilderLocalVar.Path, channelId, limit, offset, since, until, inclusive, order);
                Events.ExecuteOnErrorGetMessages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMessagesApiResponse"/>
        /// </summary>
        public partial class GetMessagesApiResponse : Traq.Client.ApiResponse, IGetMessagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMessagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMessagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessagesApiResponse(ILogger<GetMessagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Message>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Message>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Message>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetPin(ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterGetPinDefaultImplementation(IGetPinApiResponse apiResponseLocalVar, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterGetPin(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterGetPin(ref bool suppressDefaultLog, IGetPinApiResponse apiResponseLocalVar, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        private void OnErrorGetPinDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetPin(ref suppressDefaultLog, exception, pathFormat, path, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        partial void OnErrorGetPin(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId);

        /// <summary>
        /// ピン留めを取得 指定したメッセージのピン留め情報を取得します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPinApiResponse"/>&gt;</returns>
        public async Task<IGetPinApiResponse?> GetPinOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetPinAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ピン留めを取得 指定したメッセージのピン留め情報を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetPinApiResponse"/>&gt;</returns>
        public async Task<IGetPinApiResponse> GetPinAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetPin(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/pin";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetPinApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetPinApiResponse>();

                        GetPinApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/pin", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetPinDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnGetPin(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetPinDefaultImplementation(e, "/messages/{messageId}/pin", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorGetPin(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetPinApiResponse"/>
        /// </summary>
        public partial class GetPinApiResponse : Traq.Client.ApiResponse, IGetPinApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetPinApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetPinApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetPinApiResponse(ILogger<GetPinApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.MessagePin? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.MessagePin>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.MessagePin? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostDirectMessage(ref Guid userId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postMessageRequest"></param>
        /// <returns></returns>
        private void ValidatePostDirectMessage(Option<PostMessageRequest> postMessageRequest)
        {
            if (postMessageRequest.IsSet && postMessageRequest.Value == null)
                throw new ArgumentNullException(nameof(postMessageRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="postMessageRequest"></param>
        private void AfterPostDirectMessageDefaultImplementation(IPostDirectMessageApiResponse apiResponseLocalVar, Guid userId, Option<PostMessageRequest> postMessageRequest)
        {
            bool suppressDefaultLog = false;
            AfterPostDirectMessage(ref suppressDefaultLog, apiResponseLocalVar, userId, postMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="postMessageRequest"></param>
        partial void AfterPostDirectMessage(ref bool suppressDefaultLog, IPostDirectMessageApiResponse apiResponseLocalVar, Guid userId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="postMessageRequest"></param>
        private void OnErrorPostDirectMessageDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Option<PostMessageRequest> postMessageRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorPostDirectMessage(ref suppressDefaultLog, exception, pathFormat, path, userId, postMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="postMessageRequest"></param>
        partial void OnErrorPostDirectMessage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// ダイレクトメッセージを送信 指定したユーザーにダイレクトメッセージを送信します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostDirectMessageApiResponse"/>&gt;</returns>
        public async Task<IPostDirectMessageApiResponse?> PostDirectMessageOrDefaultAsync(Guid userId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostDirectMessageAsync(userId, postMessageRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ダイレクトメッセージを送信 指定したユーザーにダイレクトメッセージを送信します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostDirectMessageApiResponse"/>&gt;</returns>
        public async Task<IPostDirectMessageApiResponse> PostDirectMessageAsync(Guid userId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostDirectMessage(postMessageRequest);

                FormatPostDirectMessage(ref userId, postMessageRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/messages";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    if (postMessageRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postMessageRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postMessageRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostDirectMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostDirectMessageApiResponse>();

                        PostDirectMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostDirectMessageDefaultImplementation(apiResponseLocalVar, userId, postMessageRequest);

                        Events.ExecuteOnPostDirectMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostDirectMessageDefaultImplementation(e, "/users/{userId}/messages", uriBuilderLocalVar.Path, userId, postMessageRequest);
                Events.ExecuteOnErrorPostDirectMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostDirectMessageApiResponse"/>
        /// </summary>
        public partial class PostDirectMessageApiResponse : Traq.Client.ApiResponse, IPostDirectMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostDirectMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostDirectMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostDirectMessageApiResponse(ILogger<PostDirectMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.Message? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.Message>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.Message? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPostMessage(ref Guid channelId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postMessageRequest"></param>
        /// <returns></returns>
        private void ValidatePostMessage(Option<PostMessageRequest> postMessageRequest)
        {
            if (postMessageRequest.IsSet && postMessageRequest.Value == null)
                throw new ArgumentNullException(nameof(postMessageRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="postMessageRequest"></param>
        private void AfterPostMessageDefaultImplementation(IPostMessageApiResponse apiResponseLocalVar, Guid channelId, Option<PostMessageRequest> postMessageRequest)
        {
            bool suppressDefaultLog = false;
            AfterPostMessage(ref suppressDefaultLog, apiResponseLocalVar, channelId, postMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="channelId"></param>
        /// <param name="postMessageRequest"></param>
        partial void AfterPostMessage(ref bool suppressDefaultLog, IPostMessageApiResponse apiResponseLocalVar, Guid channelId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="postMessageRequest"></param>
        private void OnErrorPostMessageDefaultImplementation(Exception exception, string pathFormat, string path, Guid channelId, Option<PostMessageRequest> postMessageRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorPostMessage(ref suppressDefaultLog, exception, pathFormat, path, channelId, postMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="channelId"></param>
        /// <param name="postMessageRequest"></param>
        partial void OnErrorPostMessage(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid channelId, Option<PostMessageRequest> postMessageRequest);

        /// <summary>
        /// チャンネルにメッセージを投稿 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。 アーカイブされているチャンネルに投稿することはできません。
        /// </summary>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostMessageApiResponse"/>&gt;</returns>
        public async Task<IPostMessageApiResponse?> PostMessageOrDefaultAsync(Guid channelId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PostMessageAsync(channelId, postMessageRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// チャンネルにメッセージを投稿 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。 アーカイブされているチャンネルに投稿することはできません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="channelId">チャンネルUUID</param>
        /// <param name="postMessageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPostMessageApiResponse"/>&gt;</returns>
        public async Task<IPostMessageApiResponse> PostMessageAsync(Guid channelId, Option<PostMessageRequest> postMessageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePostMessage(postMessageRequest);

                FormatPostMessage(ref channelId, postMessageRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/channels/{channelId}/messages";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BchannelId%7D", Uri.EscapeDataString(channelId.ToString()));

                    if (postMessageRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postMessageRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postMessageRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PostMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PostMessageApiResponse>();

                        PostMessageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/channels/{channelId}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPostMessageDefaultImplementation(apiResponseLocalVar, channelId, postMessageRequest);

                        Events.ExecuteOnPostMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPostMessageDefaultImplementation(e, "/channels/{channelId}/messages", uriBuilderLocalVar.Path, channelId, postMessageRequest);
                Events.ExecuteOnErrorPostMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PostMessageApiResponse"/>
        /// </summary>
        public partial class PostMessageApiResponse : Traq.Client.ApiResponse, IPostMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PostMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PostMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PostMessageApiResponse(ILogger<PostMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.Message? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.Message>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.Message? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveMessageStamp(ref Guid messageId, ref Guid stampId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        private void AfterRemoveMessageStampDefaultImplementation(IRemoveMessageStampApiResponse apiResponseLocalVar, Guid messageId, Guid stampId)
        {
            bool suppressDefaultLog = false;
            AfterRemoveMessageStamp(ref suppressDefaultLog, apiResponseLocalVar, messageId, stampId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        partial void AfterRemoveMessageStamp(ref bool suppressDefaultLog, IRemoveMessageStampApiResponse apiResponseLocalVar, Guid messageId, Guid stampId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        private void OnErrorRemoveMessageStampDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId, Guid stampId)
        {
            bool suppressDefaultLog = false;
            OnErrorRemoveMessageStamp(ref suppressDefaultLog, exception, pathFormat, path, messageId, stampId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        /// <param name="stampId"></param>
        partial void OnErrorRemoveMessageStamp(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId, Guid stampId);

        /// <summary>
        /// スタンプを消す 指定したメッセージから指定した自身が押したスタンプを削除します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMessageStampApiResponse"/>&gt;</returns>
        public async Task<IRemoveMessageStampApiResponse?> RemoveMessageStampOrDefaultAsync(Guid messageId, Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveMessageStampAsync(messageId, stampId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// スタンプを消す 指定したメッセージから指定した自身が押したスタンプを削除します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="stampId">スタンプUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMessageStampApiResponse"/>&gt;</returns>
        public async Task<IRemoveMessageStampApiResponse> RemoveMessageStampAsync(Guid messageId, Guid stampId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRemoveMessageStamp(ref messageId, ref stampId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/stamps/{stampId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BstampId%7D", Uri.EscapeDataString(stampId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemoveMessageStampApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveMessageStampApiResponse>();

                        RemoveMessageStampApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/stamps/{stampId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemoveMessageStampDefaultImplementation(apiResponseLocalVar, messageId, stampId);

                        Events.ExecuteOnRemoveMessageStamp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveMessageStampDefaultImplementation(e, "/messages/{messageId}/stamps/{stampId}", uriBuilderLocalVar.Path, messageId, stampId);
                Events.ExecuteOnErrorRemoveMessageStamp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveMessageStampApiResponse"/>
        /// </summary>
        public partial class RemoveMessageStampApiResponse : Traq.Client.ApiResponse, IRemoveMessageStampApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveMessageStampApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveMessageStampApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveMessageStampApiResponse(ILogger<RemoveMessageStampApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemovePin(ref Guid messageId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        private void AfterRemovePinDefaultImplementation(IRemovePinApiResponse apiResponseLocalVar, Guid messageId)
        {
            bool suppressDefaultLog = false;
            AfterRemovePin(ref suppressDefaultLog, apiResponseLocalVar, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="messageId"></param>
        partial void AfterRemovePin(ref bool suppressDefaultLog, IRemovePinApiResponse apiResponseLocalVar, Guid messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        private void OnErrorRemovePinDefaultImplementation(Exception exception, string pathFormat, string path, Guid messageId)
        {
            bool suppressDefaultLog = false;
            OnErrorRemovePin(ref suppressDefaultLog, exception, pathFormat, path, messageId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="messageId"></param>
        partial void OnErrorRemovePin(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid messageId);

        /// <summary>
        /// ピン留めを外す 指定したメッセージのピン留めを外します。
        /// </summary>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemovePinApiResponse"/>&gt;</returns>
        public async Task<IRemovePinApiResponse?> RemovePinOrDefaultAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemovePinAsync(messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ピン留めを外す 指定したメッセージのピン留めを外します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="messageId">メッセージUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemovePinApiResponse"/>&gt;</returns>
        public async Task<IRemovePinApiResponse> RemovePinAsync(Guid messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRemovePin(ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages/{messageId}/pin";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BmessageId%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemovePinApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemovePinApiResponse>();

                        RemovePinApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages/{messageId}/pin", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemovePinDefaultImplementation(apiResponseLocalVar, messageId);

                        Events.ExecuteOnRemovePin(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemovePinDefaultImplementation(e, "/messages/{messageId}/pin", uriBuilderLocalVar.Path, messageId);
                Events.ExecuteOnErrorRemovePin(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemovePinApiResponse"/>
        /// </summary>
        public partial class RemovePinApiResponse : Traq.Client.ApiResponse, IRemovePinApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemovePinApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemovePinApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemovePinApiResponse(ILogger<RemovePinApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchMessages(ref Option<string> word, ref Option<DateTimeOffset> after, ref Option<DateTimeOffset> before, ref Option<Guid> varIn, Option<List<Guid>> to, Option<List<Guid>> from, ref Option<Guid> citation, ref Option<bool> bot, ref Option<bool> hasURL, ref Option<bool> hasAttachments, ref Option<bool> hasImage, ref Option<bool> hasVideo, ref Option<bool> hasAudio, ref Option<int> limit, ref Option<int> offset, ref Option<string> sort);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="word"></param>
        /// <param name="to"></param>
        /// <param name="from"></param>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateSearchMessages(Option<string> word, Option<List<Guid>> to, Option<List<Guid>> from, Option<string> sort)
        {
            if (word.IsSet && word.Value == null)
                throw new ArgumentNullException(nameof(word));

            if (to.IsSet && to.Value == null)
                throw new ArgumentNullException(nameof(to));

            if (from.IsSet && from.Value == null)
                throw new ArgumentNullException(nameof(from));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="word"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <param name="varIn"></param>
        /// <param name="to"></param>
        /// <param name="from"></param>
        /// <param name="citation"></param>
        /// <param name="bot"></param>
        /// <param name="hasURL"></param>
        /// <param name="hasAttachments"></param>
        /// <param name="hasImage"></param>
        /// <param name="hasVideo"></param>
        /// <param name="hasAudio"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="sort"></param>
        private void AfterSearchMessagesDefaultImplementation(ISearchMessagesApiResponse apiResponseLocalVar, Option<string> word, Option<DateTimeOffset> after, Option<DateTimeOffset> before, Option<Guid> varIn, Option<List<Guid>> to, Option<List<Guid>> from, Option<Guid> citation, Option<bool> bot, Option<bool> hasURL, Option<bool> hasAttachments, Option<bool> hasImage, Option<bool> hasVideo, Option<bool> hasAudio, Option<int> limit, Option<int> offset, Option<string> sort)
        {
            bool suppressDefaultLog = false;
            AfterSearchMessages(ref suppressDefaultLog, apiResponseLocalVar, word, after, before, varIn, to, from, citation, bot, hasURL, hasAttachments, hasImage, hasVideo, hasAudio, limit, offset, sort);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="word"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <param name="varIn"></param>
        /// <param name="to"></param>
        /// <param name="from"></param>
        /// <param name="citation"></param>
        /// <param name="bot"></param>
        /// <param name="hasURL"></param>
        /// <param name="hasAttachments"></param>
        /// <param name="hasImage"></param>
        /// <param name="hasVideo"></param>
        /// <param name="hasAudio"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="sort"></param>
        partial void AfterSearchMessages(ref bool suppressDefaultLog, ISearchMessagesApiResponse apiResponseLocalVar, Option<string> word, Option<DateTimeOffset> after, Option<DateTimeOffset> before, Option<Guid> varIn, Option<List<Guid>> to, Option<List<Guid>> from, Option<Guid> citation, Option<bool> bot, Option<bool> hasURL, Option<bool> hasAttachments, Option<bool> hasImage, Option<bool> hasVideo, Option<bool> hasAudio, Option<int> limit, Option<int> offset, Option<string> sort);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="word"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <param name="varIn"></param>
        /// <param name="to"></param>
        /// <param name="from"></param>
        /// <param name="citation"></param>
        /// <param name="bot"></param>
        /// <param name="hasURL"></param>
        /// <param name="hasAttachments"></param>
        /// <param name="hasImage"></param>
        /// <param name="hasVideo"></param>
        /// <param name="hasAudio"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="sort"></param>
        private void OnErrorSearchMessagesDefaultImplementation(Exception exception, string pathFormat, string path, Option<string> word, Option<DateTimeOffset> after, Option<DateTimeOffset> before, Option<Guid> varIn, Option<List<Guid>> to, Option<List<Guid>> from, Option<Guid> citation, Option<bool> bot, Option<bool> hasURL, Option<bool> hasAttachments, Option<bool> hasImage, Option<bool> hasVideo, Option<bool> hasAudio, Option<int> limit, Option<int> offset, Option<string> sort)
        {
            bool suppressDefaultLog = false;
            OnErrorSearchMessages(ref suppressDefaultLog, exception, pathFormat, path, word, after, before, varIn, to, from, citation, bot, hasURL, hasAttachments, hasImage, hasVideo, hasAudio, limit, offset, sort);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="word"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <param name="varIn"></param>
        /// <param name="to"></param>
        /// <param name="from"></param>
        /// <param name="citation"></param>
        /// <param name="bot"></param>
        /// <param name="hasURL"></param>
        /// <param name="hasAttachments"></param>
        /// <param name="hasImage"></param>
        /// <param name="hasVideo"></param>
        /// <param name="hasAudio"></param>
        /// <param name="limit"></param>
        /// <param name="offset"></param>
        /// <param name="sort"></param>
        partial void OnErrorSearchMessages(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<string> word, Option<DateTimeOffset> after, Option<DateTimeOffset> before, Option<Guid> varIn, Option<List<Guid>> to, Option<List<Guid>> from, Option<Guid> citation, Option<bool> bot, Option<bool> hasURL, Option<bool> hasAttachments, Option<bool> hasImage, Option<bool> hasVideo, Option<bool> hasAudio, Option<int> limit, Option<int> offset, Option<string> sort);

        /// <summary>
        /// メッセージを検索 メッセージを検索します。
        /// </summary>
        /// <param name="word">検索ワード Simple-Query-String-Syntaxをパースして検索します  (optional)</param>
        /// <param name="after">投稿日時が指定日時より後 (optional)</param>
        /// <param name="before">投稿日時が指定日時より前 (optional)</param>
        /// <param name="varIn">メッセージが投稿されたチャンネル (optional)</param>
        /// <param name="to">メンションされたユーザー (optional)</param>
        /// <param name="from">メッセージを投稿したユーザー (optional)</param>
        /// <param name="citation">引用しているメッセージ (optional)</param>
        /// <param name="bot">メッセージを投稿したユーザーがBotかどうか (optional)</param>
        /// <param name="hasURL">メッセージがURLを含むか (optional)</param>
        /// <param name="hasAttachments">メッセージが添付ファイルを含むか (optional)</param>
        /// <param name="hasImage">メッセージが画像を含むか (optional)</param>
        /// <param name="hasVideo">メッセージが動画を含むか (optional)</param>
        /// <param name="hasAudio">メッセージが音声ファイルを含むか (optional)</param>
        /// <param name="limit">検索結果から取得するメッセージの最大件数 (optional)</param>
        /// <param name="offset">検索結果から取得するメッセージのオフセット (optional)</param>
        /// <param name="sort">ソート順 (作成日時が新しい &#x60;createdAt&#x60;, 作成日時が古い &#x60;-createdAt&#x60;, 更新日時が新しい &#x60;updatedAt&#x60;, 更新日時が古い &#x60;-updatedAt&#x60;) (optional, default to -createdAt)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchMessagesApiResponse"/>&gt;</returns>
        public async Task<ISearchMessagesApiResponse?> SearchMessagesOrDefaultAsync(Option<string> word = default, Option<DateTimeOffset> after = default, Option<DateTimeOffset> before = default, Option<Guid> varIn = default, Option<List<Guid>> to = default, Option<List<Guid>> from = default, Option<Guid> citation = default, Option<bool> bot = default, Option<bool> hasURL = default, Option<bool> hasAttachments = default, Option<bool> hasImage = default, Option<bool> hasVideo = default, Option<bool> hasAudio = default, Option<int> limit = default, Option<int> offset = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchMessagesAsync(word, after, before, varIn, to, from, citation, bot, hasURL, hasAttachments, hasImage, hasVideo, hasAudio, limit, offset, sort, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// メッセージを検索 メッセージを検索します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="word">検索ワード Simple-Query-String-Syntaxをパースして検索します  (optional)</param>
        /// <param name="after">投稿日時が指定日時より後 (optional)</param>
        /// <param name="before">投稿日時が指定日時より前 (optional)</param>
        /// <param name="varIn">メッセージが投稿されたチャンネル (optional)</param>
        /// <param name="to">メンションされたユーザー (optional)</param>
        /// <param name="from">メッセージを投稿したユーザー (optional)</param>
        /// <param name="citation">引用しているメッセージ (optional)</param>
        /// <param name="bot">メッセージを投稿したユーザーがBotかどうか (optional)</param>
        /// <param name="hasURL">メッセージがURLを含むか (optional)</param>
        /// <param name="hasAttachments">メッセージが添付ファイルを含むか (optional)</param>
        /// <param name="hasImage">メッセージが画像を含むか (optional)</param>
        /// <param name="hasVideo">メッセージが動画を含むか (optional)</param>
        /// <param name="hasAudio">メッセージが音声ファイルを含むか (optional)</param>
        /// <param name="limit">検索結果から取得するメッセージの最大件数 (optional)</param>
        /// <param name="offset">検索結果から取得するメッセージのオフセット (optional)</param>
        /// <param name="sort">ソート順 (作成日時が新しい &#x60;createdAt&#x60;, 作成日時が古い &#x60;-createdAt&#x60;, 更新日時が新しい &#x60;updatedAt&#x60;, 更新日時が古い &#x60;-updatedAt&#x60;) (optional, default to -createdAt)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchMessagesApiResponse"/>&gt;</returns>
        public async Task<ISearchMessagesApiResponse> SearchMessagesAsync(Option<string> word = default, Option<DateTimeOffset> after = default, Option<DateTimeOffset> before = default, Option<Guid> varIn = default, Option<List<Guid>> to = default, Option<List<Guid>> from = default, Option<Guid> citation = default, Option<bool> bot = default, Option<bool> hasURL = default, Option<bool> hasAttachments = default, Option<bool> hasImage = default, Option<bool> hasVideo = default, Option<bool> hasAudio = default, Option<int> limit = default, Option<int> offset = default, Option<string> sort = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchMessages(word, to, from, sort);

                FormatSearchMessages(ref word, ref after, ref before, ref varIn, to, from, ref citation, ref bot, ref hasURL, ref hasAttachments, ref hasImage, ref hasVideo, ref hasAudio, ref limit, ref offset, ref sort);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/messages";

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (word.IsSet)
                        parseQueryStringLocalVar["word"] = ClientUtils.ParameterToString(word.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (varIn.IsSet)
                        parseQueryStringLocalVar["in"] = ClientUtils.ParameterToString(varIn.Value);

                    if (to.IsSet)
                        parseQueryStringLocalVar["to"] = ClientUtils.ParameterToString(to.Value);

                    if (from.IsSet)
                        parseQueryStringLocalVar["from"] = ClientUtils.ParameterToString(from.Value);

                    if (citation.IsSet)
                        parseQueryStringLocalVar["citation"] = ClientUtils.ParameterToString(citation.Value);

                    if (bot.IsSet)
                        parseQueryStringLocalVar["bot"] = ClientUtils.ParameterToString(bot.Value);

                    if (hasURL.IsSet)
                        parseQueryStringLocalVar["hasURL"] = ClientUtils.ParameterToString(hasURL.Value);

                    if (hasAttachments.IsSet)
                        parseQueryStringLocalVar["hasAttachments"] = ClientUtils.ParameterToString(hasAttachments.Value);

                    if (hasImage.IsSet)
                        parseQueryStringLocalVar["hasImage"] = ClientUtils.ParameterToString(hasImage.Value);

                    if (hasVideo.IsSet)
                        parseQueryStringLocalVar["hasVideo"] = ClientUtils.ParameterToString(hasVideo.Value);

                    if (hasAudio.IsSet)
                        parseQueryStringLocalVar["hasAudio"] = ClientUtils.ParameterToString(hasAudio.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (offset.IsSet)
                        parseQueryStringLocalVar["offset"] = ClientUtils.ParameterToString(offset.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SearchMessagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchMessagesApiResponse>();

                        SearchMessagesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/messages", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSearchMessagesDefaultImplementation(apiResponseLocalVar, word, after, before, varIn, to, from, citation, bot, hasURL, hasAttachments, hasImage, hasVideo, hasAudio, limit, offset, sort);

                        Events.ExecuteOnSearchMessages(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchMessagesDefaultImplementation(e, "/messages", uriBuilderLocalVar.Path, word, after, before, varIn, to, from, citation, bot, hasURL, hasAttachments, hasImage, hasVideo, hasAudio, limit, offset, sort);
                Events.ExecuteOnErrorSearchMessages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchMessagesApiResponse"/>
        /// </summary>
        public partial class SearchMessagesApiResponse : Traq.Client.ApiResponse, ISearchMessagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchMessagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchMessagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchMessagesApiResponse(ILogger<SearchMessagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.MessageSearchResult? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.MessageSearchResult>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.MessageSearchResult? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 503 ServiceUnavailable
            /// </summary>
            /// <returns></returns>
            public bool IsServiceUnavailable => 503 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
