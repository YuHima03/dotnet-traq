// <auto-generated>
/*
 * traQ v3
 *
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Traq.Client;
using Traq.Model;
using System.Diagnostics.CodeAnalysis;

namespace Traq.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IUserTagApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        UserTagApiEvents Events { get; }

        /// <summary>
        /// 自分にタグを追加
        /// </summary>
        /// <remarks>
        /// 自分に新しくタグを追加します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMyUserTagApiResponse"/>&gt;</returns>
        Task<IAddMyUserTagApiResponse> AddMyUserTagAsync(Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分にタグを追加
        /// </summary>
        /// <remarks>
        /// 自分に新しくタグを追加します。
        /// </remarks>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMyUserTagApiResponse"/>?&gt;</returns>
        Task<IAddMyUserTagApiResponse?> AddMyUserTagOrDefaultAsync(Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーにタグを追加
        /// </summary>
        /// <remarks>
        /// 指定したユーザーに指定したタグを追加します。 Webhookユーザーにタグを追加することは出来ません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUserTagApiResponse"/>&gt;</returns>
        Task<IAddUserTagApiResponse> AddUserTagAsync(Guid userId, Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーにタグを追加
        /// </summary>
        /// <remarks>
        /// 指定したユーザーに指定したタグを追加します。 Webhookユーザーにタグを追加することは出来ません。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUserTagApiResponse"/>?&gt;</returns>
        Task<IAddUserTagApiResponse?> AddUserTagOrDefaultAsync(Guid userId, Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のタグを編集
        /// </summary>
        /// <remarks>
        /// 自分の指定したタグの状態を変更します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditMyUserTagApiResponse"/>&gt;</returns>
        Task<IEditMyUserTagApiResponse> EditMyUserTagAsync(Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のタグを編集
        /// </summary>
        /// <remarks>
        /// 自分の指定したタグの状態を変更します。
        /// </remarks>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditMyUserTagApiResponse"/>?&gt;</returns>
        Task<IEditMyUserTagApiResponse?> EditMyUserTagOrDefaultAsync(Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのタグを編集
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの指定したタグの状態を変更します。 他人の状態は変更できません。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserTagApiResponse"/>&gt;</returns>
        Task<IEditUserTagApiResponse> EditUserTagAsync(Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのタグを編集
        /// </summary>
        /// <remarks>
        /// 指定したユーザーの指定したタグの状態を変更します。 他人の状態は変更できません。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserTagApiResponse"/>?&gt;</returns>
        Task<IEditUserTagApiResponse?> EditUserTagOrDefaultAsync(Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のタグリストを取得
        /// </summary>
        /// <remarks>
        /// 自分に付けられているタグの配列を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyUserTagsApiResponse"/>&gt;</returns>
        Task<IGetMyUserTagsApiResponse> GetMyUserTagsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分のタグリストを取得
        /// </summary>
        /// <remarks>
        /// 自分に付けられているタグの配列を取得します。
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyUserTagsApiResponse"/>?&gt;</returns>
        Task<IGetMyUserTagsApiResponse?> GetMyUserTagsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// タグ情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したタグの情報を取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagApiResponse"/>&gt;</returns>
        Task<IGetTagApiResponse> GetTagAsync(Guid tagId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// タグ情報を取得
        /// </summary>
        /// <remarks>
        /// 指定したタグの情報を取得します。
        /// </remarks>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagApiResponse"/>?&gt;</returns>
        Task<IGetTagApiResponse?> GetTagOrDefaultAsync(Guid tagId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのタグリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのタグリストを取得します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserTagsApiResponse"/>&gt;</returns>
        Task<IGetUserTagsApiResponse> GetUserTagsAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーのタグリストを取得
        /// </summary>
        /// <remarks>
        /// 指定したユーザーのタグリストを取得します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserTagsApiResponse"/>?&gt;</returns>
        Task<IGetUserTagsApiResponse?> GetUserTagsOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分からタグを削除します
        /// </summary>
        /// <remarks>
        /// 既に存在しないタグを削除しようとした場合は204を返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMyUserTagApiResponse"/>&gt;</returns>
        Task<IRemoveMyUserTagApiResponse> RemoveMyUserTagAsync(Guid tagId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// 自分からタグを削除します
        /// </summary>
        /// <remarks>
        /// 既に存在しないタグを削除しようとした場合は204を返します。
        /// </remarks>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMyUserTagApiResponse"/>?&gt;</returns>
        Task<IRemoveMyUserTagApiResponse?> RemoveMyUserTagOrDefaultAsync(Guid tagId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーからタグを削除します
        /// </summary>
        /// <remarks>
        /// 既に存在しないタグを削除しようとした場合は204を返します。
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUserTagApiResponse"/>&gt;</returns>
        Task<IRemoveUserTagApiResponse> RemoveUserTagAsync(Guid userId, Guid tagId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// ユーザーからタグを削除します
        /// </summary>
        /// <remarks>
        /// 既に存在しないタグを削除しようとした場合は204を返します。
        /// </remarks>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUserTagApiResponse"/>?&gt;</returns>
        Task<IRemoveUserTagApiResponse?> RemoveUserTagOrDefaultAsync(Guid userId, Guid tagId, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddMyUserTagApiResponse"/>
    /// </summary>
    public interface IAddMyUserTagApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.UserTag?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }
    }

    /// <summary>
    /// The <see cref="IAddUserTagApiResponse"/>
    /// </summary>
    public interface IAddUserTagApiResponse : Traq.Client.IApiResponse, ICreated<Traq.Model.UserTag?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }
    }

    /// <summary>
    /// The <see cref="IEditMyUserTagApiResponse"/>
    /// </summary>
    public interface IEditMyUserTagApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IEditUserTagApiResponse"/>
    /// </summary>
    public interface IEditUserTagApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetMyUserTagsApiResponse"/>
    /// </summary>
    public interface IGetMyUserTagsApiResponse : Traq.Client.IApiResponse, IOk<List<UserTag>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetTagApiResponse"/>
    /// </summary>
    public interface IGetTagApiResponse : Traq.Client.IApiResponse, IOk<Traq.Model.Tag?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetUserTagsApiResponse"/>
    /// </summary>
    public interface IGetUserTagsApiResponse : Traq.Client.IApiResponse, IOk<List<UserTag>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveMyUserTagApiResponse"/>
    /// </summary>
    public interface IRemoveMyUserTagApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveUserTagApiResponse"/>
    /// </summary>
    public interface IRemoveUserTagApiResponse : Traq.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class UserTagApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddMyUserTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddMyUserTag;

        internal void ExecuteOnAddMyUserTag(UserTagApi.AddMyUserTagApiResponse apiResponse)
        {
            OnAddMyUserTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddMyUserTag(Exception exception)
        {
            OnErrorAddMyUserTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddUserTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddUserTag;

        internal void ExecuteOnAddUserTag(UserTagApi.AddUserTagApiResponse apiResponse)
        {
            OnAddUserTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddUserTag(Exception exception)
        {
            OnErrorAddUserTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditMyUserTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditMyUserTag;

        internal void ExecuteOnEditMyUserTag(UserTagApi.EditMyUserTagApiResponse apiResponse)
        {
            OnEditMyUserTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditMyUserTag(Exception exception)
        {
            OnErrorEditMyUserTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEditUserTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEditUserTag;

        internal void ExecuteOnEditUserTag(UserTagApi.EditUserTagApiResponse apiResponse)
        {
            OnEditUserTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEditUserTag(Exception exception)
        {
            OnErrorEditUserTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMyUserTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMyUserTags;

        internal void ExecuteOnGetMyUserTags(UserTagApi.GetMyUserTagsApiResponse apiResponse)
        {
            OnGetMyUserTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMyUserTags(Exception exception)
        {
            OnErrorGetMyUserTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTag;

        internal void ExecuteOnGetTag(UserTagApi.GetTagApiResponse apiResponse)
        {
            OnGetTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTag(Exception exception)
        {
            OnErrorGetTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetUserTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetUserTags;

        internal void ExecuteOnGetUserTags(UserTagApi.GetUserTagsApiResponse apiResponse)
        {
            OnGetUserTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetUserTags(Exception exception)
        {
            OnErrorGetUserTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveMyUserTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveMyUserTag;

        internal void ExecuteOnRemoveMyUserTag(UserTagApi.RemoveMyUserTagApiResponse apiResponse)
        {
            OnRemoveMyUserTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveMyUserTag(Exception exception)
        {
            OnErrorRemoveMyUserTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveUserTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveUserTag;

        internal void ExecuteOnRemoveUserTag(UserTagApi.RemoveUserTagApiResponse apiResponse)
        {
            OnRemoveUserTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveUserTag(Exception exception)
        {
            OnErrorRemoveUserTag?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class UserTagApi : IUserTagApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<UserTagApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public UserTagApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="UserTagApi"/> class.
        /// </summary>
        /// <returns></returns>
        public UserTagApi(ILogger<UserTagApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, UserTagApiEvents userTagApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<UserTagApi>();
            HttpClient = httpClient;
            Events = userTagApiEvents;
            ApiKeyProvider = apiKeyProvider;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatAddMyUserTag(Option<PostUserTagRequest> postUserTagRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postUserTagRequest"></param>
        /// <returns></returns>
        private void ValidateAddMyUserTag(Option<PostUserTagRequest> postUserTagRequest)
        {
            if (postUserTagRequest.IsSet && postUserTagRequest.Value == null)
                throw new ArgumentNullException(nameof(postUserTagRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postUserTagRequest"></param>
        private void AfterAddMyUserTagDefaultImplementation(IAddMyUserTagApiResponse apiResponseLocalVar, Option<PostUserTagRequest> postUserTagRequest)
        {
            bool suppressDefaultLog = false;
            AfterAddMyUserTag(ref suppressDefaultLog, apiResponseLocalVar, postUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="postUserTagRequest"></param>
        partial void AfterAddMyUserTag(ref bool suppressDefaultLog, IAddMyUserTagApiResponse apiResponseLocalVar, Option<PostUserTagRequest> postUserTagRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postUserTagRequest"></param>
        private void OnErrorAddMyUserTagDefaultImplementation(Exception exception, string pathFormat, string path, Option<PostUserTagRequest> postUserTagRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorAddMyUserTag(ref suppressDefaultLog, exception, pathFormat, path, postUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="postUserTagRequest"></param>
        partial void OnErrorAddMyUserTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Option<PostUserTagRequest> postUserTagRequest);

        /// <summary>
        /// 自分にタグを追加 自分に新しくタグを追加します。
        /// </summary>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMyUserTagApiResponse"/>&gt;</returns>
        public async Task<IAddMyUserTagApiResponse?> AddMyUserTagOrDefaultAsync(Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddMyUserTagAsync(postUserTagRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 自分にタグを追加 自分に新しくタグを追加します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddMyUserTagApiResponse"/>&gt;</returns>
        public async Task<IAddMyUserTagApiResponse> AddMyUserTagAsync(Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddMyUserTag(postUserTagRequest);

                FormatAddMyUserTag(postUserTagRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/tags";

                    if (postUserTagRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postUserTagRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postUserTagRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AddMyUserTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddMyUserTagApiResponse>();

                        AddMyUserTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/tags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddMyUserTagDefaultImplementation(apiResponseLocalVar, postUserTagRequest);

                        Events.ExecuteOnAddMyUserTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddMyUserTagDefaultImplementation(e, "/users/me/tags", uriBuilderLocalVar.Path, postUserTagRequest);
                Events.ExecuteOnErrorAddMyUserTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddMyUserTagApiResponse"/>
        /// </summary>
        public partial class AddMyUserTagApiResponse : Traq.Client.ApiResponse, IAddMyUserTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddMyUserTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddMyUserTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddMyUserTagApiResponse(ILogger<AddMyUserTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.UserTag? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.UserTag>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.UserTag? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAddUserTag(ref Guid userId, Option<PostUserTagRequest> postUserTagRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="postUserTagRequest"></param>
        /// <returns></returns>
        private void ValidateAddUserTag(Option<PostUserTagRequest> postUserTagRequest)
        {
            if (postUserTagRequest.IsSet && postUserTagRequest.Value == null)
                throw new ArgumentNullException(nameof(postUserTagRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="postUserTagRequest"></param>
        private void AfterAddUserTagDefaultImplementation(IAddUserTagApiResponse apiResponseLocalVar, Guid userId, Option<PostUserTagRequest> postUserTagRequest)
        {
            bool suppressDefaultLog = false;
            AfterAddUserTag(ref suppressDefaultLog, apiResponseLocalVar, userId, postUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="postUserTagRequest"></param>
        partial void AfterAddUserTag(ref bool suppressDefaultLog, IAddUserTagApiResponse apiResponseLocalVar, Guid userId, Option<PostUserTagRequest> postUserTagRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="postUserTagRequest"></param>
        private void OnErrorAddUserTagDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Option<PostUserTagRequest> postUserTagRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorAddUserTag(ref suppressDefaultLog, exception, pathFormat, path, userId, postUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="postUserTagRequest"></param>
        partial void OnErrorAddUserTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Option<PostUserTagRequest> postUserTagRequest);

        /// <summary>
        /// ユーザーにタグを追加 指定したユーザーに指定したタグを追加します。 Webhookユーザーにタグを追加することは出来ません。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUserTagApiResponse"/>&gt;</returns>
        public async Task<IAddUserTagApiResponse?> AddUserTagOrDefaultAsync(Guid userId, Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddUserTagAsync(userId, postUserTagRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーにタグを追加 指定したユーザーに指定したタグを追加します。 Webhookユーザーにタグを追加することは出来ません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="postUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddUserTagApiResponse"/>&gt;</returns>
        public async Task<IAddUserTagApiResponse> AddUserTagAsync(Guid userId, Option<PostUserTagRequest> postUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddUserTag(postUserTagRequest);

                FormatAddUserTag(ref userId, postUserTagRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/tags";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    if (postUserTagRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (postUserTagRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(postUserTagRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AddUserTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddUserTagApiResponse>();

                        AddUserTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/tags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddUserTagDefaultImplementation(apiResponseLocalVar, userId, postUserTagRequest);

                        Events.ExecuteOnAddUserTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddUserTagDefaultImplementation(e, "/users/{userId}/tags", uriBuilderLocalVar.Path, userId, postUserTagRequest);
                Events.ExecuteOnErrorAddUserTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddUserTagApiResponse"/>
        /// </summary>
        public partial class AddUserTagApiResponse : Traq.Client.ApiResponse, IAddUserTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddUserTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddUserTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddUserTagApiResponse(ILogger<AddUserTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Traq.Model.UserTag? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.UserTag>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Traq.Model.UserTag? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditMyUserTag(ref Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="patchUserTagRequest"></param>
        /// <returns></returns>
        private void ValidateEditMyUserTag(Option<PatchUserTagRequest> patchUserTagRequest)
        {
            if (patchUserTagRequest.IsSet && patchUserTagRequest.Value == null)
                throw new ArgumentNullException(nameof(patchUserTagRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        private void AfterEditMyUserTagDefaultImplementation(IEditMyUserTagApiResponse apiResponseLocalVar, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditMyUserTag(ref suppressDefaultLog, apiResponseLocalVar, tagId, patchUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        partial void AfterEditMyUserTag(ref bool suppressDefaultLog, IEditMyUserTagApiResponse apiResponseLocalVar, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        private void OnErrorEditMyUserTagDefaultImplementation(Exception exception, string pathFormat, string path, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditMyUserTag(ref suppressDefaultLog, exception, pathFormat, path, tagId, patchUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        partial void OnErrorEditMyUserTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest);

        /// <summary>
        /// 自分のタグを編集 自分の指定したタグの状態を変更します。
        /// </summary>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditMyUserTagApiResponse"/>&gt;</returns>
        public async Task<IEditMyUserTagApiResponse?> EditMyUserTagOrDefaultAsync(Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditMyUserTagAsync(tagId, patchUserTagRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 自分のタグを編集 自分の指定したタグの状態を変更します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditMyUserTagApiResponse"/>&gt;</returns>
        public async Task<IEditMyUserTagApiResponse> EditMyUserTagAsync(Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditMyUserTag(patchUserTagRequest);

                FormatEditMyUserTag(ref tagId, patchUserTagRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/tags/{tagId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtagId%7D", Uri.EscapeDataString(tagId.ToString()));

                    if (patchUserTagRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchUserTagRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchUserTagRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditMyUserTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditMyUserTagApiResponse>();

                        EditMyUserTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/tags/{tagId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditMyUserTagDefaultImplementation(apiResponseLocalVar, tagId, patchUserTagRequest);

                        Events.ExecuteOnEditMyUserTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditMyUserTagDefaultImplementation(e, "/users/me/tags/{tagId}", uriBuilderLocalVar.Path, tagId, patchUserTagRequest);
                Events.ExecuteOnErrorEditMyUserTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditMyUserTagApiResponse"/>
        /// </summary>
        public partial class EditMyUserTagApiResponse : Traq.Client.ApiResponse, IEditMyUserTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditMyUserTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditMyUserTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditMyUserTagApiResponse(ILogger<EditMyUserTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEditUserTag(ref Guid userId, ref Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="patchUserTagRequest"></param>
        /// <returns></returns>
        private void ValidateEditUserTag(Option<PatchUserTagRequest> patchUserTagRequest)
        {
            if (patchUserTagRequest.IsSet && patchUserTagRequest.Value == null)
                throw new ArgumentNullException(nameof(patchUserTagRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        private void AfterEditUserTagDefaultImplementation(IEditUserTagApiResponse apiResponseLocalVar, Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest)
        {
            bool suppressDefaultLog = false;
            AfterEditUserTag(ref suppressDefaultLog, apiResponseLocalVar, userId, tagId, patchUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        partial void AfterEditUserTag(ref bool suppressDefaultLog, IEditUserTagApiResponse apiResponseLocalVar, Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        private void OnErrorEditUserTagDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest)
        {
            bool suppressDefaultLog = false;
            OnErrorEditUserTag(ref suppressDefaultLog, exception, pathFormat, path, userId, tagId, patchUserTagRequest);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        /// <param name="patchUserTagRequest"></param>
        partial void OnErrorEditUserTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest);

        /// <summary>
        /// ユーザーのタグを編集 指定したユーザーの指定したタグの状態を変更します。 他人の状態は変更できません。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserTagApiResponse"/>&gt;</returns>
        public async Task<IEditUserTagApiResponse?> EditUserTagOrDefaultAsync(Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EditUserTagAsync(userId, tagId, patchUserTagRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーのタグを編集 指定したユーザーの指定したタグの状態を変更します。 他人の状態は変更できません。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="patchUserTagRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEditUserTagApiResponse"/>&gt;</returns>
        public async Task<IEditUserTagApiResponse> EditUserTagAsync(Guid userId, Guid tagId, Option<PatchUserTagRequest> patchUserTagRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEditUserTag(patchUserTagRequest);

                FormatEditUserTag(ref userId, ref tagId, patchUserTagRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/tags/{tagId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtagId%7D", Uri.EscapeDataString(tagId.ToString()));

                    if (patchUserTagRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (patchUserTagRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(patchUserTagRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EditUserTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EditUserTagApiResponse>();

                        EditUserTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/tags/{tagId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEditUserTagDefaultImplementation(apiResponseLocalVar, userId, tagId, patchUserTagRequest);

                        Events.ExecuteOnEditUserTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEditUserTagDefaultImplementation(e, "/users/{userId}/tags/{tagId}", uriBuilderLocalVar.Path, userId, tagId, patchUserTagRequest);
                Events.ExecuteOnErrorEditUserTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EditUserTagApiResponse"/>
        /// </summary>
        public partial class EditUserTagApiResponse : Traq.Client.ApiResponse, IEditUserTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EditUserTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EditUserTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EditUserTagApiResponse(ILogger<EditUserTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetMyUserTagsDefaultImplementation(IGetMyUserTagsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetMyUserTags(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetMyUserTags(ref bool suppressDefaultLog, IGetMyUserTagsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        private void OnErrorGetMyUserTagsDefaultImplementation(Exception exception, string pathFormat, string path)
        {
            bool suppressDefaultLog = false;
            OnErrorGetMyUserTags(ref suppressDefaultLog, exception, pathFormat, path);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        partial void OnErrorGetMyUserTags(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path);

        /// <summary>
        /// 自分のタグリストを取得 自分に付けられているタグの配列を取得します。
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyUserTagsApiResponse"/>&gt;</returns>
        public async Task<IGetMyUserTagsApiResponse?> GetMyUserTagsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMyUserTagsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 自分のタグリストを取得 自分に付けられているタグの配列を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMyUserTagsApiResponse"/>&gt;</returns>
        public async Task<IGetMyUserTagsApiResponse> GetMyUserTagsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/tags";

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMyUserTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMyUserTagsApiResponse>();

                        GetMyUserTagsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/tags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMyUserTagsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetMyUserTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMyUserTagsDefaultImplementation(e, "/users/me/tags", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetMyUserTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMyUserTagsApiResponse"/>
        /// </summary>
        public partial class GetMyUserTagsApiResponse : Traq.Client.ApiResponse, IGetMyUserTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMyUserTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMyUserTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMyUserTagsApiResponse(ILogger<GetMyUserTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<UserTag>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<UserTag>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<UserTag>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTag(ref Guid tagId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tagId"></param>
        private void AfterGetTagDefaultImplementation(IGetTagApiResponse apiResponseLocalVar, Guid tagId)
        {
            bool suppressDefaultLog = false;
            AfterGetTag(ref suppressDefaultLog, apiResponseLocalVar, tagId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tagId"></param>
        partial void AfterGetTag(ref bool suppressDefaultLog, IGetTagApiResponse apiResponseLocalVar, Guid tagId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="tagId"></param>
        private void OnErrorGetTagDefaultImplementation(Exception exception, string pathFormat, string path, Guid tagId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetTag(ref suppressDefaultLog, exception, pathFormat, path, tagId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="tagId"></param>
        partial void OnErrorGetTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid tagId);

        /// <summary>
        /// タグ情報を取得 指定したタグの情報を取得します。
        /// </summary>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagApiResponse"/>&gt;</returns>
        public async Task<IGetTagApiResponse?> GetTagOrDefaultAsync(Guid tagId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTagAsync(tagId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// タグ情報を取得 指定したタグの情報を取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTagApiResponse"/>&gt;</returns>
        public async Task<IGetTagApiResponse> GetTagAsync(Guid tagId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetTag(ref tagId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/tags/{tagId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtagId%7D", Uri.EscapeDataString(tagId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTagApiResponse>();

                        GetTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/tags/{tagId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTagDefaultImplementation(apiResponseLocalVar, tagId);

                        Events.ExecuteOnGetTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTagDefaultImplementation(e, "/tags/{tagId}", uriBuilderLocalVar.Path, tagId);
                Events.ExecuteOnErrorGetTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTagApiResponse"/>
        /// </summary>
        public partial class GetTagApiResponse : Traq.Client.ApiResponse, IGetTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTagApiResponse(ILogger<GetTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Traq.Model.Tag? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Traq.Model.Tag>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Traq.Model.Tag? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetUserTags(ref Guid userId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        private void AfterGetUserTagsDefaultImplementation(IGetUserTagsApiResponse apiResponseLocalVar, Guid userId)
        {
            bool suppressDefaultLog = false;
            AfterGetUserTags(ref suppressDefaultLog, apiResponseLocalVar, userId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        partial void AfterGetUserTags(ref bool suppressDefaultLog, IGetUserTagsApiResponse apiResponseLocalVar, Guid userId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        private void OnErrorGetUserTagsDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId)
        {
            bool suppressDefaultLog = false;
            OnErrorGetUserTags(ref suppressDefaultLog, exception, pathFormat, path, userId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        partial void OnErrorGetUserTags(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId);

        /// <summary>
        /// ユーザーのタグリストを取得 指定したユーザーのタグリストを取得します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserTagsApiResponse"/>&gt;</returns>
        public async Task<IGetUserTagsApiResponse?> GetUserTagsOrDefaultAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetUserTagsAsync(userId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーのタグリストを取得 指定したユーザーのタグリストを取得します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetUserTagsApiResponse"/>&gt;</returns>
        public async Task<IGetUserTagsApiResponse> GetUserTagsAsync(Guid userId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetUserTags(ref userId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/tags";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetUserTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetUserTagsApiResponse>();

                        GetUserTagsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/tags", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetUserTagsDefaultImplementation(apiResponseLocalVar, userId);

                        Events.ExecuteOnGetUserTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetUserTagsDefaultImplementation(e, "/users/{userId}/tags", uriBuilderLocalVar.Path, userId);
                Events.ExecuteOnErrorGetUserTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetUserTagsApiResponse"/>
        /// </summary>
        public partial class GetUserTagsApiResponse : Traq.Client.ApiResponse, IGetUserTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetUserTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetUserTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetUserTagsApiResponse(ILogger<GetUserTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<UserTag>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<UserTag>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<UserTag>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveMyUserTag(ref Guid tagId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tagId"></param>
        private void AfterRemoveMyUserTagDefaultImplementation(IRemoveMyUserTagApiResponse apiResponseLocalVar, Guid tagId)
        {
            bool suppressDefaultLog = false;
            AfterRemoveMyUserTag(ref suppressDefaultLog, apiResponseLocalVar, tagId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tagId"></param>
        partial void AfterRemoveMyUserTag(ref bool suppressDefaultLog, IRemoveMyUserTagApiResponse apiResponseLocalVar, Guid tagId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="tagId"></param>
        private void OnErrorRemoveMyUserTagDefaultImplementation(Exception exception, string pathFormat, string path, Guid tagId)
        {
            bool suppressDefaultLog = false;
            OnErrorRemoveMyUserTag(ref suppressDefaultLog, exception, pathFormat, path, tagId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="tagId"></param>
        partial void OnErrorRemoveMyUserTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid tagId);

        /// <summary>
        /// 自分からタグを削除します 既に存在しないタグを削除しようとした場合は204を返します。
        /// </summary>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMyUserTagApiResponse"/>&gt;</returns>
        public async Task<IRemoveMyUserTagApiResponse?> RemoveMyUserTagOrDefaultAsync(Guid tagId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveMyUserTagAsync(tagId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// 自分からタグを削除します 既に存在しないタグを削除しようとした場合は204を返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveMyUserTagApiResponse"/>&gt;</returns>
        public async Task<IRemoveMyUserTagApiResponse> RemoveMyUserTagAsync(Guid tagId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRemoveMyUserTag(ref tagId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/me/tags/{tagId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtagId%7D", Uri.EscapeDataString(tagId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemoveMyUserTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveMyUserTagApiResponse>();

                        RemoveMyUserTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/me/tags/{tagId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemoveMyUserTagDefaultImplementation(apiResponseLocalVar, tagId);

                        Events.ExecuteOnRemoveMyUserTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveMyUserTagDefaultImplementation(e, "/users/me/tags/{tagId}", uriBuilderLocalVar.Path, tagId);
                Events.ExecuteOnErrorRemoveMyUserTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveMyUserTagApiResponse"/>
        /// </summary>
        public partial class RemoveMyUserTagApiResponse : Traq.Client.ApiResponse, IRemoveMyUserTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveMyUserTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveMyUserTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveMyUserTagApiResponse(ILogger<RemoveMyUserTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveUserTag(ref Guid userId, ref Guid tagId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        private void AfterRemoveUserTagDefaultImplementation(IRemoveUserTagApiResponse apiResponseLocalVar, Guid userId, Guid tagId)
        {
            bool suppressDefaultLog = false;
            AfterRemoveUserTag(ref suppressDefaultLog, apiResponseLocalVar, userId, tagId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        partial void AfterRemoveUserTag(ref bool suppressDefaultLog, IRemoveUserTagApiResponse apiResponseLocalVar, Guid userId, Guid tagId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        private void OnErrorRemoveUserTagDefaultImplementation(Exception exception, string pathFormat, string path, Guid userId, Guid tagId)
        {
            bool suppressDefaultLog = false;
            OnErrorRemoveUserTag(ref suppressDefaultLog, exception, pathFormat, path, userId, tagId);
            if (!suppressDefaultLog)
                Logger.LogError(exception, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="exception"></param>
        /// <param name="pathFormat"></param>
        /// <param name="path"></param>
        /// <param name="userId"></param>
        /// <param name="tagId"></param>
        partial void OnErrorRemoveUserTag(ref bool suppressDefaultLog, Exception exception, string pathFormat, string path, Guid userId, Guid tagId);

        /// <summary>
        /// ユーザーからタグを削除します 既に存在しないタグを削除しようとした場合は204を返します。
        /// </summary>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUserTagApiResponse"/>&gt;</returns>
        public async Task<IRemoveUserTagApiResponse?> RemoveUserTagOrDefaultAsync(Guid userId, Guid tagId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveUserTagAsync(userId, tagId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ユーザーからタグを削除します 既に存在しないタグを削除しようとした場合は204を返します。
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">ユーザーUUID</param>
        /// <param name="tagId">タグUUID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveUserTagApiResponse"/>&gt;</returns>
        public async Task<IRemoveUserTagApiResponse> RemoveUserTagAsync(Guid userId, Guid tagId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRemoveUserTag(ref userId, ref tagId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = ClientUtils.CONTEXT_PATH + "/users/{userId}/tags/{tagId}";
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BuserId%7D", Uri.EscapeDataString(userId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BtagId%7D", Uri.EscapeDataString(tagId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemoveUserTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveUserTagApiResponse>();

                        RemoveUserTagApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/users/{userId}/tags/{tagId}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemoveUserTagDefaultImplementation(apiResponseLocalVar, userId, tagId);

                        Events.ExecuteOnRemoveUserTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveUserTagDefaultImplementation(e, "/users/{userId}/tags/{tagId}", uriBuilderLocalVar.Path, userId, tagId);
                Events.ExecuteOnErrorRemoveUserTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveUserTagApiResponse"/>
        /// </summary>
        public partial class RemoveUserTagApiResponse : Traq.Client.ApiResponse, IRemoveUserTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveUserTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveUserTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveUserTagApiResponse(ILogger<RemoveUserTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
